import {
  Clock,
  Color,
  LinearEncoding,
  LoadingManager,
  NoToneMapping,
  OrthographicCamera,
  PCFShadowMap,
  PerspectiveCamera,
  Scene,
  TextureLoader,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-77HLCOWG.js";
import {
  computed,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  inject,
  nextTick,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  provide,
  reactive,
  ref,
  shallowRef,
  toRefs,
  unref,
  watch
} from "./chunk-QO6ZHO7P.js";

// node_modules/@vueuse/shared/index.mjs
var _a;
var isClient = typeof window !== "undefined";
var isString = (val) => typeof val === "string";
var noop = () => {
};
var isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}
function identity(arg) {
  return arg;
}
function createEventHook() {
  const fns = [];
  const off = (fn) => {
    const index = fns.indexOf(fn);
    if (index !== -1)
      fns.splice(index, 1);
  };
  const on = (fn) => {
    fns.push(fn);
    return {
      off: () => off(fn)
    };
  };
  const trigger = (param) => {
    fns.forEach((fn) => fn(param));
  };
  return {
    on,
    off,
    trigger
  };
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useSupported(callback, sync = false) {
  const isSupported = ref();
  const update = () => isSupported.value = Boolean(callback());
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
function useDevicePixelRatio({
  window: window2 = defaultWindow
} = {}) {
  if (!window2) {
    return {
      pixelRatio: ref(1)
    };
  }
  const pixelRatio = ref(1);
  const cleanups = [];
  const cleanup = () => {
    cleanups.map((i) => i());
    cleanups.length = 0;
  };
  const observe = () => {
    pixelRatio.value = window2.devicePixelRatio;
    cleanup();
    const media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
    media.addEventListener("change", observe, { once: true });
    cleanups.push(() => {
      media.removeEventListener("change", observe);
    });
  };
  observe();
  tryOnScopeDispose(cleanup);
  return { pixelRatio };
}
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported.value && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref(false);
  let rafId = null;
  function loop() {
    if (!isActive.value || !window2)
      return;
    fn();
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      loop();
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { box = "content-box" } = options;
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  useResizeObserver(target, ([entry]) => {
    const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
    if (boxSize) {
      width.value = boxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
      height.value = boxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
    } else {
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }
  }, options);
  watch(() => unrefElement(target), (ele) => {
    width.value = ele ? initialSize.width : 0;
    height.value = ele ? initialSize.height : 0;
  });
  return {
    width,
    height
  };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = __spreadValues({
  linear: identity
}, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation)
    useEventListener("orientationchange", update, { passive: true });
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var Oe = ((e) => (e.Perspective = "Perspective", e.Orthographic = "Orthographic", e))(Oe || {});
var P = {
  cameras: []
};
var Ae = 45;
var E;
function Z() {
  const { width: e, height: t } = useWindowSize(), { setState: n } = oe();
  function a(i = "Perspective", f) {
    if (i === "Perspective") {
      const { near: u, far: m, fov: d } = f || {
        near: 0.1,
        far: 1e3,
        fov: Ae
      };
      E = new PerspectiveCamera(d, r.value, u, m), P.cameras.push(E);
    } else {
      const { left: u, right: m, top: d, bottom: w, near: C, far: x } = f || {
        left: -100,
        right: 100,
        top: 100,
        bottom: -100,
        near: 0.1,
        far: 1e3
      };
      E = new OrthographicCamera(u, m, d, w, C, x), P.cameras.push(E);
    }
    return P.cameras.push(E), E;
  }
  const r = computed(() => e.value / t.value), o = computed(() => P.cameras[0]);
  function s() {
    o.value instanceof PerspectiveCamera && (o.value.aspect = r.value), o.value.updateProjectionMatrix();
  }
  function c(i) {
    const f = inject("camera");
    i && f && (f.value = i, n("camera", f.value)), P.cameras.push(i), i instanceof PerspectiveCamera && (i.aspect = r.value), i.updateProjectionMatrix();
  }
  return watch(r, s), {
    activeCamera: o,
    createCamera: a,
    updateCamera: s,
    pushCamera: c
  };
}
var b = { ...three_module_exports };
delete b.Scene;
function be() {
  return {
    extend: (t) => {
      b = Object.assign(b, t);
    },
    catalogue: b
  };
}
var Be = (e) => typeof e < "u";
var V = (e) => !!e && e.constructor === Array;
function $e(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function q(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var K = "[TresJS \u25B2 \u25A0 \u25CF] ";
function W() {
  function e(a, r) {
    console.error(`${K} ${a}`, r || "");
  }
  function t(a) {
    console.warn(`${K} ${a}`);
  }
  function n(a, r) {
  }
  return {
    logError: e,
    logWarning: t,
    logMessage: n
  };
}
var Ie = ["rotation", "scale", "position"];
function ze(e) {
  const { logMessage: t, logError: n } = W();
  function a(r) {
    return Object.entries(r).filter(([o, s]) => {
      var c, i;
      return (i = (c = s == null ? void 0 : s.prototype) == null ? void 0 : c.constructor) == null ? void 0 : i.toString().includes("class");
    }).map(([o, s]) => {
      const c = `${e}${o}`, i = defineComponent({
        name: c,
        setup(f, { slots: u, attrs: m, ...d }) {
          t(c, {
            props: f,
            slots: u,
            attrs: m,
            ctx: d
          });
          let w;
          const { scene: C } = ae(), { pushCamera: x } = Z();
          function L() {
            if ((u == null ? void 0 : u.default) && (u == null ? void 0 : u.default())) {
              const y = u.default().map((l) => {
                var h2;
                let v;
                const g = l.type.name.replace(e, "");
                return (h2 = l == null ? void 0 : l.props) != null && h2.args ? v = new r[g](...l.props.args) : v = new r[g](), l != null && l.props && T(l.props, v), v;
              });
              w = new s(...y);
            } else
              m.args ? w = new s(...m.args) : w = new s();
            T(m, w), c.includes("Camera") && x(w), w.isObject3D && (C == null || C.value.add(w)), t("Instance added", C), d.expose(w);
          }
          function T(y, l) {
            Object.entries(y).forEach(([v, g]) => {
              const h2 = v.replace(/(-\w)/g, (M) => M[1].toUpperCase());
              if (!(h2 === "args" || g === void 0)) {
                Ie.includes(v) && g && (g = $e(g));
                try {
                  l[h2] && Be(l[h2].set) ? V(g) ? l[h2].set(...g) : l[h2].set(g) : (g === "" && (g = true), l[h2] = g);
                } catch (M) {
                  n(`There was an error setting ${h2} property`, M);
                }
              }
            }), y.ref && (y.ref = l);
          }
          return L(), () => {
          };
        }
      });
      return [c, i];
    });
  }
  return {
    createComponentInstances: a
  };
}
var ee = createEventHook();
var te = createEventHook();
var ne = createEventHook();
var Q = new Clock();
var { pause: De, resume: Fe, isActive: _e } = useRafFn(
  () => {
    const e = Q.getElapsedTime(), t = Q.getDelta();
    ee.trigger({ delta: t, elapsed: e }), te.trigger({ delta: t, elapsed: e }), ne.trigger({ delta: t, elapsed: e });
  },
  { immediate: false }
);
function re() {
  return {
    onBeforeLoop: ee.on,
    onLoop: te.on,
    onAfterLoop: ne.on,
    pause: De,
    resume: Fe,
    isActive: _e
  };
}
var je = shallowRef(new Scene());
function ae() {
  return {
    scene: je
  };
}
function Ue(e) {
  const t = { nodes: {}, materials: {} };
  return e && e.traverse((n) => {
    n.name && (t.nodes[n.name] = n), n.material && !t.materials[n.material.name] && (t.materials[n.material.name] = n.material);
  }), t;
}
async function Je(e, t, n, a, r) {
  const { logError: o } = W(), s = new e();
  r && r(s), n && n(e);
  const i = (Array.isArray(t) ? t : [t]).map(
    (f) => new Promise((u, m) => {
      s.load(
        f,
        (d) => {
          d.scene && Object.assign(d, Ue(d.scene)), u(d);
        },
        a,
        (d) => m(o("[useLoader] - Failed to load resource", d))
      );
    })
  );
  return V(t) ? await Promise.all(i) : await i[0];
}
async function qe(e) {
  const t = new LoadingManager(), n = new TextureLoader(t), a = (r) => new Promise((o, s) => {
    n.load(
      r,
      (c) => o(c),
      () => null,
      () => {
        s(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (V(e)) {
    const r = await Promise.all(e.map((o) => a(o)));
    return e.length > 1 ? r : r[0];
  } else {
    const { map: r, displacementMap: o, normalMap: s, roughnessMap: c, metalnessMap: i, aoMap: f } = e;
    return {
      map: r ? await a(r) : null,
      displacementMap: o ? await a(o) : null,
      normalMap: s ? await a(s) : null,
      roughnessMap: c ? await a(c) : null,
      metalnessMap: i ? await a(i) : null,
      aoMap: f ? await a(f) : null
    };
  }
}
var R = reactive({});
function oe() {
  function e(n) {
    return R[n];
  }
  function t(n, a) {
    R[n] = a;
  }
  return {
    state: R,
    ...toRefs(R),
    getState: e,
    setState: t
  };
}
var p = shallowRef();
var z = ref(false);
function Ve(e, t, n) {
  const {
    alpha: a = false,
    antialias: r,
    depth: o,
    logarithmicDepthBuffer: s,
    failIfMajorPerformanceCaveat: c,
    precision: i,
    premultipliedAlpha: f,
    stencil: u,
    shadows: m = false,
    shadowMapType: d = PCFShadowMap,
    physicallyCorrectLights: w = false,
    outputEncoding: C = LinearEncoding,
    toneMapping: x = NoToneMapping,
    toneMappingExposure: L = 1,
    context: T = void 0,
    powerPreference: y = "default",
    preserveDrawingBuffer: l = false,
    clearColor: v = q("#000000"),
    windowSize: g = false
  } = n, { width: h2, height: M } = g ? useWindowSize() : useElementSize(t), { pixelRatio: k } = useDevicePixelRatio(), { pause: se, resume: ie } = re(), ce = computed(() => h2.value / M.value), N = () => {
    !p.value || (p.value.setSize(h2.value, M.value), p.value.setPixelRatio(k.value));
  }, H = () => {
    !p.value || (p.value.shadowMap.enabled = resolveUnref(m), p.value.outputEncoding = resolveUnref(C), p.value.shadowMap.type = resolveUnref(d), p.value.physicallyCorrectLights = resolveUnref(w), p.value.toneMapping = resolveUnref(x), p.value.toneMappingExposure = resolveUnref(L), p.value.setClearColor(q(resolveUnref(v))));
  }, ue = () => {
    const G = unrefElement(e);
    if (p.value || !G)
      return;
    p.value = new WebGLRenderer({
      canvas: G,
      alpha: a,
      antialias: r,
      context: T,
      depth: o,
      failIfMajorPerformanceCaveat: c,
      logarithmicDepthBuffer: s,
      powerPreference: y,
      precision: i,
      stencil: u,
      preserveDrawingBuffer: l,
      premultipliedAlpha: f
    });
    const { setState: pe } = oe();
    pe("renderer", p.value), H(), N(), ie(), z.value = true;
  }, le = () => {
    !p.value || (p.value.dispose(), p.value = void 0, z.value = false, se());
  };
  return watch([h2, M, k], N), watch(
    () => [
      m,
      d,
      C,
      w,
      x,
      L,
      v
    ],
    H
  ), watch(
    () => [e, t],
    () => {
      unrefElement(e) && unrefElement(t) && ue();
    },
    { immediate: true, deep: true }
  ), {
    renderer: p,
    isReady: z,
    dispose: le,
    aspectRatio: ce
  };
}
var We = defineComponent({
  name: "TresCanvas",
  props: {
    shadows: Boolean,
    shadowMapType: Object,
    physicallyCorrectLights: Boolean,
    outputEncoding: Object,
    toneMapping: Object,
    toneMappingExposure: Number,
    context: Object,
    powerPreference: Object,
    preserveDrawingBuffer: Boolean,
    clearColor: String,
    windowSize: Boolean
  },
  setup(e, { slots: t, attrs: n }) {
    const { logError: a } = W(), r = ref(), o = ref(), { renderer: s, dispose: c, aspectRatio: i } = Ve(r, o, e), f = shallowRef();
    return provide("camera", f), provide("renderer", s), provide("aspect-ratio", i), t.default && !t.default().some((u) => u.type.name === "Scene") && a("TresCanvas must contain a Scene component."), t.default && !t.default().some((u) => {
      var m;
      return (m = u.type.name) == null ? void 0 : m.includes("Camera");
    }) && a("Scene must contain a Camera component."), onBeforeUnmount(() => c()), () => {
      if (t.default)
        return h(
          "div",
          {
            ref: o,
            style: {
              position: "relative",
              width: "100%",
              height: "100vh",
              ...n.style
            }
          },
          [
            h("canvas", {
              ref: r,
              style: { width: "100%", height: "100%", position: "absolute", top: 0, left: 0 }
            }),
            t.default()
          ]
        );
    };
  }
});
var ke = defineComponent({
  name: "Scene",
  setup(e, { slots: t }) {
    const { scene: n } = ae(), a = inject("renderer"), { activeCamera: r } = Z(), { onLoop: o } = re();
    return provide("local-scene", n), o(() => {
      (a == null ? void 0 : a.value) && (r == null ? void 0 : r.value) && (n == null ? void 0 : n.value) && a.value.render(n == null ? void 0 : n.value, r.value);
    }), () => {
      if (t.default)
        return t.default();
    };
  }
});
var Ke = Symbol("UseTresState");
var Qe = {
  install(e, t) {
    const n = (t == null ? void 0 : t.prefix) || "Tres";
    e.component(`${n}Canvas`, We), e.component(`${n}Scene`, ke);
    const { catalogue: a } = be(), { createComponentInstances: r } = ze(n);
    r(t != null && t.extends ? { ...a, ...t.extends } : a).forEach(([s, c]) => {
      e.component(s, c);
    });
  }
};

export {
  Oe,
  Z,
  be,
  ze,
  re,
  ae,
  Ue,
  Je,
  qe,
  oe,
  Ve,
  Ke,
  Qe
};
//# sourceMappingURL=chunk-SAJEVOOO.js.map
