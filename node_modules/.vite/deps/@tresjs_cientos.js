import {
  Je,
  re
} from "./chunk-SAJEVOOO.js";
import {
  AnimationClip,
  Bone,
  Box3,
  BufferAttribute,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  DirectionalLight,
  DoubleSide,
  EventDispatcher,
  FileLoader,
  FrontSide,
  Group,
  ImageBitmapLoader,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NumberKeyframeTrack,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RepeatWrapping,
  Skeleton,
  SkinnedMesh,
  Sphere,
  Spherical,
  SpotLight,
  TOUCH,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  Vector2,
  Vector3,
  VectorKeyframeTrack,
  sRGBEncoding
} from "./chunk-77HLCOWG.js";
import {
  defineComponent,
  inject,
  onMounted,
  onUnmounted,
  unref,
  watch
} from "./chunk-QO6ZHO7P.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@tresjs/cientos/dist/trescientos.js
function Yl(T, u) {
  for (var p = 0; p < u.length; p++) {
    const a = u[p];
    if (typeof a != "string" && !Array.isArray(a)) {
      for (const d in a)
        if (d !== "default" && !(d in T)) {
          const m = Object.getOwnPropertyDescriptor(a, d);
          m && Object.defineProperty(T, d, m.get ? m : {
            enumerable: true,
            get: () => a[d]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(T, Symbol.toStringTag, { value: "Module" }));
}
function K(T, u, p) {
  return u in T ? Object.defineProperty(T, u, {
    value: p,
    enumerable: true,
    configurable: true,
    writable: true
  }) : T[u] = p, T;
}
var Hr = (T, u) => (T % u + u) % u;
var Xl = class extends EventDispatcher {
  constructor(u, p) {
    super(), K(this, "object", void 0), K(this, "domElement", void 0), K(this, "enabled", true), K(this, "target", new Vector3()), K(this, "minDistance", 0), K(this, "maxDistance", 1 / 0), K(this, "minZoom", 0), K(this, "maxZoom", 1 / 0), K(this, "minPolarAngle", 0), K(this, "maxPolarAngle", Math.PI), K(this, "minAzimuthAngle", -1 / 0), K(this, "maxAzimuthAngle", 1 / 0), K(this, "enableDamping", false), K(this, "dampingFactor", 0.05), K(this, "enableZoom", true), K(this, "zoomSpeed", 1), K(this, "enableRotate", true), K(this, "rotateSpeed", 1), K(this, "enablePan", true), K(this, "panSpeed", 1), K(this, "screenSpacePanning", true), K(this, "keyPanSpeed", 7), K(this, "autoRotate", false), K(this, "autoRotateSpeed", 2), K(this, "reverseOrbit", false), K(this, "keys", {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown"
    }), K(this, "mouseButtons", {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    }), K(this, "touches", {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    }), K(this, "target0", void 0), K(this, "position0", void 0), K(this, "zoom0", void 0), K(this, "_domElementKeyEvents", null), K(this, "getPolarAngle", void 0), K(this, "getAzimuthalAngle", void 0), K(this, "setPolarAngle", void 0), K(this, "setAzimuthalAngle", void 0), K(this, "getDistance", void 0), K(this, "listenToKeyEvents", void 0), K(this, "saveState", void 0), K(this, "reset", void 0), K(this, "update", void 0), K(this, "connect", void 0), K(this, "dispose", void 0), this.object = u, this.domElement = p, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof PerspectiveCamera ? this.object.zoom : 1, this.getPolarAngle = () => E.phi, this.getAzimuthalAngle = () => E.theta, this.setPolarAngle = (C) => {
      let S = Hr(C, 2 * Math.PI), B = E.phi;
      B < 0 && (B += 2 * Math.PI), S < 0 && (S += 2 * Math.PI);
      let G = Math.abs(S - B);
      2 * Math.PI - G < G && (S < B ? S += 2 * Math.PI : B += 2 * Math.PI), g.phi = S - B, a.update();
    }, this.setAzimuthalAngle = (C) => {
      let S = Hr(C, 2 * Math.PI), B = E.theta;
      B < 0 && (B += 2 * Math.PI), S < 0 && (S += 2 * Math.PI);
      let G = Math.abs(S - B);
      2 * Math.PI - G < G && (S < B ? S += 2 * Math.PI : B += 2 * Math.PI), g.theta = S - B, a.update();
    }, this.getDistance = () => a.object.position.distanceTo(a.target), this.listenToKeyEvents = (C) => {
      C.addEventListener("keydown", Ye), this._domElementKeyEvents = C;
    }, this.saveState = () => {
      a.target0.copy(a.target), a.position0.copy(a.object.position), a.zoom0 = a.object instanceof PerspectiveCamera ? a.object.zoom : 1;
    }, this.reset = () => {
      a.target.copy(a.target0), a.object.position.copy(a.position0), a.object instanceof PerspectiveCamera && (a.object.zoom = a.zoom0, a.object.updateProjectionMatrix()), a.dispatchEvent(d), a.update(), f = b.NONE;
    }, this.update = (() => {
      const C = new Vector3(), S = new Quaternion().setFromUnitVectors(u.up, new Vector3(0, 1, 0)), B = S.clone().invert(), G = new Vector3(), oe = new Quaternion(), ke = 2 * Math.PI;
      return function() {
        const nn = a.object.position;
        C.copy(nn).sub(a.target), C.applyQuaternion(S), E.setFromVector3(C), a.autoRotate && f === b.NONE && ye(ne()), a.enableDamping ? (E.theta += g.theta * a.dampingFactor, E.phi += g.phi * a.dampingFactor) : (E.theta += g.theta, E.phi += g.phi);
        let ge = a.minAzimuthAngle, we = a.maxAzimuthAngle;
        return isFinite(ge) && isFinite(we) && (ge < -Math.PI ? ge += ke : ge > Math.PI && (ge -= ke), we < -Math.PI ? we += ke : we > Math.PI && (we -= ke), ge <= we ? E.theta = Math.max(ge, Math.min(we, E.theta)) : E.theta = E.theta > (ge + we) / 2 ? Math.max(ge, E.theta) : Math.min(we, E.theta)), E.phi = Math.max(a.minPolarAngle, Math.min(a.maxPolarAngle, E.phi)), E.makeSafe(), E.radius *= k, E.radius = Math.max(a.minDistance, Math.min(a.maxDistance, E.radius)), a.enableDamping === true ? a.target.addScaledVector(V, a.dampingFactor) : a.target.add(V), C.setFromSpherical(E), C.applyQuaternion(B), nn.copy(a.target).add(C), a.object.lookAt(a.target), a.enableDamping === true ? (g.theta *= 1 - a.dampingFactor, g.phi *= 1 - a.dampingFactor, V.multiplyScalar(1 - a.dampingFactor)) : (g.set(0, 0, 0), V.set(0, 0, 0)), k = 1, L || G.distanceToSquared(a.object.position) > x || 8 * (1 - oe.dot(a.object.quaternion)) > x ? (a.dispatchEvent(d), G.copy(a.object.position), oe.copy(a.object.quaternion), L = false, true) : false;
      };
    })(), this.connect = (C) => {
      C === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), a.domElement = C, a.domElement.style.touchAction = "none", a.domElement.addEventListener("contextmenu", Ve), a.domElement.addEventListener("pointerdown", Vt), a.domElement.addEventListener("pointercancel", qe), a.domElement.addEventListener("wheel", Ae);
    }, this.dispose = () => {
      var C, S, B, G, oe, ke;
      (C = a.domElement) === null || C === void 0 || C.removeEventListener("contextmenu", Ve), (S = a.domElement) === null || S === void 0 || S.removeEventListener("pointerdown", Vt), (B = a.domElement) === null || B === void 0 || B.removeEventListener("pointercancel", qe), (G = a.domElement) === null || G === void 0 || G.removeEventListener("wheel", Ae), (oe = a.domElement) === null || oe === void 0 || oe.ownerDocument.removeEventListener("pointermove", $e), (ke = a.domElement) === null || ke === void 0 || ke.ownerDocument.removeEventListener("pointerup", tt), a._domElementKeyEvents !== null && a._domElementKeyEvents.removeEventListener("keydown", Ye);
    };
    const a = this, d = {
      type: "change"
    }, m = {
      type: "start"
    }, h = {
      type: "end"
    }, b = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let f = b.NONE;
    const x = 1e-6, E = new Spherical(), g = new Spherical();
    let k = 1;
    const V = new Vector3();
    let L = false;
    const D = new Vector2(), N = new Vector2(), R = new Vector2(), q = new Vector2(), I = new Vector2(), ie = new Vector2(), ue = new Vector2(), te = new Vector2(), Y = new Vector2(), z = [], J = {};
    function ne() {
      return 2 * Math.PI / 60 / 60 * a.autoRotateSpeed;
    }
    function be() {
      return Math.pow(0.95, a.zoomSpeed);
    }
    function ye(C) {
      a.reverseOrbit ? g.theta += C : g.theta -= C;
    }
    function de(C) {
      a.reverseOrbit ? g.phi += C : g.phi -= C;
    }
    const pe = (() => {
      const C = new Vector3();
      return function(B, G) {
        C.setFromMatrixColumn(G, 0), C.multiplyScalar(-B), V.add(C);
      };
    })(), ve = (() => {
      const C = new Vector3();
      return function(B, G) {
        a.screenSpacePanning === true ? C.setFromMatrixColumn(G, 1) : (C.setFromMatrixColumn(G, 0), C.crossVectors(a.object.up, C)), C.multiplyScalar(B), V.add(C);
      };
    })(), X = (() => {
      const C = new Vector3();
      return function(B, G) {
        const oe = a.domElement;
        if (oe && a.object instanceof PerspectiveCamera && a.object.isPerspectiveCamera) {
          const ke = a.object.position;
          C.copy(ke).sub(a.target);
          let mt = C.length();
          mt *= Math.tan(a.object.fov / 2 * Math.PI / 180), pe(2 * B * mt / oe.clientHeight, a.object.matrix), ve(2 * G * mt / oe.clientHeight, a.object.matrix);
        } else
          oe && a.object instanceof OrthographicCamera && a.object.isOrthographicCamera ? (pe(B * (a.object.right - a.object.left) / a.object.zoom / oe.clientWidth, a.object.matrix), ve(G * (a.object.top - a.object.bottom) / a.object.zoom / oe.clientHeight, a.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), a.enablePan = false);
      };
    })();
    function j(C) {
      a.object instanceof PerspectiveCamera && a.object.isPerspectiveCamera ? k /= C : a.object instanceof OrthographicCamera && a.object.isOrthographicCamera ? (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom * C)), a.object.updateProjectionMatrix(), L = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = false);
    }
    function pt(C) {
      a.object instanceof PerspectiveCamera && a.object.isPerspectiveCamera ? k *= C : a.object instanceof OrthographicCamera && a.object.isOrthographicCamera ? (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom / C)), a.object.updateProjectionMatrix(), L = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = false);
    }
    function Zt(C) {
      D.set(C.clientX, C.clientY);
    }
    function Qt(C) {
      ue.set(C.clientX, C.clientY);
    }
    function _e(C) {
      q.set(C.clientX, C.clientY);
    }
    function Lt(C) {
      N.set(C.clientX, C.clientY), R.subVectors(N, D).multiplyScalar(a.rotateSpeed);
      const S = a.domElement;
      S && (ye(2 * Math.PI * R.x / S.clientHeight), de(2 * Math.PI * R.y / S.clientHeight)), D.copy(N), a.update();
    }
    function H(C) {
      te.set(C.clientX, C.clientY), Y.subVectors(te, ue), Y.y > 0 ? j(be()) : Y.y < 0 && pt(be()), ue.copy(te), a.update();
    }
    function re2(C) {
      I.set(C.clientX, C.clientY), ie.subVectors(I, q).multiplyScalar(a.panSpeed), X(ie.x, ie.y), q.copy(I), a.update();
    }
    function wn(C) {
      C.deltaY < 0 ? pt(be()) : C.deltaY > 0 && j(be()), a.update();
    }
    function Jt(C) {
      let S = false;
      switch (C.code) {
        case a.keys.UP:
          X(0, a.keyPanSpeed), S = true;
          break;
        case a.keys.BOTTOM:
          X(0, -a.keyPanSpeed), S = true;
          break;
        case a.keys.LEFT:
          X(a.keyPanSpeed, 0), S = true;
          break;
        case a.keys.RIGHT:
          X(-a.keyPanSpeed, 0), S = true;
          break;
      }
      S && (C.preventDefault(), a.update());
    }
    function St() {
      if (z.length == 1)
        D.set(z[0].pageX, z[0].pageY);
      else {
        const C = 0.5 * (z[0].pageX + z[1].pageX), S = 0.5 * (z[0].pageY + z[1].pageY);
        D.set(C, S);
      }
    }
    function At() {
      if (z.length == 1)
        q.set(z[0].pageX, z[0].pageY);
      else {
        const C = 0.5 * (z[0].pageX + z[1].pageX), S = 0.5 * (z[0].pageY + z[1].pageY);
        q.set(C, S);
      }
    }
    function Ce() {
      const C = z[0].pageX - z[1].pageX, S = z[0].pageY - z[1].pageY, B = Math.sqrt(C * C + S * S);
      ue.set(0, B);
    }
    function Ee() {
      a.enableZoom && Ce(), a.enablePan && At();
    }
    function Je2() {
      a.enableZoom && Ce(), a.enableRotate && St();
    }
    function et(C) {
      if (z.length == 1)
        N.set(C.pageX, C.pageY);
      else {
        const B = Fe(C), G = 0.5 * (C.pageX + B.x), oe = 0.5 * (C.pageY + B.y);
        N.set(G, oe);
      }
      R.subVectors(N, D).multiplyScalar(a.rotateSpeed);
      const S = a.domElement;
      S && (ye(2 * Math.PI * R.x / S.clientHeight), de(2 * Math.PI * R.y / S.clientHeight)), D.copy(N);
    }
    function ut(C) {
      if (z.length == 1)
        I.set(C.pageX, C.pageY);
      else {
        const S = Fe(C), B = 0.5 * (C.pageX + S.x), G = 0.5 * (C.pageY + S.y);
        I.set(B, G);
      }
      ie.subVectors(I, q).multiplyScalar(a.panSpeed), X(ie.x, ie.y), q.copy(I);
    }
    function dt(C) {
      const S = Fe(C), B = C.pageX - S.x, G = C.pageY - S.y, oe = Math.sqrt(B * B + G * G);
      te.set(0, oe), Y.set(0, Math.pow(te.y / ue.y, a.zoomSpeed)), j(Y.y), ue.copy(te);
    }
    function xn(C) {
      a.enableZoom && dt(C), a.enablePan && ut(C);
    }
    function yn(C) {
      a.enableZoom && dt(C), a.enableRotate && et(C);
    }
    function Vt(C) {
      if (a.enabled !== false) {
        if (z.length === 0) {
          var S, B;
          (S = a.domElement) === null || S === void 0 || S.ownerDocument.addEventListener("pointermove", $e), (B = a.domElement) === null || B === void 0 || B.ownerDocument.addEventListener("pointerup", tt);
        }
        ht(C), C.pointerType === "touch" ? Cn(C) : en(C);
      }
    }
    function $e(C) {
      a.enabled !== false && (C.pointerType === "touch" ? Rt(C) : tn(C));
    }
    function tt(C) {
      if (Pe(C), z.length === 0) {
        var S, B, G;
        (S = a.domElement) === null || S === void 0 || S.releasePointerCapture(C.pointerId), (B = a.domElement) === null || B === void 0 || B.ownerDocument.removeEventListener("pointermove", $e), (G = a.domElement) === null || G === void 0 || G.ownerDocument.removeEventListener("pointerup", tt);
      }
      a.dispatchEvent(h), f = b.NONE;
    }
    function qe(C) {
      Pe(C);
    }
    function en(C) {
      let S;
      switch (C.button) {
        case 0:
          S = a.mouseButtons.LEFT;
          break;
        case 1:
          S = a.mouseButtons.MIDDLE;
          break;
        case 2:
          S = a.mouseButtons.RIGHT;
          break;
        default:
          S = -1;
      }
      switch (S) {
        case MOUSE.DOLLY:
          if (a.enableZoom === false)
            return;
          Qt(C), f = b.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (C.ctrlKey || C.metaKey || C.shiftKey) {
            if (a.enablePan === false)
              return;
            _e(C), f = b.PAN;
          } else {
            if (a.enableRotate === false)
              return;
            Zt(C), f = b.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (C.ctrlKey || C.metaKey || C.shiftKey) {
            if (a.enableRotate === false)
              return;
            Zt(C), f = b.ROTATE;
          } else {
            if (a.enablePan === false)
              return;
            _e(C), f = b.PAN;
          }
          break;
        default:
          f = b.NONE;
      }
      f !== b.NONE && a.dispatchEvent(m);
    }
    function tn(C) {
      if (a.enabled !== false)
        switch (f) {
          case b.ROTATE:
            if (a.enableRotate === false)
              return;
            Lt(C);
            break;
          case b.DOLLY:
            if (a.enableZoom === false)
              return;
            H(C);
            break;
          case b.PAN:
            if (a.enablePan === false)
              return;
            re2(C);
            break;
        }
    }
    function Ae(C) {
      a.enabled === false || a.enableZoom === false || f !== b.NONE && f !== b.ROTATE || (C.preventDefault(), a.dispatchEvent(m), wn(C), a.dispatchEvent(h));
    }
    function Ye(C) {
      a.enabled === false || a.enablePan === false || Jt(C);
    }
    function Cn(C) {
      switch (De(C), z.length) {
        case 1:
          switch (a.touches.ONE) {
            case TOUCH.ROTATE:
              if (a.enableRotate === false)
                return;
              St(), f = b.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (a.enablePan === false)
                return;
              At(), f = b.TOUCH_PAN;
              break;
            default:
              f = b.NONE;
          }
          break;
        case 2:
          switch (a.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (a.enableZoom === false && a.enablePan === false)
                return;
              Ee(), f = b.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (a.enableZoom === false && a.enableRotate === false)
                return;
              Je2(), f = b.TOUCH_DOLLY_ROTATE;
              break;
            default:
              f = b.NONE;
          }
          break;
        default:
          f = b.NONE;
      }
      f !== b.NONE && a.dispatchEvent(m);
    }
    function Rt(C) {
      switch (De(C), f) {
        case b.TOUCH_ROTATE:
          if (a.enableRotate === false)
            return;
          et(C), a.update();
          break;
        case b.TOUCH_PAN:
          if (a.enablePan === false)
            return;
          ut(C), a.update();
          break;
        case b.TOUCH_DOLLY_PAN:
          if (a.enableZoom === false && a.enablePan === false)
            return;
          xn(C), a.update();
          break;
        case b.TOUCH_DOLLY_ROTATE:
          if (a.enableZoom === false && a.enableRotate === false)
            return;
          yn(C), a.update();
          break;
        default:
          f = b.NONE;
      }
    }
    function Ve(C) {
      a.enabled !== false && C.preventDefault();
    }
    function ht(C) {
      z.push(C);
    }
    function Pe(C) {
      delete J[C.pointerId];
      for (let S = 0; S < z.length; S++)
        if (z[S].pointerId == C.pointerId) {
          z.splice(S, 1);
          return;
        }
    }
    function De(C) {
      let S = J[C.pointerId];
      S === void 0 && (S = new Vector2(), J[C.pointerId] = S), S.set(C.pageX, C.pageY);
    }
    function Fe(C) {
      const S = C.pointerId === z[0].pointerId ? z[1] : z[0];
      return J[S.pointerId];
    }
    p !== void 0 && this.connect(p), this.update();
  }
};
var Wl = class extends Loader {
  constructor(u) {
    super(u), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(p) {
      return new tc(p);
    }), this.register(function(p) {
      return new lc(p);
    }), this.register(function(p) {
      return new cc(p);
    }), this.register(function(p) {
      return new sc(p);
    }), this.register(function(p) {
      return new ic(p);
    }), this.register(function(p) {
      return new rc(p);
    }), this.register(function(p) {
      return new oc(p);
    }), this.register(function(p) {
      return new ec(p);
    }), this.register(function(p) {
      return new ac(p);
    }), this.register(function(p) {
      return new nc(p);
    }), this.register(function(p) {
      return new Ql(p);
    }), this.register(function(p) {
      return new pc(p);
    });
  }
  load(u, p, a, d) {
    const m = this;
    let h;
    this.resourcePath !== "" ? h = this.resourcePath : this.path !== "" ? h = this.path : h = LoaderUtils.extractUrlBase(u), this.manager.itemStart(u);
    const b = function(x) {
      d ? d(x) : console.error(x), m.manager.itemError(u), m.manager.itemEnd(u);
    }, f = new FileLoader(this.manager);
    f.setPath(this.path), f.setResponseType("arraybuffer"), f.setRequestHeader(this.requestHeader), f.setWithCredentials(this.withCredentials), f.load(u, function(x) {
      try {
        m.parse(x, h, function(E) {
          p(E), m.manager.itemEnd(u);
        }, b);
      } catch (E) {
        b(E);
      }
    }, a, b);
  }
  setDRACOLoader(u) {
    return this.dracoLoader = u, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(u) {
    return this.ktx2Loader = u, this;
  }
  setMeshoptDecoder(u) {
    return this.meshoptDecoder = u, this;
  }
  register(u) {
    return this.pluginCallbacks.indexOf(u) === -1 && this.pluginCallbacks.push(u), this;
  }
  unregister(u) {
    return this.pluginCallbacks.indexOf(u) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(u), 1), this;
  }
  parse(u, p, a, d) {
    let m;
    const h = {}, b = {};
    if (typeof u == "string")
      m = u;
    else if (LoaderUtils.decodeText(new Uint8Array(u, 0, 4)) === ao) {
      try {
        h[$.KHR_BINARY_GLTF] = new uc(u);
      } catch (g) {
        d && d(g);
        return;
      }
      m = h[$.KHR_BINARY_GLTF].content;
    } else
      m = LoaderUtils.decodeText(new Uint8Array(u));
    const f = JSON.parse(m);
    if (f.asset === void 0 || f.asset.version[0] < 2) {
      d && d(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const x = new Ec(f, {
      path: p || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    x.fileLoader.setRequestHeader(this.requestHeader);
    for (let E = 0; E < this.pluginCallbacks.length; E++) {
      const g = this.pluginCallbacks[E](x);
      b[g.name] = g, h[g.name] = true;
    }
    if (f.extensionsUsed)
      for (let E = 0; E < f.extensionsUsed.length; ++E) {
        const g = f.extensionsUsed[E], k = f.extensionsRequired || [];
        switch (g) {
          case $.KHR_MATERIALS_UNLIT:
            h[g] = new Jl();
            break;
          case $.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            h[g] = new mc();
            break;
          case $.KHR_DRACO_MESH_COMPRESSION:
            h[g] = new dc(f, this.dracoLoader);
            break;
          case $.KHR_TEXTURE_TRANSFORM:
            h[g] = new hc();
            break;
          case $.KHR_MESH_QUANTIZATION:
            h[g] = new vc();
            break;
          default:
            k.indexOf(g) >= 0 && b[g] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + g + '".');
        }
      }
    x.setExtensions(h), x.setPlugins(b), x.parse(a, d);
  }
  parseAsync(u, p) {
    const a = this;
    return new Promise(function(d, m) {
      a.parse(u, p, d, m);
    });
  }
};
function Zl() {
  let T = {};
  return {
    get: function(u) {
      return T[u];
    },
    add: function(u, p) {
      T[u] = p;
    },
    remove: function(u) {
      delete T[u];
    },
    removeAll: function() {
      T = {};
    }
  };
}
var $ = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
var Ql = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_LIGHTS_PUNCTUAL, this.cache = {
      refs: {},
      uses: {}
    };
  }
  _markDefs() {
    const u = this.parser, p = this.parser.json.nodes || [];
    for (let a = 0, d = p.length; a < d; a++) {
      const m = p[a];
      m.extensions && m.extensions[this.name] && m.extensions[this.name].light !== void 0 && u._addNodeRef(this.cache, m.extensions[this.name].light);
    }
  }
  _loadLight(u) {
    const p = this.parser, a = "light:" + u;
    let d = p.cache.get(a);
    if (d)
      return d;
    const m = p.json, f = ((m.extensions && m.extensions[this.name] || {}).lights || [])[u];
    let x;
    const E = new Color(16777215);
    f.color !== void 0 && E.fromArray(f.color);
    const g = f.range !== void 0 ? f.range : 0;
    switch (f.type) {
      case "directional":
        x = new DirectionalLight(E), x.target.position.set(0, 0, -1), x.add(x.target);
        break;
      case "point":
        x = new PointLight(E), x.distance = g;
        break;
      case "spot":
        x = new SpotLight(E), x.distance = g, f.spot = f.spot || {}, f.spot.innerConeAngle = f.spot.innerConeAngle !== void 0 ? f.spot.innerConeAngle : 0, f.spot.outerConeAngle = f.spot.outerConeAngle !== void 0 ? f.spot.outerConeAngle : Math.PI / 4, x.angle = f.spot.outerConeAngle, x.penumbra = 1 - f.spot.innerConeAngle / f.spot.outerConeAngle, x.target.position.set(0, 0, -1), x.add(x.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + f.type);
    }
    return x.position.set(0, 0, 0), x.decay = 2, f.intensity !== void 0 && (x.intensity = f.intensity), x.name = p.createUniqueName(f.name || "light_" + u), d = Promise.resolve(x), p.cache.add(a, d), d;
  }
  createNodeAttachment(u) {
    const p = this, a = this.parser, m = a.json.nodes[u], b = (m.extensions && m.extensions[this.name] || {}).light;
    return b === void 0 ? null : this._loadLight(b).then(function(f) {
      return a._getNodeRef(p.cache, b, f);
    });
  }
};
var Jl = class {
  constructor() {
    this.name = $.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(u, p, a) {
    const d = [];
    u.color = new Color(1, 1, 1), u.opacity = 1;
    const m = p.pbrMetallicRoughness;
    if (m) {
      if (Array.isArray(m.baseColorFactor)) {
        const h = m.baseColorFactor;
        u.color.fromArray(h), u.opacity = h[3];
      }
      m.baseColorTexture !== void 0 && d.push(a.assignTexture(u, "map", m.baseColorTexture, sRGBEncoding));
    }
    return Promise.all(d);
  }
};
var ec = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(u, p) {
    const d = this.parser.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = d.extensions[this.name].emissiveStrength;
    return m !== void 0 && (p.emissiveIntensity = m), Promise.resolve();
  }
};
var tc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [], h = d.extensions[this.name];
    if (h.clearcoatFactor !== void 0 && (p.clearcoat = h.clearcoatFactor), h.clearcoatTexture !== void 0 && m.push(a.assignTexture(p, "clearcoatMap", h.clearcoatTexture)), h.clearcoatRoughnessFactor !== void 0 && (p.clearcoatRoughness = h.clearcoatRoughnessFactor), h.clearcoatRoughnessTexture !== void 0 && m.push(a.assignTexture(p, "clearcoatRoughnessMap", h.clearcoatRoughnessTexture)), h.clearcoatNormalTexture !== void 0 && (m.push(a.assignTexture(p, "clearcoatNormalMap", h.clearcoatNormalTexture)), h.clearcoatNormalTexture.scale !== void 0)) {
      const b = h.clearcoatNormalTexture.scale;
      p.clearcoatNormalScale = new Vector2(b, b);
    }
    return Promise.all(m);
  }
};
var nc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [], h = d.extensions[this.name];
    return h.iridescenceFactor !== void 0 && (p.iridescence = h.iridescenceFactor), h.iridescenceTexture !== void 0 && m.push(a.assignTexture(p, "iridescenceMap", h.iridescenceTexture)), h.iridescenceIor !== void 0 && (p.iridescenceIOR = h.iridescenceIor), p.iridescenceThicknessRange === void 0 && (p.iridescenceThicknessRange = [100, 400]), h.iridescenceThicknessMinimum !== void 0 && (p.iridescenceThicknessRange[0] = h.iridescenceThicknessMinimum), h.iridescenceThicknessMaximum !== void 0 && (p.iridescenceThicknessRange[1] = h.iridescenceThicknessMaximum), h.iridescenceThicknessTexture !== void 0 && m.push(a.assignTexture(p, "iridescenceThicknessMap", h.iridescenceThicknessTexture)), Promise.all(m);
  }
};
var sc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [];
    p.sheenColor = new Color(0, 0, 0), p.sheenRoughness = 0, p.sheen = 1;
    const h = d.extensions[this.name];
    return h.sheenColorFactor !== void 0 && p.sheenColor.fromArray(h.sheenColorFactor), h.sheenRoughnessFactor !== void 0 && (p.sheenRoughness = h.sheenRoughnessFactor), h.sheenColorTexture !== void 0 && m.push(a.assignTexture(p, "sheenColorMap", h.sheenColorTexture, sRGBEncoding)), h.sheenRoughnessTexture !== void 0 && m.push(a.assignTexture(p, "sheenRoughnessMap", h.sheenRoughnessTexture)), Promise.all(m);
  }
};
var ic = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [], h = d.extensions[this.name];
    return h.transmissionFactor !== void 0 && (p.transmission = h.transmissionFactor), h.transmissionTexture !== void 0 && m.push(a.assignTexture(p, "transmissionMap", h.transmissionTexture)), Promise.all(m);
  }
};
var rc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [], h = d.extensions[this.name];
    p.thickness = h.thicknessFactor !== void 0 ? h.thicknessFactor : 0, h.thicknessTexture !== void 0 && m.push(a.assignTexture(p, "thicknessMap", h.thicknessTexture)), p.attenuationDistance = h.attenuationDistance || 1 / 0;
    const b = h.attenuationColor || [1, 1, 1];
    return p.attenuationColor = new Color(b[0], b[1], b[2]), Promise.all(m);
  }
};
var oc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_IOR;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const d = this.parser.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = d.extensions[this.name];
    return p.ior = m.ior !== void 0 ? m.ior : 1.5, Promise.resolve();
  }
};
var ac = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(u) {
    const a = this.parser.json.materials[u];
    return !a.extensions || !a.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(u, p) {
    const a = this.parser, d = a.json.materials[u];
    if (!d.extensions || !d.extensions[this.name])
      return Promise.resolve();
    const m = [], h = d.extensions[this.name];
    p.specularIntensity = h.specularFactor !== void 0 ? h.specularFactor : 1, h.specularTexture !== void 0 && m.push(a.assignTexture(p, "specularIntensityMap", h.specularTexture));
    const b = h.specularColorFactor || [1, 1, 1];
    return p.specularColor = new Color(b[0], b[1], b[2]), h.specularColorTexture !== void 0 && m.push(a.assignTexture(p, "specularColorMap", h.specularColorTexture, sRGBEncoding)), Promise.all(m);
  }
};
var lc = class {
  constructor(u) {
    this.parser = u, this.name = $.KHR_TEXTURE_BASISU;
  }
  loadTexture(u) {
    const p = this.parser, a = p.json, d = a.textures[u];
    if (!d.extensions || !d.extensions[this.name])
      return null;
    const m = d.extensions[this.name], h = p.options.ktx2Loader;
    if (!h) {
      if (a.extensionsRequired && a.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return p.loadTextureImage(u, m.source, h);
  }
};
var cc = class {
  constructor(u) {
    this.parser = u, this.name = $.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(u) {
    const p = this.name, a = this.parser, d = a.json, m = d.textures[u];
    if (!m.extensions || !m.extensions[p])
      return null;
    const h = m.extensions[p], b = d.images[h.source];
    let f = a.textureLoader;
    if (b.uri) {
      const x = a.options.manager.getHandler(b.uri);
      x !== null && (f = x);
    }
    return this.detectSupport().then(function(x) {
      if (x)
        return a.loadTextureImage(u, h.source, f);
      if (d.extensionsRequired && d.extensionsRequired.indexOf(p) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return a.loadTexture(u);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(u) {
      const p = new Image();
      p.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", p.onload = p.onerror = function() {
        u(p.height === 1);
      };
    })), this.isSupported;
  }
};
var pc = class {
  constructor(u) {
    this.name = $.EXT_MESHOPT_COMPRESSION, this.parser = u;
  }
  loadBufferView(u) {
    const p = this.parser.json, a = p.bufferViews[u];
    if (a.extensions && a.extensions[this.name]) {
      const d = a.extensions[this.name], m = this.parser.getDependency("buffer", d.buffer), h = this.parser.options.meshoptDecoder;
      if (!h || !h.supported) {
        if (p.extensionsRequired && p.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return m.then(function(b) {
        const f = d.byteOffset || 0, x = d.byteLength || 0, E = d.count, g = d.byteStride, k = new Uint8Array(b, f, x);
        return h.decodeGltfBufferAsync ? h.decodeGltfBufferAsync(E, g, k, d.mode, d.filter).then(function(V) {
          return V.buffer;
        }) : h.ready.then(function() {
          const V = new ArrayBuffer(E * g);
          return h.decodeGltfBuffer(new Uint8Array(V), E, g, k, d.mode, d.filter), V;
        });
      });
    } else
      return null;
  }
};
var ao = "glTF";
var Qn = 12;
var Gr = {
  JSON: 1313821514,
  BIN: 5130562
};
var uc = class {
  constructor(u) {
    this.name = $.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const p = new DataView(u, 0, Qn);
    if (this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(u.slice(0, 4))),
      version: p.getUint32(4, true),
      length: p.getUint32(8, true)
    }, this.header.magic !== ao)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const a = this.header.length - Qn, d = new DataView(u, Qn);
    let m = 0;
    for (; m < a; ) {
      const h = d.getUint32(m, true);
      m += 4;
      const b = d.getUint32(m, true);
      if (m += 4, b === Gr.JSON) {
        const f = new Uint8Array(u, Qn + m, h);
        this.content = LoaderUtils.decodeText(f);
      } else if (b === Gr.BIN) {
        const f = Qn + m;
        this.body = u.slice(f, f + h);
      }
      m += h;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
};
var dc = class {
  constructor(u, p) {
    if (!p)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = $.KHR_DRACO_MESH_COMPRESSION, this.json = u, this.dracoLoader = p, this.dracoLoader.preload();
  }
  decodePrimitive(u, p) {
    const a = this.json, d = this.dracoLoader, m = u.extensions[this.name].bufferView, h = u.extensions[this.name].attributes, b = {}, f = {}, x = {};
    for (const E in h) {
      const g = Ji[E] || E.toLowerCase();
      b[g] = h[E];
    }
    for (const E in u.attributes) {
      const g = Ji[E] || E.toLowerCase();
      if (h[E] !== void 0) {
        const k = a.accessors[u.attributes[E]], V = ts[k.componentType];
        x[g] = V.name, f[g] = k.normalized === true;
      }
    }
    return p.getDependency("bufferView", m).then(function(E) {
      return new Promise(function(g) {
        d.decodeDracoFile(E, function(k) {
          for (const V in k.attributes) {
            const L = k.attributes[V], D = f[V];
            D !== void 0 && (L.normalized = D);
          }
          g(k);
        }, b, x);
      });
    });
  }
};
var hc = class {
  constructor() {
    this.name = $.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(u, p) {
    return p.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), p.offset === void 0 && p.rotation === void 0 && p.scale === void 0 || (u = u.clone(), p.offset !== void 0 && u.offset.fromArray(p.offset), p.rotation !== void 0 && (u.rotation = p.rotation), p.scale !== void 0 && u.repeat.fromArray(p.scale), u.needsUpdate = true), u;
  }
};
var Qi = class extends MeshStandardMaterial {
  constructor(u) {
    super(), this.isGLTFSpecularGlossinessMaterial = true;
    const p = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`), a = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`), d = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`), m = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`), h = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`), b = {
      specular: {
        value: new Color().setHex(16777215)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    this._extraUniforms = b, this.onBeforeCompile = function(f) {
      for (const x in b)
        f.uniforms[x] = b[x];
      f.fragmentShader = f.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", p).replace("#include <metalnessmap_pars_fragment>", a).replace("#include <roughnessmap_fragment>", d).replace("#include <metalnessmap_fragment>", m).replace("#include <lights_physical_fragment>", h);
    }, Object.defineProperties(this, {
      specular: {
        get: function() {
          return b.specular.value;
        },
        set: function(f) {
          b.specular.value = f;
        }
      },
      specularMap: {
        get: function() {
          return b.specularMap.value;
        },
        set: function(f) {
          b.specularMap.value = f, f ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
        }
      },
      glossiness: {
        get: function() {
          return b.glossiness.value;
        },
        set: function(f) {
          b.glossiness.value = f;
        }
      },
      glossinessMap: {
        get: function() {
          return b.glossinessMap.value;
        },
        set: function(f) {
          b.glossinessMap.value = f, f ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
        }
      }
    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(u);
  }
  copy(u) {
    return super.copy(u), this.specularMap = u.specularMap, this.specular.copy(u.specular), this.glossinessMap = u.glossinessMap, this.glossiness = u.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }
};
var mc = class {
  constructor() {
    this.name = $.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"];
  }
  getMaterialType() {
    return Qi;
  }
  extendParams(u, p, a) {
    const d = p.extensions[this.name];
    u.color = new Color(1, 1, 1), u.opacity = 1;
    const m = [];
    if (Array.isArray(d.diffuseFactor)) {
      const h = d.diffuseFactor;
      u.color.fromArray(h), u.opacity = h[3];
    }
    if (d.diffuseTexture !== void 0 && m.push(a.assignTexture(u, "map", d.diffuseTexture, sRGBEncoding)), u.emissive = new Color(0, 0, 0), u.glossiness = d.glossinessFactor !== void 0 ? d.glossinessFactor : 1, u.specular = new Color(1, 1, 1), Array.isArray(d.specularFactor) && u.specular.fromArray(d.specularFactor), d.specularGlossinessTexture !== void 0) {
      const h = d.specularGlossinessTexture;
      m.push(a.assignTexture(u, "glossinessMap", h)), m.push(a.assignTexture(u, "specularMap", h, sRGBEncoding));
    }
    return Promise.all(m);
  }
  createMaterial(u) {
    const p = new Qi(u);
    return p.fog = true, p.color = u.color, p.map = u.map === void 0 ? null : u.map, p.lightMap = null, p.lightMapIntensity = 1, p.aoMap = u.aoMap === void 0 ? null : u.aoMap, p.aoMapIntensity = 1, p.emissive = u.emissive, p.emissiveIntensity = u.emissiveIntensity === void 0 ? 1 : u.emissiveIntensity, p.emissiveMap = u.emissiveMap === void 0 ? null : u.emissiveMap, p.bumpMap = u.bumpMap === void 0 ? null : u.bumpMap, p.bumpScale = 1, p.normalMap = u.normalMap === void 0 ? null : u.normalMap, p.normalMapType = TangentSpaceNormalMap, u.normalScale && (p.normalScale = u.normalScale), p.displacementMap = null, p.displacementScale = 1, p.displacementBias = 0, p.specularMap = u.specularMap === void 0 ? null : u.specularMap, p.specular = u.specular, p.glossinessMap = u.glossinessMap === void 0 ? null : u.glossinessMap, p.glossiness = u.glossiness, p.alphaMap = null, p.envMap = u.envMap === void 0 ? null : u.envMap, p.envMapIntensity = 1, p.refractionRatio = 0.98, p;
  }
};
var vc = class {
  constructor() {
    this.name = $.KHR_MESH_QUANTIZATION;
  }
};
var lo = class extends Interpolant {
  constructor(u, p, a, d) {
    super(u, p, a, d);
  }
  copySampleValue_(u) {
    const p = this.resultBuffer, a = this.sampleValues, d = this.valueSize, m = u * d * 3 + d;
    for (let h = 0; h !== d; h++)
      p[h] = a[m + h];
    return p;
  }
  interpolate_(u, p, a, d) {
    const m = this.resultBuffer, h = this.sampleValues, b = this.valueSize, f = b * 2, x = b * 3, E = d - p, g = (a - p) / E, k = g * g, V = k * g, L = u * x, D = L - x, N = -2 * V + 3 * k, R = V - k, q = 1 - N, I = R - k + g;
    for (let ie = 0; ie !== b; ie++) {
      const ue = h[D + ie + b], te = h[D + ie + f] * E, Y = h[L + ie + b], z = h[L + ie] * E;
      m[ie] = q * ue + I * te + N * Y + R * z;
    }
    return m;
  }
};
var fc = new Quaternion();
var bc = class extends lo {
  interpolate_(u, p, a, d) {
    const m = super.interpolate_(u, p, a, d);
    return fc.fromArray(m).normalize().toArray(m), m;
  }
};
var ct = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var ts = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var $r = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var qr = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var Yr = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var Ji = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var Mt = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var _c = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var $i = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function gc(T) {
  return T.DefaultMaterial === void 0 && (T.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: false,
    depthTest: true,
    side: FrontSide
  })), T.DefaultMaterial;
}
function Jn(T, u, p) {
  for (const a in p.extensions)
    T[a] === void 0 && (u.userData.gltfExtensions = u.userData.gltfExtensions || {}, u.userData.gltfExtensions[a] = p.extensions[a]);
}
function qt(T, u) {
  u.extras !== void 0 && (typeof u.extras == "object" ? Object.assign(T.userData, u.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + u.extras));
}
function wc(T, u, p) {
  let a = false, d = false, m = false;
  for (let x = 0, E = u.length; x < E; x++) {
    const g = u[x];
    if (g.POSITION !== void 0 && (a = true), g.NORMAL !== void 0 && (d = true), g.COLOR_0 !== void 0 && (m = true), a && d && m)
      break;
  }
  if (!a && !d && !m)
    return Promise.resolve(T);
  const h = [], b = [], f = [];
  for (let x = 0, E = u.length; x < E; x++) {
    const g = u[x];
    if (a) {
      const k = g.POSITION !== void 0 ? p.getDependency("accessor", g.POSITION) : T.attributes.position;
      h.push(k);
    }
    if (d) {
      const k = g.NORMAL !== void 0 ? p.getDependency("accessor", g.NORMAL) : T.attributes.normal;
      b.push(k);
    }
    if (m) {
      const k = g.COLOR_0 !== void 0 ? p.getDependency("accessor", g.COLOR_0) : T.attributes.color;
      f.push(k);
    }
  }
  return Promise.all([Promise.all(h), Promise.all(b), Promise.all(f)]).then(function(x) {
    const E = x[0], g = x[1], k = x[2];
    return a && (T.morphAttributes.position = E), d && (T.morphAttributes.normal = g), m && (T.morphAttributes.color = k), T.morphTargetsRelative = true, T;
  });
}
function xc(T, u) {
  if (T.updateMorphTargets(), u.weights !== void 0)
    for (let p = 0, a = u.weights.length; p < a; p++)
      T.morphTargetInfluences[p] = u.weights[p];
  if (u.extras && Array.isArray(u.extras.targetNames)) {
    const p = u.extras.targetNames;
    if (T.morphTargetInfluences.length === p.length) {
      T.morphTargetDictionary = {};
      for (let a = 0, d = p.length; a < d; a++)
        T.morphTargetDictionary[p[a]] = a;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function yc(T) {
  const u = T.extensions && T.extensions[$.KHR_DRACO_MESH_COMPRESSION];
  let p;
  return u ? p = "draco:" + u.bufferView + ":" + u.indices + ":" + Xr(u.attributes) : p = T.indices + ":" + Xr(T.attributes) + ":" + T.mode, p;
}
function Xr(T) {
  let u = "";
  const p = Object.keys(T).sort();
  for (let a = 0, d = p.length; a < d; a++)
    u += p[a] + ":" + T[p[a]] + ";";
  return u;
}
function er(T) {
  switch (T) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function Cc(T) {
  return T.search(/\.jpe?g($|\?)/i) > 0 || T.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : T.search(/\.webp($|\?)/i) > 0 || T.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
var Ec = class {
  constructor(u = {}, p = {}) {
    var a, d;
    this.json = u, this.extensions = {}, this.plugins = {}, this.options = p, this.cache = new Zl(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = {
      refs: {},
      uses: {}
    }, this.cameraCache = {
      refs: {},
      uses: {}
    }, this.lightCache = {
      refs: {},
      uses: {}
    }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    const m = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true, h = typeof navigator < "u" && ((a = navigator.userAgent) === null || a === void 0 ? void 0 : a.indexOf("Firefox")) > -1, b = typeof navigator < "u" && h ? (d = navigator.userAgent) === null || d === void 0 ? void 0 : d.match(/Firefox\/([0-9]+)\./)[1] : -1;
    typeof createImageBitmap > "u" || m || h && b < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(u) {
    this.extensions = u;
  }
  setPlugins(u) {
    this.plugins = u;
  }
  parse(u, p) {
    const a = this, d = this.json, m = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(h) {
      return h._markDefs && h._markDefs();
    }), Promise.all(this._invokeAll(function(h) {
      return h.beforeRoot && h.beforeRoot();
    })).then(function() {
      return Promise.all([a.getDependencies("scene"), a.getDependencies("animation"), a.getDependencies("camera")]);
    }).then(function(h) {
      const b = {
        scene: h[0][d.scene || 0],
        scenes: h[0],
        animations: h[1],
        cameras: h[2],
        asset: d.asset,
        parser: a,
        userData: {}
      };
      Jn(m, b, d), qt(b, d), Promise.all(a._invokeAll(function(f) {
        return f.afterRoot && f.afterRoot(b);
      })).then(function() {
        u(b);
      });
    }).catch(p);
  }
  _markDefs() {
    const u = this.json.nodes || [], p = this.json.skins || [], a = this.json.meshes || [];
    for (let d = 0, m = p.length; d < m; d++) {
      const h = p[d].joints;
      for (let b = 0, f = h.length; b < f; b++)
        u[h[b]].isBone = true;
    }
    for (let d = 0, m = u.length; d < m; d++) {
      const h = u[d];
      h.mesh !== void 0 && (this._addNodeRef(this.meshCache, h.mesh), h.skin !== void 0 && (a[h.mesh].isSkinnedMesh = true)), h.camera !== void 0 && this._addNodeRef(this.cameraCache, h.camera);
    }
  }
  _addNodeRef(u, p) {
    p !== void 0 && (u.refs[p] === void 0 && (u.refs[p] = u.uses[p] = 0), u.refs[p]++);
  }
  _getNodeRef(u, p, a) {
    if (u.refs[p] <= 1)
      return a;
    const d = a.clone(), m = (h, b) => {
      const f = this.associations.get(h);
      f != null && this.associations.set(b, f);
      for (const [x, E] of h.children.entries())
        m(E, b.children[x]);
    };
    return m(a, d), d.name += "_instance_" + u.uses[p]++, d;
  }
  _invokeOne(u) {
    const p = Object.values(this.plugins);
    p.push(this);
    for (let a = 0; a < p.length; a++) {
      const d = u(p[a]);
      if (d)
        return d;
    }
    return null;
  }
  _invokeAll(u) {
    const p = Object.values(this.plugins);
    p.unshift(this);
    const a = [];
    for (let d = 0; d < p.length; d++) {
      const m = u(p[d]);
      m && a.push(m);
    }
    return a;
  }
  getDependency(u, p) {
    const a = u + ":" + p;
    let d = this.cache.get(a);
    if (!d) {
      switch (u) {
        case "scene":
          d = this.loadScene(p);
          break;
        case "node":
          d = this.loadNode(p);
          break;
        case "mesh":
          d = this._invokeOne(function(m) {
            return m.loadMesh && m.loadMesh(p);
          });
          break;
        case "accessor":
          d = this.loadAccessor(p);
          break;
        case "bufferView":
          d = this._invokeOne(function(m) {
            return m.loadBufferView && m.loadBufferView(p);
          });
          break;
        case "buffer":
          d = this.loadBuffer(p);
          break;
        case "material":
          d = this._invokeOne(function(m) {
            return m.loadMaterial && m.loadMaterial(p);
          });
          break;
        case "texture":
          d = this._invokeOne(function(m) {
            return m.loadTexture && m.loadTexture(p);
          });
          break;
        case "skin":
          d = this.loadSkin(p);
          break;
        case "animation":
          d = this._invokeOne(function(m) {
            return m.loadAnimation && m.loadAnimation(p);
          });
          break;
        case "camera":
          d = this.loadCamera(p);
          break;
        default:
          throw new Error("Unknown type: " + u);
      }
      this.cache.add(a, d);
    }
    return d;
  }
  getDependencies(u) {
    let p = this.cache.get(u);
    if (!p) {
      const a = this, d = this.json[u + (u === "mesh" ? "es" : "s")] || [];
      p = Promise.all(d.map(function(m, h) {
        return a.getDependency(u, h);
      })), this.cache.add(u, p);
    }
    return p;
  }
  loadBuffer(u) {
    const p = this.json.buffers[u], a = this.fileLoader;
    if (p.type && p.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + p.type + " buffer type is not supported.");
    if (p.uri === void 0 && u === 0)
      return Promise.resolve(this.extensions[$.KHR_BINARY_GLTF].body);
    const d = this.options;
    return new Promise(function(m, h) {
      a.load(LoaderUtils.resolveURL(p.uri, d.path), m, void 0, function() {
        h(new Error('THREE.GLTFLoader: Failed to load buffer "' + p.uri + '".'));
      });
    });
  }
  loadBufferView(u) {
    const p = this.json.bufferViews[u];
    return this.getDependency("buffer", p.buffer).then(function(a) {
      const d = p.byteLength || 0, m = p.byteOffset || 0;
      return a.slice(m, m + d);
    });
  }
  loadAccessor(u) {
    const p = this, a = this.json, d = this.json.accessors[u];
    if (d.bufferView === void 0 && d.sparse === void 0)
      return Promise.resolve(null);
    const m = [];
    return d.bufferView !== void 0 ? m.push(this.getDependency("bufferView", d.bufferView)) : m.push(null), d.sparse !== void 0 && (m.push(this.getDependency("bufferView", d.sparse.indices.bufferView)), m.push(this.getDependency("bufferView", d.sparse.values.bufferView))), Promise.all(m).then(function(h) {
      const b = h[0], f = Yr[d.type], x = ts[d.componentType], E = x.BYTES_PER_ELEMENT, g = E * f, k = d.byteOffset || 0, V = d.bufferView !== void 0 ? a.bufferViews[d.bufferView].byteStride : void 0, L = d.normalized === true;
      let D, N;
      if (V && V !== g) {
        const R = Math.floor(k / V), q = "InterleavedBuffer:" + d.bufferView + ":" + d.componentType + ":" + R + ":" + d.count;
        let I = p.cache.get(q);
        I || (D = new x(b, R * V, d.count * V / E), I = new InterleavedBuffer(D, V / E), p.cache.add(q, I)), N = new InterleavedBufferAttribute(I, f, k % V / E, L);
      } else
        b === null ? D = new x(d.count * f) : D = new x(b, k, d.count * f), N = new BufferAttribute(D, f, L);
      if (d.sparse !== void 0) {
        const R = Yr.SCALAR, q = ts[d.sparse.indices.componentType], I = d.sparse.indices.byteOffset || 0, ie = d.sparse.values.byteOffset || 0, ue = new q(h[1], I, d.sparse.count * R), te = new x(h[2], ie, d.sparse.count * f);
        b !== null && (N = new BufferAttribute(N.array.slice(), N.itemSize, N.normalized));
        for (let Y = 0, z = ue.length; Y < z; Y++) {
          const J = ue[Y];
          if (N.setX(J, te[Y * f]), f >= 2 && N.setY(J, te[Y * f + 1]), f >= 3 && N.setZ(J, te[Y * f + 2]), f >= 4 && N.setW(J, te[Y * f + 3]), f >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return N;
    });
  }
  loadTexture(u) {
    const p = this.json, a = this.options, m = p.textures[u].source, h = p.images[m];
    let b = this.textureLoader;
    if (h.uri) {
      const f = a.manager.getHandler(h.uri);
      f !== null && (b = f);
    }
    return this.loadTextureImage(u, m, b);
  }
  loadTextureImage(u, p, a) {
    const d = this, m = this.json, h = m.textures[u], b = m.images[p], f = (b.uri || b.bufferView) + ":" + h.sampler;
    if (this.textureCache[f])
      return this.textureCache[f];
    const x = this.loadImageSource(p, a).then(function(E) {
      E.flipY = false, h.name && (E.name = h.name);
      const k = (m.samplers || {})[h.sampler] || {};
      return E.magFilter = $r[k.magFilter] || LinearFilter, E.minFilter = $r[k.minFilter] || LinearMipmapLinearFilter, E.wrapS = qr[k.wrapS] || RepeatWrapping, E.wrapT = qr[k.wrapT] || RepeatWrapping, d.associations.set(E, {
        textures: u
      }), E;
    }).catch(function() {
      return null;
    });
    return this.textureCache[f] = x, x;
  }
  loadImageSource(u, p) {
    const a = this, d = this.json, m = this.options;
    if (this.sourceCache[u] !== void 0)
      return this.sourceCache[u].then((g) => g.clone());
    const h = d.images[u], b = self.URL || self.webkitURL;
    let f = h.uri || "", x = false;
    if (h.bufferView !== void 0)
      f = a.getDependency("bufferView", h.bufferView).then(function(g) {
        x = true;
        const k = new Blob([g], {
          type: h.mimeType
        });
        return f = b.createObjectURL(k), f;
      });
    else if (h.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + u + " is missing URI and bufferView");
    const E = Promise.resolve(f).then(function(g) {
      return new Promise(function(k, V) {
        let L = k;
        p.isImageBitmapLoader === true && (L = function(D) {
          const N = new Texture(D);
          N.needsUpdate = true, k(N);
        }), p.load(LoaderUtils.resolveURL(g, m.path), L, void 0, V);
      });
    }).then(function(g) {
      return x === true && b.revokeObjectURL(f), g.userData.mimeType = h.mimeType || Cc(h.uri), g;
    }).catch(function(g) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", f), g;
    });
    return this.sourceCache[u] = E, E;
  }
  assignTexture(u, p, a, d) {
    const m = this;
    return this.getDependency("texture", a.index).then(function(h) {
      if (a.texCoord !== void 0 && a.texCoord != 0 && !(p === "aoMap" && a.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + a.texCoord + " for texture " + p + " not yet supported."), m.extensions[$.KHR_TEXTURE_TRANSFORM]) {
        const b = a.extensions !== void 0 ? a.extensions[$.KHR_TEXTURE_TRANSFORM] : void 0;
        if (b) {
          const f = m.associations.get(h);
          h = m.extensions[$.KHR_TEXTURE_TRANSFORM].extendTexture(h, b), m.associations.set(h, f);
        }
      }
      return d !== void 0 && (h.encoding = d), u[p] = h, h;
    });
  }
  assignFinalMaterial(u) {
    const p = u.geometry;
    let a = u.material;
    const d = p.attributes.tangent === void 0, m = p.attributes.color !== void 0, h = p.attributes.normal === void 0;
    if (u.isPoints) {
      const b = "PointsMaterial:" + a.uuid;
      let f = this.cache.get(b);
      f || (f = new PointsMaterial(), Material.prototype.copy.call(f, a), f.color.copy(a.color), f.map = a.map, f.sizeAttenuation = false, this.cache.add(b, f)), a = f;
    } else if (u.isLine) {
      const b = "LineBasicMaterial:" + a.uuid;
      let f = this.cache.get(b);
      f || (f = new LineBasicMaterial(), Material.prototype.copy.call(f, a), f.color.copy(a.color), this.cache.add(b, f)), a = f;
    }
    if (d || m || h) {
      let b = "ClonedMaterial:" + a.uuid + ":";
      a.isGLTFSpecularGlossinessMaterial && (b += "specular-glossiness:"), d && (b += "derivative-tangents:"), m && (b += "vertex-colors:"), h && (b += "flat-shading:");
      let f = this.cache.get(b);
      f || (f = a.clone(), m && (f.vertexColors = true), h && (f.flatShading = true), d && (f.normalScale && (f.normalScale.y *= -1), f.clearcoatNormalScale && (f.clearcoatNormalScale.y *= -1)), this.cache.add(b, f), this.associations.set(f, this.associations.get(a))), a = f;
    }
    a.aoMap && p.attributes.uv2 === void 0 && p.attributes.uv !== void 0 && p.setAttribute("uv2", p.attributes.uv), u.material = a;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(u) {
    const p = this, a = this.json, d = this.extensions, m = a.materials[u];
    let h;
    const b = {}, f = m.extensions || {}, x = [];
    if (f[$.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const g = d[$.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      h = g.getMaterialType(), x.push(g.extendParams(b, m, p));
    } else if (f[$.KHR_MATERIALS_UNLIT]) {
      const g = d[$.KHR_MATERIALS_UNLIT];
      h = g.getMaterialType(), x.push(g.extendParams(b, m, p));
    } else {
      const g = m.pbrMetallicRoughness || {};
      if (b.color = new Color(1, 1, 1), b.opacity = 1, Array.isArray(g.baseColorFactor)) {
        const k = g.baseColorFactor;
        b.color.fromArray(k), b.opacity = k[3];
      }
      g.baseColorTexture !== void 0 && x.push(p.assignTexture(b, "map", g.baseColorTexture, sRGBEncoding)), b.metalness = g.metallicFactor !== void 0 ? g.metallicFactor : 1, b.roughness = g.roughnessFactor !== void 0 ? g.roughnessFactor : 1, g.metallicRoughnessTexture !== void 0 && (x.push(p.assignTexture(b, "metalnessMap", g.metallicRoughnessTexture)), x.push(p.assignTexture(b, "roughnessMap", g.metallicRoughnessTexture))), h = this._invokeOne(function(k) {
        return k.getMaterialType && k.getMaterialType(u);
      }), x.push(Promise.all(this._invokeAll(function(k) {
        return k.extendMaterialParams && k.extendMaterialParams(u, b);
      })));
    }
    m.doubleSided === true && (b.side = DoubleSide);
    const E = m.alphaMode || $i.OPAQUE;
    if (E === $i.BLEND ? (b.transparent = true, b.depthWrite = false) : (b.transparent = false, E === $i.MASK && (b.alphaTest = m.alphaCutoff !== void 0 ? m.alphaCutoff : 0.5)), m.normalTexture !== void 0 && h !== MeshBasicMaterial && (x.push(p.assignTexture(b, "normalMap", m.normalTexture)), b.normalScale = new Vector2(1, 1), m.normalTexture.scale !== void 0)) {
      const g = m.normalTexture.scale;
      b.normalScale.set(g, g);
    }
    return m.occlusionTexture !== void 0 && h !== MeshBasicMaterial && (x.push(p.assignTexture(b, "aoMap", m.occlusionTexture)), m.occlusionTexture.strength !== void 0 && (b.aoMapIntensity = m.occlusionTexture.strength)), m.emissiveFactor !== void 0 && h !== MeshBasicMaterial && (b.emissive = new Color().fromArray(m.emissiveFactor)), m.emissiveTexture !== void 0 && h !== MeshBasicMaterial && x.push(p.assignTexture(b, "emissiveMap", m.emissiveTexture, sRGBEncoding)), Promise.all(x).then(function() {
      let g;
      return h === Qi ? g = d[$.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(b) : g = new h(b), m.name && (g.name = m.name), qt(g, m), p.associations.set(g, {
        materials: u
      }), m.extensions && Jn(d, g, m), g;
    });
  }
  createUniqueName(u) {
    const p = PropertyBinding.sanitizeNodeName(u || "");
    let a = p;
    for (let d = 1; this.nodeNamesUsed[a]; ++d)
      a = p + "_" + d;
    return this.nodeNamesUsed[a] = true, a;
  }
  loadGeometries(u) {
    const p = this, a = this.extensions, d = this.primitiveCache;
    function m(b) {
      return a[$.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(b, p).then(function(f) {
        return Wr(f, b, p);
      });
    }
    const h = [];
    for (let b = 0, f = u.length; b < f; b++) {
      const x = u[b], E = yc(x), g = d[E];
      if (g)
        h.push(g.promise);
      else {
        let k;
        x.extensions && x.extensions[$.KHR_DRACO_MESH_COMPRESSION] ? k = m(x) : k = Wr(new BufferGeometry(), x, p), d[E] = {
          primitive: x,
          promise: k
        }, h.push(k);
      }
    }
    return Promise.all(h);
  }
  loadMesh(u) {
    const p = this, a = this.json, d = this.extensions, m = a.meshes[u], h = m.primitives, b = [];
    for (let f = 0, x = h.length; f < x; f++) {
      const E = h[f].material === void 0 ? gc(this.cache) : this.getDependency("material", h[f].material);
      b.push(E);
    }
    return b.push(p.loadGeometries(h)), Promise.all(b).then(function(f) {
      const x = f.slice(0, f.length - 1), E = f[f.length - 1], g = [];
      for (let V = 0, L = E.length; V < L; V++) {
        const D = E[V], N = h[V];
        let R;
        const q = x[V];
        if (N.mode === ct.TRIANGLES || N.mode === ct.TRIANGLE_STRIP || N.mode === ct.TRIANGLE_FAN || N.mode === void 0)
          R = m.isSkinnedMesh === true ? new SkinnedMesh(D, q) : new Mesh(D, q), R.isSkinnedMesh === true && !R.geometry.attributes.skinWeight.normalized && R.normalizeSkinWeights(), N.mode === ct.TRIANGLE_STRIP ? R.geometry = Zr(R.geometry, TriangleStripDrawMode) : N.mode === ct.TRIANGLE_FAN && (R.geometry = Zr(R.geometry, TriangleFanDrawMode));
        else if (N.mode === ct.LINES)
          R = new LineSegments(D, q);
        else if (N.mode === ct.LINE_STRIP)
          R = new Line(D, q);
        else if (N.mode === ct.LINE_LOOP)
          R = new LineLoop(D, q);
        else if (N.mode === ct.POINTS)
          R = new Points(D, q);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + N.mode);
        Object.keys(R.geometry.morphAttributes).length > 0 && xc(R, m), R.name = p.createUniqueName(m.name || "mesh_" + u), qt(R, m), N.extensions && Jn(d, R, N), p.assignFinalMaterial(R), g.push(R);
      }
      for (let V = 0, L = g.length; V < L; V++)
        p.associations.set(g[V], {
          meshes: u,
          primitives: V
        });
      if (g.length === 1)
        return g[0];
      const k = new Group();
      p.associations.set(k, {
        meshes: u
      });
      for (let V = 0, L = g.length; V < L; V++)
        k.add(g[V]);
      return k;
    });
  }
  loadCamera(u) {
    let p;
    const a = this.json.cameras[u], d = a[a.type];
    if (!d) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return a.type === "perspective" ? p = new PerspectiveCamera(MathUtils.radToDeg(d.yfov), d.aspectRatio || 1, d.znear || 1, d.zfar || 2e6) : a.type === "orthographic" && (p = new OrthographicCamera(-d.xmag, d.xmag, d.ymag, -d.ymag, d.znear, d.zfar)), a.name && (p.name = this.createUniqueName(a.name)), qt(p, a), Promise.resolve(p);
  }
  loadSkin(u) {
    const p = this.json.skins[u], a = {
      joints: p.joints
    };
    return p.inverseBindMatrices === void 0 ? Promise.resolve(a) : this.getDependency("accessor", p.inverseBindMatrices).then(function(d) {
      return a.inverseBindMatrices = d, a;
    });
  }
  loadAnimation(u) {
    const a = this.json.animations[u], d = [], m = [], h = [], b = [], f = [];
    for (let x = 0, E = a.channels.length; x < E; x++) {
      const g = a.channels[x], k = a.samplers[g.sampler], V = g.target, L = V.node, D = a.parameters !== void 0 ? a.parameters[k.input] : k.input, N = a.parameters !== void 0 ? a.parameters[k.output] : k.output;
      d.push(this.getDependency("node", L)), m.push(this.getDependency("accessor", D)), h.push(this.getDependency("accessor", N)), b.push(k), f.push(V);
    }
    return Promise.all([Promise.all(d), Promise.all(m), Promise.all(h), Promise.all(b), Promise.all(f)]).then(function(x) {
      const E = x[0], g = x[1], k = x[2], V = x[3], L = x[4], D = [];
      for (let R = 0, q = E.length; R < q; R++) {
        const I = E[R], ie = g[R], ue = k[R], te = V[R], Y = L[R];
        if (I === void 0)
          continue;
        I.updateMatrix();
        let z;
        switch (Mt[Y.path]) {
          case Mt.weights:
            z = NumberKeyframeTrack;
            break;
          case Mt.rotation:
            z = QuaternionKeyframeTrack;
            break;
          case Mt.position:
          case Mt.scale:
          default:
            z = VectorKeyframeTrack;
            break;
        }
        const J = I.name ? I.name : I.uuid, ne = te.interpolation !== void 0 ? _c[te.interpolation] : InterpolateLinear, be = [];
        Mt[Y.path] === Mt.weights ? I.traverse(function(de) {
          de.morphTargetInfluences && be.push(de.name ? de.name : de.uuid);
        }) : be.push(J);
        let ye = ue.array;
        if (ue.normalized) {
          const de = er(ye.constructor), pe = new Float32Array(ye.length);
          for (let ve = 0, X = ye.length; ve < X; ve++)
            pe[ve] = ye[ve] * de;
          ye = pe;
        }
        for (let de = 0, pe = be.length; de < pe; de++) {
          const ve = new z(be[de] + "." + Mt[Y.path], ie.array, ye, ne);
          te.interpolation === "CUBICSPLINE" && (ve.createInterpolant = function(j) {
            const pt = this instanceof QuaternionKeyframeTrack ? bc : lo;
            return new pt(this.times, this.values, this.getValueSize() / 3, j);
          }, ve.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), D.push(ve);
        }
      }
      const N = a.name ? a.name : "animation_" + u;
      return new AnimationClip(N, void 0, D);
    });
  }
  createNodeMesh(u) {
    const p = this.json, a = this, d = p.nodes[u];
    return d.mesh === void 0 ? null : a.getDependency("mesh", d.mesh).then(function(m) {
      const h = a._getNodeRef(a.meshCache, d.mesh, m);
      return d.weights !== void 0 && h.traverse(function(b) {
        if (!!b.isMesh)
          for (let f = 0, x = d.weights.length; f < x; f++)
            b.morphTargetInfluences[f] = d.weights[f];
      }), h;
    });
  }
  loadNode(u) {
    const p = this.json, a = this.extensions, d = this, m = p.nodes[u], h = m.name ? d.createUniqueName(m.name) : "";
    return function() {
      const b = [], f = d._invokeOne(function(x) {
        return x.createNodeMesh && x.createNodeMesh(u);
      });
      return f && b.push(f), m.camera !== void 0 && b.push(d.getDependency("camera", m.camera).then(function(x) {
        return d._getNodeRef(d.cameraCache, m.camera, x);
      })), d._invokeAll(function(x) {
        return x.createNodeAttachment && x.createNodeAttachment(u);
      }).forEach(function(x) {
        b.push(x);
      }), Promise.all(b);
    }().then(function(b) {
      let f;
      if (m.isBone === true ? f = new Bone() : b.length > 1 ? f = new Group() : b.length === 1 ? f = b[0] : f = new Object3D(), f !== b[0])
        for (let x = 0, E = b.length; x < E; x++)
          f.add(b[x]);
      if (m.name && (f.userData.name = m.name, f.name = h), qt(f, m), m.extensions && Jn(a, f, m), m.matrix !== void 0) {
        const x = new Matrix4();
        x.fromArray(m.matrix), f.applyMatrix4(x);
      } else
        m.translation !== void 0 && f.position.fromArray(m.translation), m.rotation !== void 0 && f.quaternion.fromArray(m.rotation), m.scale !== void 0 && f.scale.fromArray(m.scale);
      return d.associations.has(f) || d.associations.set(f, {}), d.associations.get(f).nodes = u, f;
    });
  }
  loadScene(u) {
    const p = this.json, a = this.extensions, d = this.json.scenes[u], m = this, h = new Group();
    d.name && (h.name = m.createUniqueName(d.name)), qt(h, d), d.extensions && Jn(a, h, d);
    const b = d.nodes || [], f = [];
    for (let x = 0, E = b.length; x < E; x++)
      f.push(co(b[x], h, p, m));
    return Promise.all(f).then(function() {
      const x = (E) => {
        const g = /* @__PURE__ */ new Map();
        for (const [k, V] of m.associations)
          (k instanceof Material || k instanceof Texture) && g.set(k, V);
        return E.traverse((k) => {
          const V = m.associations.get(k);
          V != null && g.set(k, V);
        }), g;
      };
      return m.associations = x(h), h;
    });
  }
};
function co(T, u, p, a) {
  const d = p.nodes[T];
  return a.getDependency("node", T).then(function(m) {
    if (d.skin === void 0)
      return m;
    let h;
    return a.getDependency("skin", d.skin).then(function(b) {
      h = b;
      const f = [];
      for (let x = 0, E = h.joints.length; x < E; x++)
        f.push(a.getDependency("node", h.joints[x]));
      return Promise.all(f);
    }).then(function(b) {
      return m.traverse(function(f) {
        if (!f.isMesh)
          return;
        const x = [], E = [];
        for (let g = 0, k = b.length; g < k; g++) {
          const V = b[g];
          if (V) {
            x.push(V);
            const L = new Matrix4();
            h.inverseBindMatrices !== void 0 && L.fromArray(h.inverseBindMatrices.array, g * 16), E.push(L);
          } else
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', h.joints[g]);
        }
        f.bind(new Skeleton(x, E), f.matrixWorld);
      }), m;
    });
  }).then(function(m) {
    u.add(m);
    const h = [];
    if (d.children) {
      const b = d.children;
      for (let f = 0, x = b.length; f < x; f++) {
        const E = b[f];
        h.push(co(E, m, p, a));
      }
    }
    return Promise.all(h);
  });
}
function Pc(T, u, p) {
  const a = u.attributes, d = new Box3();
  if (a.POSITION !== void 0) {
    const b = p.json.accessors[a.POSITION], f = b.min, x = b.max;
    if (f !== void 0 && x !== void 0) {
      if (d.set(new Vector3(f[0], f[1], f[2]), new Vector3(x[0], x[1], x[2])), b.normalized) {
        const E = er(ts[b.componentType]);
        d.min.multiplyScalar(E), d.max.multiplyScalar(E);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const m = u.targets;
  if (m !== void 0) {
    const b = new Vector3(), f = new Vector3();
    for (let x = 0, E = m.length; x < E; x++) {
      const g = m[x];
      if (g.POSITION !== void 0) {
        const k = p.json.accessors[g.POSITION], V = k.min, L = k.max;
        if (V !== void 0 && L !== void 0) {
          if (f.setX(Math.max(Math.abs(V[0]), Math.abs(L[0]))), f.setY(Math.max(Math.abs(V[1]), Math.abs(L[1]))), f.setZ(Math.max(Math.abs(V[2]), Math.abs(L[2]))), k.normalized) {
            const D = er(ts[k.componentType]);
            f.multiplyScalar(D);
          }
          b.max(f);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    d.expandByVector(b);
  }
  T.boundingBox = d;
  const h = new Sphere();
  d.getCenter(h.center), h.radius = d.min.distanceTo(d.max) / 2, T.boundingSphere = h;
}
function Wr(T, u, p) {
  const a = u.attributes, d = [];
  function m(h, b) {
    return p.getDependency("accessor", h).then(function(f) {
      T.setAttribute(b, f);
    });
  }
  for (const h in a) {
    const b = Ji[h] || h.toLowerCase();
    b in T.attributes || d.push(m(a[h], b));
  }
  if (u.indices !== void 0 && !T.index) {
    const h = p.getDependency("accessor", u.indices).then(function(b) {
      T.setIndex(b);
    });
    d.push(h);
  }
  return qt(T, u), Pc(T, u, p), Promise.all(d).then(function() {
    return u.targets !== void 0 ? wc(T, u.targets, p) : T;
  });
}
function Zr(T, u) {
  let p = T.getIndex();
  if (p === null) {
    const h = [], b = T.getAttribute("position");
    if (b !== void 0) {
      for (let f = 0; f < b.count; f++)
        h.push(f);
      T.setIndex(h), p = T.getIndex();
    } else
      return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), T;
  }
  const a = p.count - 2, d = [];
  if (u === TriangleFanDrawMode)
    for (let h = 1; h <= a; h++)
      d.push(p.getX(0)), d.push(p.getX(h)), d.push(p.getX(h + 1));
  else
    for (let h = 0; h < a; h++)
      h % 2 === 0 ? (d.push(p.getX(h)), d.push(p.getX(h + 1)), d.push(p.getX(h + 2))) : (d.push(p.getX(h + 2)), d.push(p.getX(h + 1)), d.push(p.getX(h)));
  d.length / 3 !== a && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const m = T.clone();
  return m.setIndex(d), m;
}
var po = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function kc(T) {
  return T && T.__esModule && Object.prototype.hasOwnProperty.call(T, "default") ? T.default : T;
}
var qi = /* @__PURE__ */ new WeakMap();
var Tc = class extends Loader {
  constructor(u) {
    super(u), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(u) {
    return this.decoderPath = u, this;
  }
  setDecoderConfig(u) {
    return this.decoderConfig = u, this;
  }
  setWorkerLimit(u) {
    return this.workerLimit = u, this;
  }
  load(u, p, a, d) {
    const m = new FileLoader(this.manager);
    m.setPath(this.path), m.setResponseType("arraybuffer"), m.setRequestHeader(this.requestHeader), m.setWithCredentials(this.withCredentials), m.load(u, (h) => {
      const b = {
        attributeIDs: this.defaultAttributeIDs,
        attributeTypes: this.defaultAttributeTypes,
        useUniqueIDs: false
      };
      this.decodeGeometry(h, b).then(p).catch(d);
    }, a, d);
  }
  decodeDracoFile(u, p, a, d) {
    const m = {
      attributeIDs: a || this.defaultAttributeIDs,
      attributeTypes: d || this.defaultAttributeTypes,
      useUniqueIDs: !!a
    };
    this.decodeGeometry(u, m).then(p);
  }
  decodeGeometry(u, p) {
    for (const f in p.attributeTypes) {
      const x = p.attributeTypes[f];
      x.BYTES_PER_ELEMENT !== void 0 && (p.attributeTypes[f] = x.name);
    }
    const a = JSON.stringify(p);
    if (qi.has(u)) {
      const f = qi.get(u);
      if (f.key === a)
        return f.promise;
      if (u.byteLength === 0)
        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
    }
    let d;
    const m = this.workerNextTaskID++, h = u.byteLength, b = this._getWorker(m, h).then((f) => (d = f, new Promise((x, E) => {
      d._callbacks[m] = {
        resolve: x,
        reject: E
      }, d.postMessage({
        type: "decode",
        id: m,
        taskConfig: p,
        buffer: u
      }, [u]);
    }))).then((f) => this._createGeometry(f.geometry));
    return b.catch(() => true).then(() => {
      d && m && this._releaseTask(d, m);
    }), qi.set(u, {
      key: a,
      promise: b
    }), b;
  }
  _createGeometry(u) {
    const p = new BufferGeometry();
    u.index && p.setIndex(new BufferAttribute(u.index.array, 1));
    for (let a = 0; a < u.attributes.length; a++) {
      const d = u.attributes[a], m = d.name, h = d.array, b = d.itemSize;
      p.setAttribute(m, new BufferAttribute(h, b));
    }
    return p;
  }
  _loadLibrary(u, p) {
    const a = new FileLoader(this.manager);
    return a.setPath(this.decoderPath), a.setResponseType(p), a.setWithCredentials(this.withCredentials), new Promise((d, m) => {
      a.load(u, d, void 0, m);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const u = typeof WebAssembly != "object" || this.decoderConfig.type === "js", p = [];
    return u ? p.push(this._loadLibrary("draco_decoder.js", "text")) : (p.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), p.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(p).then((a) => {
      const d = a[0];
      u || (this.decoderConfig.wasmBinary = a[1]);
      const m = Mc.toString(), h = ["/* draco decoder */", d, "", "/* worker */", m.substring(m.indexOf("{") + 1, m.lastIndexOf("}"))].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([h]));
    }), this.decoderPending;
  }
  _getWorker(u, p) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const d = new Worker(this.workerSourceURL);
        d._callbacks = {}, d._taskCosts = {}, d._taskLoad = 0, d.postMessage({
          type: "init",
          decoderConfig: this.decoderConfig
        }), d.onmessage = function(m) {
          const h = m.data;
          switch (h.type) {
            case "decode":
              d._callbacks[h.id].resolve(h);
              break;
            case "error":
              d._callbacks[h.id].reject(h);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + h.type + '"');
          }
        }, this.workerPool.push(d);
      } else
        this.workerPool.sort(function(d, m) {
          return d._taskLoad > m._taskLoad ? -1 : 1;
        });
      const a = this.workerPool[this.workerPool.length - 1];
      return a._taskCosts[u] = p, a._taskLoad += p, a;
    });
  }
  _releaseTask(u, p) {
    u._taskLoad -= u._taskCosts[p], delete u._callbacks[p], delete u._taskCosts[p];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((u) => u._taskLoad));
  }
  dispose() {
    for (let u = 0; u < this.workerPool.length; ++u)
      this.workerPool[u].terminate();
    return this.workerPool.length = 0, this;
  }
};
function Mc() {
  let T, u;
  onmessage = function(h) {
    const b = h.data;
    switch (b.type) {
      case "init":
        T = b.decoderConfig, u = new Promise(function(E) {
          T.onModuleLoaded = function(g) {
            E({
              draco: g
            });
          }, DracoDecoderModule(T);
        });
        break;
      case "decode":
        const f = b.buffer, x = b.taskConfig;
        u.then((E) => {
          const g = E.draco, k = new g.Decoder(), V = new g.DecoderBuffer();
          V.Init(new Int8Array(f), f.byteLength);
          try {
            const L = p(g, k, V, x), D = L.attributes.map((N) => N.array.buffer);
            L.index && D.push(L.index.array.buffer), self.postMessage({
              type: "decode",
              id: b.id,
              geometry: L
            }, D);
          } catch (L) {
            console.error(L), self.postMessage({
              type: "error",
              id: b.id,
              error: L.message
            });
          } finally {
            g.destroy(V), g.destroy(k);
          }
        });
        break;
    }
  };
  function p(h, b, f, x) {
    const E = x.attributeIDs, g = x.attributeTypes;
    let k, V;
    const L = b.GetEncodedGeometryType(f);
    if (L === h.TRIANGULAR_MESH)
      k = new h.Mesh(), V = b.DecodeBufferToMesh(f, k);
    else if (L === h.POINT_CLOUD)
      k = new h.PointCloud(), V = b.DecodeBufferToPointCloud(f, k);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!V.ok() || k.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + V.error_msg());
    const D = {
      index: null,
      attributes: []
    };
    for (const N in E) {
      const R = self[g[N]];
      let q, I;
      if (x.useUniqueIDs)
        I = E[N], q = b.GetAttributeByUniqueId(k, I);
      else {
        if (I = b.GetAttributeId(k, h[E[N]]), I === -1)
          continue;
        q = b.GetAttribute(k, I);
      }
      D.attributes.push(d(h, b, k, N, R, q));
    }
    return L === h.TRIANGULAR_MESH && (D.index = a(h, b, k)), h.destroy(k), D;
  }
  function a(h, b, f) {
    const E = f.num_faces() * 3, g = E * 4, k = h._malloc(g);
    b.GetTrianglesUInt32Array(f, g, k);
    const V = new Uint32Array(h.HEAPF32.buffer, k, E).slice();
    return h._free(k), {
      array: V,
      itemSize: 1
    };
  }
  function d(h, b, f, x, E, g) {
    const k = g.num_components(), L = f.num_points() * k, D = L * E.BYTES_PER_ELEMENT, N = m(h, E), R = h._malloc(D);
    b.GetAttributeDataArrayForAllPoints(f, g, N, D, R);
    const q = new E(h.HEAPF32.buffer, R, L).slice();
    return h._free(R), {
      name: x,
      array: q,
      itemSize: k
    };
  }
  function m(h, b) {
    switch (b) {
      case Float32Array:
        return h.DT_FLOAT32;
      case Int8Array:
        return h.DT_INT8;
      case Int16Array:
        return h.DT_INT16;
      case Int32Array:
        return h.DT_INT32;
      case Uint8Array:
        return h.DT_UINT8;
      case Uint16Array:
        return h.DT_UINT16;
      case Uint32Array:
        return h.DT_UINT32;
    }
  }
}
var Oc = defineComponent({
  __name: "OrbitControls",
  setup(T) {
    let u;
    const p = inject("camera"), a = inject("renderer");
    return watch(
      [p, a],
      () => {
        if ((p == null ? void 0 : p.value) && (a == null ? void 0 : a.value)) {
          u = new Xl(p.value, unref(a).domElement), u.enableDamping = true;
          const { onLoop: d } = re();
          d(() => {
            u && u.update();
          });
        }
      },
      {
        deep: true
      }
    ), () => {
    };
  }
});
var tr = { exports: {} };
(function(T, u) {
  (function(p, a) {
    a(u);
  })(po, function(p) {
    class a {
      constructor(e) {
        const [t, i] = e.split("-"), c = t.split(".");
        this.major = parseInt(c[0], 10), this.minor = parseInt(c[1], 10), this.patch = parseInt(c[2], 10), this.prerelease = i != null ? i : null;
      }
      toString() {
        const e = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [e, this.prerelease].join("-") : e;
      }
    }
    class d {
      constructor(e) {
        this.controller_ = e;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(e) {
        this.controller_.viewProps.set("disabled", e);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(e) {
        this.controller_.viewProps.set("hidden", e);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", true);
      }
    }
    class m {
      constructor(e) {
        this.target = e;
      }
    }
    class h extends m {
      constructor(e, t, i, c) {
        super(e), this.value = t, this.presetKey = i, this.last = c != null ? c : true;
      }
    }
    class b extends m {
      constructor(e, t, i) {
        super(e), this.value = t, this.presetKey = i;
      }
    }
    class f extends m {
      constructor(e, t) {
        super(e), this.expanded = t;
      }
    }
    class x extends m {
      constructor(e, t) {
        super(e), this.index = t;
      }
    }
    function E(n) {
      return n;
    }
    function g(n) {
      return n == null;
    }
    function k(n, e) {
      if (n.length !== e.length)
        return false;
      for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
          return false;
      return true;
    }
    const V = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (n) => `Invalid parameters for '${n.name}'`,
      nomatchingcontroller: (n) => `No matching controller for '${n.key}'`,
      nomatchingview: (n) => `No matching view for '${JSON.stringify(n.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (n) => `Property '${n.name}' not found`,
      shouldneverhappen: () => "This error should never happen"
    };
    class L {
      constructor(e) {
        var t;
        this.message = (t = V[e.type](e.context)) !== null && t !== void 0 ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type;
      }
      static alreadyDisposed() {
        return new L({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new L({
          type: "notbindable"
        });
      }
      static propertyNotFound(e) {
        return new L({
          type: "propertynotfound",
          context: {
            name: e
          }
        });
      }
      static shouldNeverHappen() {
        return new L({ type: "shouldneverhappen" });
      }
    }
    class D {
      constructor(e, t, i) {
        this.obj_ = e, this.key_ = t, this.presetKey_ = i != null ? i : t;
      }
      static isBindable(e) {
        return !(e === null || typeof e != "object");
      }
      get key() {
        return this.key_;
      }
      get presetKey() {
        return this.presetKey_;
      }
      read() {
        return this.obj_[this.key_];
      }
      write(e) {
        this.obj_[this.key_] = e;
      }
      writeProperty(e, t) {
        const i = this.read();
        if (!D.isBindable(i))
          throw L.notBindable();
        if (!(e in i))
          throw L.propertyNotFound(e);
        i[e] = t;
      }
    }
    class N extends d {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      get title() {
        var e;
        return (e = this.controller_.valueController.props.get("title")) !== null && e !== void 0 ? e : "";
      }
      set title(e) {
        this.controller_.valueController.props.set("title", e);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.controller_.valueController.emitter.on(e, () => {
          i(new m(this));
        }), this;
      }
    }
    class R {
      constructor() {
        this.observers_ = {};
      }
      on(e, t) {
        let i = this.observers_[e];
        return i || (i = this.observers_[e] = []), i.push({
          handler: t
        }), this;
      }
      off(e, t) {
        const i = this.observers_[e];
        return i && (this.observers_[e] = i.filter((c) => c.handler !== t)), this;
      }
      emit(e, t) {
        const i = this.observers_[e];
        !i || i.forEach((c) => {
          c.handler(t);
        });
      }
    }
    const q = "tp";
    function I(n) {
      return (t, i) => [
        q,
        "-",
        n,
        "v",
        t ? `_${t}` : "",
        i ? `-${i}` : ""
      ].join("");
    }
    function ie(n, e) {
      return (t) => e(n(t));
    }
    function ue(n) {
      return n.rawValue;
    }
    function te(n, e) {
      n.emitter.on("change", ie(ue, e)), e(n.rawValue);
    }
    function Y(n, e, t) {
      te(n.value(e), t);
    }
    function z(n, e, t) {
      t ? n.classList.add(e) : n.classList.remove(e);
    }
    function J(n, e) {
      return (t) => {
        z(n, e, t);
      };
    }
    function ne(n, e) {
      te(n, (t) => {
        e.textContent = t != null ? t : "";
      });
    }
    const be = I("btn");
    class ye {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(be()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("button");
        i.classList.add(be("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
        const c = e.createElement("div");
        c.classList.add(be("t")), ne(t.props.value("title"), c), this.buttonElement.appendChild(c);
      }
    }
    class de {
      constructor(e, t) {
        this.emitter = new R(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new ye(e, {
          props: this.props,
          viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class pe {
      constructor(e, t) {
        var i;
        this.constraint_ = t == null ? void 0 : t.constraint, this.equals_ = (i = t == null ? void 0 : t.equals) !== null && i !== void 0 ? i : (c, _) => c === _, this.emitter = new R(), this.rawValue_ = e;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(e) {
        this.setRawValue(e, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(e, t) {
        const i = t != null ? t : {
          forceEmit: false,
          last: true
        }, c = this.constraint_ ? this.constraint_.constrain(e) : e;
        !!this.equals_(this.rawValue_, c) && !i.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.rawValue_ = c, this.emitter.emit("change", {
          options: i,
          rawValue: c,
          sender: this
        }));
      }
    }
    class ve {
      constructor(e) {
        this.emitter = new R(), this.value_ = e;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(e) {
        this.setRawValue(e, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(e, t) {
        const i = t != null ? t : {
          forceEmit: false,
          last: true
        };
        this.value_ === e && !i.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.value_ = e, this.emitter.emit("change", {
          options: i,
          rawValue: this.value_,
          sender: this
        }));
      }
    }
    function X(n, e) {
      const t = e == null ? void 0 : e.constraint, i = e == null ? void 0 : e.equals;
      return !t && !i ? new ve(n) : new pe(n, e);
    }
    class j {
      constructor(e) {
        this.emitter = new R(), this.valMap_ = e;
        for (const t in this.valMap_)
          this.valMap_[t].emitter.on("change", () => {
            this.emitter.emit("change", {
              key: t,
              sender: this
            });
          });
      }
      static createCore(e) {
        return Object.keys(e).reduce((i, c) => Object.assign(i, {
          [c]: X(e[c])
        }), {});
      }
      static fromObject(e) {
        const t = this.createCore(e);
        return new j(t);
      }
      get(e) {
        return this.valMap_[e].rawValue;
      }
      set(e, t) {
        this.valMap_[e].rawValue = t;
      }
      value(e) {
        return this.valMap_[e];
      }
    }
    function pt(n, e) {
      const i = Object.keys(e).reduce((c, _) => {
        if (c === void 0)
          return;
        const y = e[_], M = y(n[_]);
        return M.succeeded ? Object.assign(Object.assign({}, c), { [_]: M.value }) : void 0;
      }, {});
      return i;
    }
    function Zt(n, e) {
      return n.reduce((t, i) => {
        if (t === void 0)
          return;
        const c = e(i);
        if (!(!c.succeeded || c.value === void 0))
          return [...t, c.value];
      }, []);
    }
    function Qt(n) {
      return n === null ? false : typeof n == "object";
    }
    function _e(n) {
      return (e) => (t) => {
        if (!e && t === void 0)
          return {
            succeeded: false,
            value: void 0
          };
        if (e && t === void 0)
          return {
            succeeded: true,
            value: void 0
          };
        const i = n(t);
        return i !== void 0 ? {
          succeeded: true,
          value: i
        } : {
          succeeded: false,
          value: void 0
        };
      };
    }
    function Lt(n) {
      return {
        custom: (e) => _e(e)(n),
        boolean: _e((e) => typeof e == "boolean" ? e : void 0)(n),
        number: _e((e) => typeof e == "number" ? e : void 0)(n),
        string: _e((e) => typeof e == "string" ? e : void 0)(n),
        function: _e((e) => typeof e == "function" ? e : void 0)(n),
        constant: (e) => _e((t) => t === e ? e : void 0)(n),
        raw: _e((e) => e)(n),
        object: (e) => _e((t) => {
          if (!!Qt(t))
            return pt(t, e);
        })(n),
        array: (e) => _e((t) => {
          if (!!Array.isArray(t))
            return Zt(t, e);
        })(n)
      };
    }
    const H = {
      optional: Lt(true),
      required: Lt(false)
    };
    function re2(n, e) {
      const t = H.required.object(e)(n);
      return t.succeeded ? t.value : void 0;
    }
    function wn(n) {
      return n && n.parentElement && n.parentElement.removeChild(n), null;
    }
    function Jt() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const St = I(""), At = {
      veryfirst: "vfst",
      first: "fst",
      last: "lst",
      verylast: "vlst"
    };
    class Ce {
      constructor(e) {
        this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
        const t = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          Jt().forEach((i) => {
            t.classList.remove(St(void 0, At[i]));
          }), this.blade.get("positions").forEach((i) => {
            t.classList.add(St(void 0, At[i]));
          });
        }), this.viewProps.handleDispose(() => {
          wn(t);
        });
      }
      get parent() {
        return this.parent_;
      }
    }
    const Ee = "http://www.w3.org/2000/svg";
    function Je2(n) {
      n.offsetHeight;
    }
    function et(n, e) {
      const t = n.style.transition;
      n.style.transition = "none", e(), n.style.transition = t;
    }
    function ut(n) {
      return n.ontouchstart !== void 0;
    }
    function dt() {
      return new Function("return this")();
    }
    function xn() {
      return dt().document;
    }
    function yn(n) {
      const e = n.ownerDocument.defaultView;
      return e && "document" in e ? n.getContext("2d") : null;
    }
    const Vt = {
      check: '<path d="M2 8l4 4l8 -8"/>',
      dropdown: '<path d="M5 7h6l-3 3 z"/>',
      p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
    };
    function $e(n, e) {
      const t = n.createElementNS(Ee, "svg");
      return t.innerHTML = Vt[e], t;
    }
    function tt(n, e, t) {
      n.insertBefore(e, n.children[t]);
    }
    function qe(n) {
      n.parentElement && n.parentElement.removeChild(n);
    }
    function en(n) {
      for (; n.children.length > 0; )
        n.removeChild(n.children[0]);
    }
    function tn(n) {
      for (; n.childNodes.length > 0; )
        n.removeChild(n.childNodes[0]);
    }
    function Ae(n) {
      return n.relatedTarget ? n.relatedTarget : "explicitOriginalTarget" in n ? n.explicitOriginalTarget : null;
    }
    const Ye = I("lbl");
    function Cn(n, e) {
      const t = n.createDocumentFragment();
      return e.split(`
`).map((c) => n.createTextNode(c)).forEach((c, _) => {
        _ > 0 && t.appendChild(n.createElement("br")), t.appendChild(c);
      }), t;
    }
    class Rt {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(Ye()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("div");
        i.classList.add(Ye("l")), Y(t.props, "label", (_) => {
          g(_) ? this.element.classList.add(Ye(void 0, "nol")) : (this.element.classList.remove(Ye(void 0, "nol")), tn(i), i.appendChild(Cn(e, _)));
        }), this.element.appendChild(i), this.labelElement = i;
        const c = e.createElement("div");
        c.classList.add(Ye("v")), this.element.appendChild(c), this.valueElement = c;
      }
    }
    class Ve extends Ce {
      constructor(e, t) {
        const i = t.valueController.viewProps;
        super(Object.assign(Object.assign({}, t), { view: new Rt(e, {
          props: t.props,
          viewProps: i
        }), viewProps: i })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const ht = {
      id: "button",
      type: "blade",
      accept(n) {
        const e = H, t = re2(n, {
          title: e.required.string,
          view: e.required.constant("button"),
          label: e.optional.string
        });
        return t ? { params: t } : null;
      },
      controller(n) {
        return new Ve(n.document, {
          blade: n.blade,
          props: j.fromObject({
            label: n.params.label
          }),
          valueController: new de(n.document, {
            props: j.fromObject({
              title: n.params.title
            }),
            viewProps: n.viewProps
          })
        });
      },
      api(n) {
        return !(n.controller instanceof Ve) || !(n.controller.valueController instanceof de) ? null : new N(n.controller);
      }
    };
    class Pe extends Ce {
      constructor(e) {
        super(e), this.value = e.value;
      }
    }
    function De() {
      return new j({
        positions: X([], {
          equals: k
        })
      });
    }
    class Fe extends j {
      constructor(e) {
        super(e);
      }
      static create(e) {
        const t = {
          completed: true,
          expanded: e,
          expandedHeight: null,
          shouldFixHeight: false,
          temporaryExpanded: null
        }, i = j.createCore(t);
        return new Fe(i);
      }
      get styleExpanded() {
        var e;
        return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const e = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !g(e) ? `${e}px` : "auto";
      }
      bindExpandedClass(e, t) {
        const i = () => {
          this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
        };
        Y(this, "expanded", i), Y(this, "temporaryExpanded", i);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
      }
    }
    function C(n, e) {
      let t = 0;
      return et(e, () => {
        n.set("expandedHeight", null), n.set("temporaryExpanded", true), Je2(e), t = e.clientHeight, n.set("temporaryExpanded", null), Je2(e);
      }), t;
    }
    function S(n, e) {
      e.style.height = n.styleHeight;
    }
    function B(n, e) {
      n.value("expanded").emitter.on("beforechange", () => {
        n.set("completed", false), g(n.get("expandedHeight")) && n.set("expandedHeight", C(n, e)), n.set("shouldFixHeight", true), Je2(e);
      }), n.emitter.on("change", () => {
        S(n, e);
      }), S(n, e), e.addEventListener("transitionend", (t) => {
        t.propertyName === "height" && n.cleanUpTransition();
      });
    }
    class G extends d {
      constructor(e, t) {
        super(e), this.rackApi_ = t;
      }
    }
    function oe(n, e) {
      return n.addBlade(Object.assign(Object.assign({}, e), { view: "button" }));
    }
    function ke(n, e) {
      return n.addBlade(Object.assign(Object.assign({}, e), { view: "folder" }));
    }
    function mt(n, e) {
      const t = e != null ? e : {};
      return n.addBlade(Object.assign(Object.assign({}, t), { view: "separator" }));
    }
    function nn(n, e) {
      return n.addBlade(Object.assign(Object.assign({}, e), { view: "tab" }));
    }
    class ge {
      constructor(e) {
        this.emitter = new R(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e;
      }
      get items() {
        return this.items_;
      }
      allItems() {
        return Array.from(this.cache_);
      }
      find(e) {
        for (const t of this.allItems())
          if (e(t))
            return t;
        return null;
      }
      includes(e) {
        return this.cache_.has(e);
      }
      add(e, t) {
        if (this.includes(e))
          throw L.shouldNeverHappen();
        const i = t !== void 0 ? t : this.items_.length;
        this.items_.splice(i, 0, e), this.cache_.add(e);
        const c = this.extract_(e);
        c && (c.emitter.on("add", this.onSubListAdd_), c.emitter.on("remove", this.onSubListRemove_), c.allItems().forEach((_) => {
          this.cache_.add(_);
        })), this.emitter.emit("add", {
          index: i,
          item: e,
          root: this,
          target: this
        });
      }
      remove(e) {
        const t = this.items_.indexOf(e);
        if (t < 0)
          return;
        this.items_.splice(t, 1), this.cache_.delete(e);
        const i = this.extract_(e);
        i && (i.emitter.off("add", this.onSubListAdd_), i.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
          index: t,
          item: e,
          root: this,
          target: this
        });
      }
      onSubListAdd_(e) {
        this.cache_.add(e.item), this.emitter.emit("add", {
          index: e.index,
          item: e.item,
          root: this,
          target: e.target
        });
      }
      onSubListRemove_(e) {
        this.cache_.delete(e.item), this.emitter.emit("remove", {
          index: e.index,
          item: e.item,
          root: this,
          target: e.target
        });
      }
    }
    class we extends d {
      constructor(e) {
        super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new R(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingChange_(e) {
        const t = e.sender.target.read();
        this.emitter_.emit("change", {
          event: new h(this, t, this.controller_.binding.target.presetKey, e.options.last)
        });
      }
    }
    class Te extends Ve {
      constructor(e, t) {
        super(e, t), this.binding = t.binding;
      }
    }
    class nt extends d {
      constructor(e) {
        super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new R(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
      refresh() {
        this.controller_.binding.read();
      }
      onBindingUpdate_(e) {
        const t = e.sender.target.read();
        this.emitter_.emit("update", {
          event: new b(this, t, this.controller_.binding.target.presetKey)
        });
      }
    }
    class Xe extends Ve {
      constructor(e, t) {
        super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
          this.binding.dispose();
        });
      }
    }
    function Nt(n) {
      return n instanceof Ot ? n.apiSet_ : n instanceof G ? n.rackApi_.apiSet_ : null;
    }
    function It(n, e) {
      const t = n.find((i) => i.controller_ === e);
      if (!t)
        throw L.shouldNeverHappen();
      return t;
    }
    function sn(n, e, t) {
      if (!D.isBindable(n))
        throw L.notBindable();
      return new D(n, e, t);
    }
    class Ot extends d {
      constructor(e, t) {
        super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new R(), this.apiSet_ = new ge(Nt), this.pool_ = t;
        const i = this.controller_.rack;
        i.emitter.on("add", this.onRackAdd_), i.emitter.on("remove", this.onRackRemove_), i.emitter.on("inputchange", this.onRackInputChange_), i.emitter.on("monitorupdate", this.onRackMonitorUpdate_), i.children.forEach((c) => {
          this.setUpApi_(c);
        });
      }
      get children() {
        return this.controller_.rack.children.map((e) => It(this.apiSet_, e));
      }
      addInput(e, t, i) {
        const c = i != null ? i : {}, _ = this.controller_.view.element.ownerDocument, y = this.pool_.createInput(_, sn(e, t, c.presetKey), c), M = new we(y);
        return this.add(M, c.index);
      }
      addMonitor(e, t, i) {
        const c = i != null ? i : {}, _ = this.controller_.view.element.ownerDocument, y = this.pool_.createMonitor(_, sn(e, t), c), M = new nt(y);
        return this.add(M, c.index);
      }
      addFolder(e) {
        return ke(this, e);
      }
      addButton(e) {
        return oe(this, e);
      }
      addSeparator(e) {
        return mt(this, e);
      }
      addTab(e) {
        return nn(this, e);
      }
      add(e, t) {
        this.controller_.rack.add(e.controller_, t);
        const i = this.apiSet_.find((c) => c.controller_ === e.controller_);
        return i && this.apiSet_.remove(i), this.apiSet_.add(e), e;
      }
      remove(e) {
        this.controller_.rack.remove(e.controller_);
      }
      addBlade(e) {
        const t = this.controller_.view.element.ownerDocument, i = this.pool_.createBlade(t, e), c = this.pool_.createBladeApi(i);
        return this.add(c, e.index);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
      setUpApi_(e) {
        this.apiSet_.find((i) => i.controller_ === e) || this.apiSet_.add(this.pool_.createBladeApi(e));
      }
      onRackAdd_(e) {
        this.setUpApi_(e.bladeController);
      }
      onRackRemove_(e) {
        if (e.isRoot) {
          const t = It(this.apiSet_, e.bladeController);
          this.apiSet_.remove(t);
        }
      }
      onRackInputChange_(e) {
        const t = e.bladeController;
        if (t instanceof Te) {
          const i = It(this.apiSet_, t), c = t.binding;
          this.emitter_.emit("change", {
            event: new h(i, c.target.read(), c.target.presetKey, e.options.last)
          });
        } else if (t instanceof Pe) {
          const i = It(this.apiSet_, t);
          this.emitter_.emit("change", {
            event: new h(i, t.value.rawValue, void 0, e.options.last)
          });
        }
      }
      onRackMonitorUpdate_(e) {
        if (!(e.bladeController instanceof Xe))
          throw L.shouldNeverHappen();
        const t = It(this.apiSet_, e.bladeController), i = e.bladeController.binding;
        this.emitter_.emit("update", {
          event: new b(t, i.target.read(), i.target.presetKey)
        });
      }
    }
    class En extends G {
      constructor(e, t) {
        super(e, new Ot(e.rackController, t)), this.emitter_ = new R(), this.controller_.foldable.value("expanded").emitter.on("change", (i) => {
          this.emitter_.emit("fold", {
            event: new f(this, i.sender.rawValue)
          });
        }), this.rackApi_.on("change", (i) => {
          this.emitter_.emit("change", {
            event: i
          });
        }), this.rackApi_.on("update", (i) => {
          this.emitter_.emit("update", {
            event: i
          });
        });
      }
      get expanded() {
        return this.controller_.foldable.get("expanded");
      }
      set expanded(e) {
        this.controller_.foldable.set("expanded", e);
      }
      get title() {
        return this.controller_.props.get("title");
      }
      set title(e) {
        this.controller_.props.set("title", e);
      }
      get children() {
        return this.rackApi_.children;
      }
      addInput(e, t, i) {
        return this.rackApi_.addInput(e, t, i);
      }
      addMonitor(e, t, i) {
        return this.rackApi_.addMonitor(e, t, i);
      }
      addFolder(e) {
        return this.rackApi_.addFolder(e);
      }
      addButton(e) {
        return this.rackApi_.addButton(e);
      }
      addSeparator(e) {
        return this.rackApi_.addSeparator(e);
      }
      addTab(e) {
        return this.rackApi_.addTab(e);
      }
      add(e, t) {
        return this.rackApi_.add(e, t);
      }
      remove(e) {
        this.rackApi_.remove(e);
      }
      addBlade(e) {
        return this.rackApi_.addBlade(e);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
    }
    class Pn extends Ce {
      constructor(e) {
        super({
          blade: e.blade,
          view: e.view,
          viewProps: e.rackController.viewProps
        }), this.rackController = e.rackController;
      }
    }
    class Rs {
      constructor(e, t) {
        const i = I(t.viewName);
        this.element = e.createElement("div"), this.element.classList.add(i()), t.viewProps.bindClassModifiers(this.element);
      }
    }
    function Ns(n, e) {
      for (let t = 0; t < n.length; t++) {
        const i = n[t];
        if (i instanceof Te && i.binding === e)
          return i;
      }
      return null;
    }
    function Is(n, e) {
      for (let t = 0; t < n.length; t++) {
        const i = n[t];
        if (i instanceof Xe && i.binding === e)
          return i;
      }
      return null;
    }
    function Os(n, e) {
      for (let t = 0; t < n.length; t++) {
        const i = n[t];
        if (i instanceof Pe && i.value === e)
          return i;
      }
      return null;
    }
    function kn(n) {
      return n instanceof Dt ? n.rack : n instanceof Pn ? n.rackController.rack : null;
    }
    function Ds(n) {
      const e = kn(n);
      return e ? e.bcSet_ : null;
    }
    class Fs {
      constructor(e) {
        var t;
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new R(), this.blade_ = e != null ? e : null, (t = this.blade_) === null || t === void 0 || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new ge(Ds), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
      }
      get children() {
        return this.bcSet_.items;
      }
      add(e, t) {
        e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t);
      }
      remove(e) {
        e.parent_ = null, this.bcSet_.remove(e);
      }
      find(e) {
        return this.bcSet_.allItems().filter((t) => t instanceof e);
      }
      onSetAdd_(e) {
        this.updatePositions_();
        const t = e.target === e.root;
        if (this.emitter.emit("add", {
          bladeController: e.item,
          index: e.index,
          isRoot: t,
          sender: this
        }), !t)
          return;
        const i = e.item;
        if (i.viewProps.emitter.on("change", this.onChildViewPropsChange_), i.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), i.viewProps.handleDispose(this.onChildDispose_), i instanceof Te)
          i.binding.emitter.on("change", this.onChildInputChange_);
        else if (i instanceof Xe)
          i.binding.emitter.on("update", this.onChildMonitorUpdate_);
        else if (i instanceof Pe)
          i.value.emitter.on("change", this.onChildValueChange_);
        else {
          const c = kn(i);
          if (c) {
            const _ = c.emitter;
            _.on("layout", this.onDescendantLayout_), _.on("inputchange", this.onDescendantInputChange_), _.on("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      onSetRemove_(e) {
        this.updatePositions_();
        const t = e.target === e.root;
        if (this.emitter.emit("remove", {
          bladeController: e.item,
          isRoot: t,
          sender: this
        }), !t)
          return;
        const i = e.item;
        if (i instanceof Te)
          i.binding.emitter.off("change", this.onChildInputChange_);
        else if (i instanceof Xe)
          i.binding.emitter.off("update", this.onChildMonitorUpdate_);
        else if (i instanceof Pe)
          i.value.emitter.off("change", this.onChildValueChange_);
        else {
          const c = kn(i);
          if (c) {
            const _ = c.emitter;
            _.off("layout", this.onDescendantLayout_), _.off("inputchange", this.onDescendantInputChange_), _.off("monitorupdate", this.onDescendantMonitorUpdate_);
          }
        }
      }
      updatePositions_() {
        const e = this.bcSet_.items.filter((c) => !c.viewProps.get("hidden")), t = e[0], i = e[e.length - 1];
        this.bcSet_.items.forEach((c) => {
          const _ = [];
          c === t && (_.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && _.push("veryfirst")), c === i && (_.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && _.push("verylast")), c.blade.set("positions", _);
        });
      }
      onChildPositionsChange_() {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildViewPropsChange_(e) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onChildDispose_() {
        this.bcSet_.items.filter((t) => t.viewProps.get("disposed")).forEach((t) => {
          this.bcSet_.remove(t);
        });
      }
      onChildInputChange_(e) {
        const t = Ns(this.find(Te), e.sender);
        if (!t)
          throw L.shouldNeverHappen();
        this.emitter.emit("inputchange", {
          bladeController: t,
          options: e.options,
          sender: this
        });
      }
      onChildMonitorUpdate_(e) {
        const t = Is(this.find(Xe), e.sender);
        if (!t)
          throw L.shouldNeverHappen();
        this.emitter.emit("monitorupdate", {
          bladeController: t,
          sender: this
        });
      }
      onChildValueChange_(e) {
        const t = Os(this.find(Pe), e.sender);
        if (!t)
          throw L.shouldNeverHappen();
        this.emitter.emit("inputchange", {
          bladeController: t,
          options: e.options,
          sender: this
        });
      }
      onDescendantLayout_(e) {
        this.updatePositions_(), this.emitter.emit("layout", {
          sender: this
        });
      }
      onDescendantInputChange_(e) {
        this.emitter.emit("inputchange", {
          bladeController: e.bladeController,
          options: e.options,
          sender: this
        });
      }
      onDescendantMonitorUpdate_(e) {
        this.emitter.emit("monitorupdate", {
          bladeController: e.bladeController,
          sender: this
        });
      }
      onBladePositionsChange_() {
        this.updatePositions_();
      }
    }
    class Dt extends Ce {
      constructor(e, t) {
        super(Object.assign(Object.assign({}, t), { view: new Rs(e, {
          viewName: "brk",
          viewProps: t.viewProps
        }) })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
        const i = new Fs(t.root ? void 0 : t.blade);
        i.emitter.on("add", this.onRackAdd_), i.emitter.on("remove", this.onRackRemove_), this.rack = i, this.viewProps.handleDispose(() => {
          for (let c = this.rack.children.length - 1; c >= 0; c--)
            this.rack.children[c].viewProps.set("disposed", true);
        });
      }
      onRackAdd_(e) {
        !e.isRoot || tt(this.view.element, e.bladeController.view.element, e.index);
      }
      onRackRemove_(e) {
        !e.isRoot || qe(e.bladeController.view.element);
      }
    }
    const ns = I("cnt");
    class js {
      constructor(e, t) {
        var i;
        this.className_ = I((i = t.viewName) !== null && i !== void 0 ? i : "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), ns()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), Y(this.foldable_, "completed", J(this.element, this.className_(void 0, "cpl")));
        const c = e.createElement("button");
        c.classList.add(this.className_("b")), Y(t.props, "title", (F) => {
          g(F) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
        }), t.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c;
        const _ = e.createElement("div");
        _.classList.add(this.className_("t")), ne(t.props.value("title"), _), this.buttonElement.appendChild(_), this.titleElement = _;
        const y = e.createElement("div");
        y.classList.add(this.className_("m")), this.buttonElement.appendChild(y);
        const M = t.containerElement;
        M.classList.add(this.className_("c")), this.element.appendChild(M), this.containerElement = M;
      }
    }
    class Tn extends Pn {
      constructor(e, t) {
        var i;
        const c = Fe.create((i = t.expanded) !== null && i !== void 0 ? i : true), _ = new Dt(e, {
          blade: t.blade,
          root: t.root,
          viewProps: t.viewProps
        });
        super(Object.assign(Object.assign({}, t), { rackController: _, view: new js(e, {
          containerElement: _.view.element,
          foldable: c,
          props: t.props,
          viewName: t.root ? "rot" : void 0,
          viewProps: t.viewProps
        }) })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = c, B(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
          this.foldable.cleanUpTransition();
        }), this.rackController.rack.emitter.on("remove", () => {
          this.foldable.cleanUpTransition();
        }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
      }
      get document() {
        return this.view.element.ownerDocument;
      }
      onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"));
      }
    }
    const Bs = {
      id: "folder",
      type: "blade",
      accept(n) {
        const e = H, t = re2(n, {
          title: e.required.string,
          view: e.required.constant("folder"),
          expanded: e.optional.boolean
        });
        return t ? { params: t } : null;
      },
      controller(n) {
        return new Tn(n.document, {
          blade: n.blade,
          expanded: n.params.expanded,
          props: j.fromObject({
            title: n.params.title
          }),
          viewProps: n.viewProps
        });
      },
      api(n) {
        return n.controller instanceof Tn ? new En(n.controller, n.pool) : null;
      }
    };
    class vt extends Pe {
      constructor(e, t) {
        const i = t.valueController.viewProps;
        super(Object.assign(Object.assign({}, t), { value: t.valueController.value, view: new Rt(e, {
          props: t.props,
          viewProps: i
        }), viewProps: i })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class Mn extends d {
    }
    const ss = I("spr");
    class Us {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(ss()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("hr");
        i.classList.add(ss("r")), this.element.appendChild(i);
      }
    }
    class is extends Ce {
      constructor(e, t) {
        super(Object.assign(Object.assign({}, t), { view: new Us(e, {
          viewProps: t.viewProps
        }) }));
      }
    }
    const rs = {
      id: "separator",
      type: "blade",
      accept(n) {
        const t = re2(n, {
          view: H.required.constant("separator")
        });
        return t ? { params: t } : null;
      },
      controller(n) {
        return new is(n.document, {
          blade: n.blade,
          viewProps: n.viewProps
        });
      },
      api(n) {
        return n.controller instanceof is ? new Mn(n.controller) : null;
      }
    }, zs = I("");
    function Ft(n, e) {
      return J(n, zs(void 0, e));
    }
    class We extends j {
      constructor(e) {
        super(e);
      }
      static create(e) {
        var t, i;
        const c = e != null ? e : {}, _ = {
          disabled: (t = c.disabled) !== null && t !== void 0 ? t : false,
          disposed: false,
          hidden: (i = c.hidden) !== null && i !== void 0 ? i : false
        }, y = j.createCore(_);
        return new We(y);
      }
      bindClassModifiers(e) {
        Y(this, "disabled", Ft(e, "disabled")), Y(this, "hidden", Ft(e, "hidden"));
      }
      bindDisabled(e) {
        Y(this, "disabled", (t) => {
          e.disabled = t;
        });
      }
      bindTabIndex(e) {
        Y(this, "disabled", (t) => {
          e.tabIndex = t ? -1 : 0;
        });
      }
      handleDispose(e) {
        this.value("disposed").emitter.on("change", (t) => {
          t && e();
        });
      }
    }
    const ce = I("tbi");
    class Ks {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(ce()), t.viewProps.bindClassModifiers(this.element), Y(t.props, "selected", (_) => {
          _ ? this.element.classList.add(ce(void 0, "sel")) : this.element.classList.remove(ce(void 0, "sel"));
        });
        const i = e.createElement("button");
        i.classList.add(ce("b")), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.buttonElement = i;
        const c = e.createElement("div");
        c.classList.add(ce("t")), ne(t.props.value("title"), c), this.buttonElement.appendChild(c), this.titleElement = c;
      }
    }
    class rn {
      constructor(e, t) {
        this.emitter = new R(), this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new Ks(e, {
          props: t.props,
          viewProps: t.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class os {
      constructor(e, t) {
        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new rn(e, {
          props: t.itemProps,
          viewProps: We.create()
        }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Dt(e, {
          blade: De(),
          viewProps: We.create()
        }), this.props = t.props, Y(this.props, "selected", (i) => {
          this.itemController.props.set("selected", i), this.contentController.viewProps.set("hidden", !i);
        });
      }
      get itemController() {
        return this.ic_;
      }
      get contentController() {
        return this.cc_;
      }
      onItemClick_() {
        this.props.set("selected", true);
      }
    }
    class Ln {
      constructor(e, t) {
        this.controller_ = e, this.rackApi_ = t;
      }
      get title() {
        var e;
        return (e = this.controller_.itemController.props.get("title")) !== null && e !== void 0 ? e : "";
      }
      set title(e) {
        this.controller_.itemController.props.set("title", e);
      }
      get selected() {
        return this.controller_.props.get("selected");
      }
      set selected(e) {
        this.controller_.props.set("selected", e);
      }
      get children() {
        return this.rackApi_.children;
      }
      addButton(e) {
        return this.rackApi_.addButton(e);
      }
      addFolder(e) {
        return this.rackApi_.addFolder(e);
      }
      addSeparator(e) {
        return this.rackApi_.addSeparator(e);
      }
      addTab(e) {
        return this.rackApi_.addTab(e);
      }
      add(e, t) {
        this.rackApi_.add(e, t);
      }
      remove(e) {
        this.rackApi_.remove(e);
      }
      addInput(e, t, i) {
        return this.rackApi_.addInput(e, t, i);
      }
      addMonitor(e, t, i) {
        return this.rackApi_.addMonitor(e, t, i);
      }
      addBlade(e) {
        return this.rackApi_.addBlade(e);
      }
    }
    class as extends G {
      constructor(e, t) {
        super(e, new Ot(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new R(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (i) => {
          this.emitter_.emit("change", {
            event: i
          });
        }), this.rackApi_.on("update", (i) => {
          this.emitter_.emit("update", {
            event: i
          });
        }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((i) => {
          this.setUpPageApi_(i);
        });
      }
      get pages() {
        return this.controller_.pageSet.items.map((e) => {
          const t = this.pageApiMap_.get(e);
          if (!t)
            throw L.shouldNeverHappen();
          return t;
        });
      }
      addPage(e) {
        const t = this.controller_.view.element.ownerDocument, i = new os(t, {
          itemProps: j.fromObject({
            selected: false,
            title: e.title
          }),
          props: j.fromObject({
            selected: false
          })
        });
        this.controller_.add(i, e.index);
        const c = this.pageApiMap_.get(i);
        if (!c)
          throw L.shouldNeverHappen();
        return c;
      }
      removePage(e) {
        this.controller_.remove(e);
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
      setUpPageApi_(e) {
        const t = this.rackApi_.apiSet_.find((c) => c.controller_ === e.contentController);
        if (!t)
          throw L.shouldNeverHappen();
        const i = new Ln(e, t);
        this.pageApiMap_.set(e, i);
      }
      onPageAdd_(e) {
        this.setUpPageApi_(e.item);
      }
      onPageRemove_(e) {
        if (!this.pageApiMap_.get(e.item))
          throw L.shouldNeverHappen();
        this.pageApiMap_.delete(e.item);
      }
      onSelect_(e) {
        this.emitter_.emit("select", {
          event: new x(this, e.rawValue)
        });
      }
    }
    const ls = -1;
    class Hs {
      constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = X(true), this.selectedIndex = X(ls), this.items_ = [];
      }
      add(e, t) {
        const i = t != null ? t : this.items_.length;
        this.items_.splice(i, 0, e), e.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
      }
      remove(e) {
        const t = this.items_.indexOf(e);
        t < 0 || (this.items_.splice(t, 1), e.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
      }
      keepSelection_() {
        if (this.items_.length === 0) {
          this.selectedIndex.rawValue = ls, this.empty.rawValue = true;
          return;
        }
        const e = this.items_.findIndex((t) => t.rawValue);
        e < 0 ? (this.items_.forEach((t, i) => {
          t.rawValue = i === 0;
        }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((t, i) => {
          t.rawValue = i === e;
        }), this.selectedIndex.rawValue = e), this.empty.rawValue = false;
      }
      onItemSelectedChange_(e) {
        if (e.rawValue) {
          const t = this.items_.findIndex((i) => i === e.sender);
          this.items_.forEach((i, c) => {
            i.rawValue = c === t;
          }), this.selectedIndex.rawValue = t;
        } else
          this.keepSelection_();
      }
    }
    const jt = I("tab");
    class ft {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(jt(), ns()), t.viewProps.bindClassModifiers(this.element), te(t.empty, J(this.element, jt(void 0, "nop")));
        const i = e.createElement("div");
        i.classList.add(jt("i")), this.element.appendChild(i), this.itemsElement = i;
        const c = t.contentsElement;
        c.classList.add(jt("c")), this.element.appendChild(c), this.contentsElement = c;
      }
    }
    class Bt extends Pn {
      constructor(e, t) {
        const i = new Dt(e, {
          blade: t.blade,
          viewProps: t.viewProps
        }), c = new Hs();
        super({
          blade: t.blade,
          rackController: i,
          view: new ft(e, {
            contentsElement: i.view.element,
            empty: c.empty,
            viewProps: t.viewProps
          })
        }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new ge(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = c;
      }
      get pageSet() {
        return this.pageSet_;
      }
      add(e, t) {
        this.pageSet_.add(e, t);
      }
      remove(e) {
        this.pageSet_.remove(this.pageSet_.items[e]);
      }
      onPageAdd_(e) {
        const t = e.item;
        tt(this.view.itemsElement, t.itemController.view.element, e.index), this.rackController.rack.add(t.contentController, e.index), this.tab.add(t.props.value("selected"));
      }
      onPageRemove_(e) {
        const t = e.item;
        qe(t.itemController.view.element), this.rackController.rack.remove(t.contentController), this.tab.remove(t.props.value("selected"));
      }
    }
    const Sn = {
      id: "tab",
      type: "blade",
      accept(n) {
        const e = H, t = re2(n, {
          pages: e.required.array(e.required.object({ title: e.required.string })),
          view: e.required.constant("tab")
        });
        return !t || t.pages.length === 0 ? null : { params: t };
      },
      controller(n) {
        const e = new Bt(n.document, {
          blade: n.blade,
          viewProps: n.viewProps
        });
        return n.params.pages.forEach((t) => {
          const i = new os(n.document, {
            itemProps: j.fromObject({
              selected: false,
              title: t.title
            }),
            props: j.fromObject({
              selected: false
            })
          });
          e.add(i);
        }), e;
      },
      api(n) {
        return n.controller instanceof Bt ? new as(n.controller, n.pool) : null;
      }
    };
    function Gs(n, e) {
      const t = n.accept(e.params);
      if (!t)
        return null;
      const i = H.optional.boolean(e.params.disabled).value, c = H.optional.boolean(e.params.hidden).value;
      return n.controller({
        blade: De(),
        document: e.document,
        params: Object.assign(Object.assign({}, t.params), { disabled: i, hidden: c }),
        viewProps: We.create({
          disabled: i,
          hidden: c
        })
      });
    }
    class cs {
      constructor() {
        this.disabled = false, this.emitter = new R();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class An {
      constructor(e, t) {
        this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new R(), this.interval_ = t, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(e) {
        this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null)
          return;
        const e = this.doc_.defaultView;
        e && e.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const e = this.doc_.defaultView;
        e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class Ze {
      constructor(e) {
        this.constraints = e;
      }
      constrain(e) {
        return this.constraints.reduce((t, i) => i.constrain(t), e);
      }
    }
    function Q(n, e) {
      if (n instanceof e)
        return n;
      if (n instanceof Ze) {
        const t = n.constraints.reduce((i, c) => i || (c instanceof e ? c : null), null);
        if (t)
          return t;
      }
      return null;
    }
    class bt {
      constructor(e) {
        this.options = e;
      }
      constrain(e) {
        const t = this.options;
        return t.length === 0 || t.filter((c) => c.value === e).length > 0 ? e : t[0].value;
      }
    }
    class Se {
      constructor(e) {
        this.maxValue = e.max, this.minValue = e.min;
      }
      constrain(e) {
        let t = e;
        return g(this.minValue) || (t = Math.max(t, this.minValue)), g(this.maxValue) || (t = Math.min(t, this.maxValue)), t;
      }
    }
    class he {
      constructor(e, t = 0) {
        this.step = e, this.origin = t;
      }
      constrain(e) {
        const t = this.origin % this.step, i = Math.round((e - t) / this.step);
        return t + i * this.step;
      }
    }
    const Vn = I("lst");
    class $s {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(Vn()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("select");
        i.classList.add(Vn("s")), Y(this.props_, "options", (_) => {
          en(i), _.forEach((y, M) => {
            const F = e.createElement("option");
            F.dataset.index = String(M), F.textContent = y.text, F.value = String(y.value), i.appendChild(F);
          });
        }), t.viewProps.bindDisabled(i), this.element.appendChild(i), this.selectElement = i;
        const c = e.createElement("div");
        c.classList.add(Vn("m")), c.appendChild($e(e, "dropdown")), this.element.appendChild(c), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_();
      }
      update_() {
        this.selectElement.value = String(this.value_.rawValue);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class st {
      constructor(e, t) {
        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new $s(e, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
      }
      onSelectChange_(e) {
        const i = e.currentTarget.selectedOptions.item(0);
        if (!i)
          return;
        const c = Number(i.dataset.index);
        this.value.rawValue = this.props.get("options")[c].value;
      }
    }
    const ps = I("pop");
    class qs {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(ps()), t.viewProps.bindClassModifiers(this.element), te(t.shows, J(this.element, ps(void 0, "v")));
      }
    }
    class Rn {
      constructor(e, t) {
        this.shows = X(false), this.viewProps = t.viewProps, this.view = new qs(e, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      }
    }
    const us = I("txt");
    class on {
      constructor(e, t) {
        this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(us()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
        const i = e.createElement("input");
        i.classList.add(us("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh();
      }
      refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Ut {
      constructor(e, t) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new on(e, {
          props: t.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e) {
        const i = e.currentTarget.value, c = this.parser_(i);
        g(c) || (this.value.rawValue = c), this.view.refresh();
      }
    }
    function Ys(n) {
      return String(n);
    }
    function ds(n) {
      return n === "false" ? false : !!n;
    }
    function hs(n) {
      return Ys(n);
    }
    class Xs {
      constructor(e) {
        this.text = e;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const Ws = {
      "**": (n, e) => Math.pow(n, e),
      "*": (n, e) => n * e,
      "/": (n, e) => n / e,
      "%": (n, e) => n % e,
      "+": (n, e) => n + e,
      "-": (n, e) => n - e,
      "<<": (n, e) => n << e,
      ">>": (n, e) => n >> e,
      ">>>": (n, e) => n >>> e,
      "&": (n, e) => n & e,
      "^": (n, e) => n ^ e,
      "|": (n, e) => n | e
    };
    class Zs {
      constructor(e, t, i) {
        this.left = t, this.operator = e, this.right = i;
      }
      evaluate() {
        const e = Ws[this.operator];
        if (!e)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return e(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")"
        ].join(" ");
      }
    }
    const Qs = {
      "+": (n) => n,
      "-": (n) => -n,
      "~": (n) => ~n
    };
    class Js {
      constructor(e, t) {
        this.operator = e, this.expression = t;
      }
      evaluate() {
        const e = Qs[this.operator];
        if (!e)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return e(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function Nn(n) {
      return (e, t) => {
        for (let i = 0; i < n.length; i++) {
          const c = n[i](e, t);
          if (c !== "")
            return c;
        }
        return "";
      };
    }
    function zt(n, e) {
      var t;
      const i = n.substr(e).match(/^\s+/);
      return (t = i && i[0]) !== null && t !== void 0 ? t : "";
    }
    function ei(n, e) {
      const t = n.substr(e, 1);
      return t.match(/^[1-9]$/) ? t : "";
    }
    function Kt(n, e) {
      var t;
      const i = n.substr(e).match(/^[0-9]+/);
      return (t = i && i[0]) !== null && t !== void 0 ? t : "";
    }
    function ti(n, e) {
      const t = Kt(n, e);
      if (t !== "")
        return t;
      const i = n.substr(e, 1);
      if (e += 1, i !== "-" && i !== "+")
        return "";
      const c = Kt(n, e);
      return c === "" ? "" : i + c;
    }
    function an(n, e) {
      const t = n.substr(e, 1);
      if (e += 1, t.toLowerCase() !== "e")
        return "";
      const i = ti(n, e);
      return i === "" ? "" : t + i;
    }
    function ms(n, e) {
      const t = n.substr(e, 1);
      if (t === "0")
        return t;
      const i = ei(n, e);
      return e += i.length, i === "" ? "" : i + Kt(n, e);
    }
    function ni(n, e) {
      const t = ms(n, e);
      if (e += t.length, t === "")
        return "";
      const i = n.substr(e, 1);
      if (e += i.length, i !== ".")
        return "";
      const c = Kt(n, e);
      return e += c.length, t + i + c + an(n, e);
    }
    function In(n, e) {
      const t = n.substr(e, 1);
      if (e += t.length, t !== ".")
        return "";
      const i = Kt(n, e);
      return e += i.length, i === "" ? "" : t + i + an(n, e);
    }
    function si(n, e) {
      const t = ms(n, e);
      return e += t.length, t === "" ? "" : t + an(n, e);
    }
    const ii = Nn([
      ni,
      In,
      si
    ]);
    function ri(n, e) {
      var t;
      const i = n.substr(e).match(/^[01]+/);
      return (t = i && i[0]) !== null && t !== void 0 ? t : "";
    }
    function Qe(n, e) {
      const t = n.substr(e, 2);
      if (e += t.length, t.toLowerCase() !== "0b")
        return "";
      const i = ri(n, e);
      return i === "" ? "" : t + i;
    }
    function oi(n, e) {
      var t;
      const i = n.substr(e).match(/^[0-7]+/);
      return (t = i && i[0]) !== null && t !== void 0 ? t : "";
    }
    function ai(n, e) {
      const t = n.substr(e, 2);
      if (e += t.length, t.toLowerCase() !== "0o")
        return "";
      const i = oi(n, e);
      return i === "" ? "" : t + i;
    }
    function li(n, e) {
      var t;
      const i = n.substr(e).match(/^[0-9a-f]+/i);
      return (t = i && i[0]) !== null && t !== void 0 ? t : "";
    }
    function ci(n, e) {
      const t = n.substr(e, 2);
      if (e += t.length, t.toLowerCase() !== "0x")
        return "";
      const i = li(n, e);
      return i === "" ? "" : t + i;
    }
    const pi = Nn([
      Qe,
      ai,
      ci
    ]), vs = Nn([
      pi,
      ii
    ]);
    function ui(n, e) {
      const t = vs(n, e);
      return e += t.length, t === "" ? null : {
        evaluable: new Xs(t),
        cursor: e
      };
    }
    function di(n, e) {
      const t = n.substr(e, 1);
      if (e += t.length, t !== "(")
        return null;
      const i = je(n, e);
      if (!i)
        return null;
      e = i.cursor, e += zt(n, e).length;
      const c = n.substr(e, 1);
      return e += c.length, c !== ")" ? null : {
        evaluable: i.evaluable,
        cursor: e
      };
    }
    function Me(n, e) {
      var t;
      return (t = ui(n, e)) !== null && t !== void 0 ? t : di(n, e);
    }
    function fs(n, e) {
      const t = Me(n, e);
      if (t)
        return t;
      const i = n.substr(e, 1);
      if (e += i.length, i !== "+" && i !== "-" && i !== "~")
        return null;
      const c = fs(n, e);
      return c ? (e = c.cursor, {
        cursor: e,
        evaluable: new Js(i, c.evaluable)
      }) : null;
    }
    function hi(n, e, t) {
      t += zt(e, t).length;
      const i = n.filter((c) => e.startsWith(c, t))[0];
      return i ? (t += i.length, t += zt(e, t).length, {
        cursor: t,
        operator: i
      }) : null;
    }
    function On(n, e) {
      return (t, i) => {
        const c = n(t, i);
        if (!c)
          return null;
        i = c.cursor;
        let _ = c.evaluable;
        for (; ; ) {
          const y = hi(e, t, i);
          if (!y)
            break;
          i = y.cursor;
          const M = n(t, i);
          if (!M)
            return null;
          i = M.cursor, _ = new Zs(y.operator, _, M.evaluable);
        }
        return _ ? {
          cursor: i,
          evaluable: _
        } : null;
      };
    }
    const mi = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"]
    ].reduce((n, e) => On(n, e), fs);
    function je(n, e) {
      return e += zt(n, e).length, mi(n, e);
    }
    function bs(n) {
      const e = je(n, 0);
      return !e || e.cursor + zt(n, e.cursor).length !== n.length ? null : e.evaluable;
    }
    function Be(n) {
      var e;
      const t = bs(n);
      return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null;
    }
    function Dn(n) {
      if (typeof n == "number")
        return n;
      if (typeof n == "string") {
        const e = Be(n);
        if (!g(e))
          return e;
      }
      return 0;
    }
    function vi(n) {
      return String(n);
    }
    function se(n) {
      return (e) => e.toFixed(Math.max(Math.min(n, 20), 0));
    }
    const fi = se(0);
    function _t(n) {
      return fi(n) + "%";
    }
    function _s(n) {
      return String(n);
    }
    function ln(n) {
      return n;
    }
    function Ue(n, e) {
      for (; n.length < e; )
        n.push(void 0);
    }
    function bi(n) {
      const e = [];
      return Ue(e, n), X(e);
    }
    function _i(n) {
      const e = n.indexOf(void 0);
      return e < 0 ? n : n.slice(0, e);
    }
    function gs(n, e) {
      const t = [..._i(n), e];
      return t.length > n.length ? t.splice(0, t.length - n.length) : Ue(t, n.length), t;
    }
    function gt({ primary: n, secondary: e, forward: t, backward: i }) {
      let c = false;
      function _(y) {
        c || (c = true, y(), c = false);
      }
      n.emitter.on("change", (y) => {
        _(() => {
          e.setRawValue(t(n, e), y.options);
        });
      }), e.emitter.on("change", (y) => {
        _(() => {
          n.setRawValue(i(n, e), y.options);
        }), _(() => {
          e.setRawValue(t(n, e), y.options);
        });
      }), _(() => {
        e.setRawValue(t(n, e), {
          forceEmit: false,
          last: true
        });
      });
    }
    function me(n, e) {
      const t = n * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
      return e.upKey ? +t : e.downKey ? -t : 0;
    }
    function Re(n) {
      return {
        altKey: n.altKey,
        downKey: n.key === "ArrowDown",
        shiftKey: n.shiftKey,
        upKey: n.key === "ArrowUp"
      };
    }
    function ze(n) {
      return {
        altKey: n.altKey,
        downKey: n.key === "ArrowLeft",
        shiftKey: n.shiftKey,
        upKey: n.key === "ArrowRight"
      };
    }
    function Fn(n) {
      return n === "ArrowUp" || n === "ArrowDown";
    }
    function ws(n) {
      return Fn(n) || n === "ArrowLeft" || n === "ArrowRight";
    }
    function jn(n, e) {
      var t, i;
      const c = e.ownerDocument.defaultView, _ = e.getBoundingClientRect();
      return {
        x: n.pageX - (((t = c && c.scrollX) !== null && t !== void 0 ? t : 0) + _.left),
        y: n.pageY - (((i = c && c.scrollY) !== null && i !== void 0 ? i : 0) + _.top)
      };
    }
    class it {
      constructor(e) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new R(), e.addEventListener("touchstart", this.onTouchStart_, {
          passive: false
        }), e.addEventListener("touchmove", this.onTouchMove_, {
          passive: true
        }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(e) {
        const t = this.elem_.getBoundingClientRect();
        return {
          bounds: {
            width: t.width,
            height: t.height
          },
          point: e ? {
            x: e.x,
            y: e.y
          } : null
        };
      }
      onMouseDown_(e) {
        var t;
        e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
        const i = this.elem_.ownerDocument;
        i.addEventListener("mousemove", this.onDocumentMouseMove_), i.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
          altKey: e.altKey,
          data: this.computePosition_(jn(e, this.elem_)),
          sender: this,
          shiftKey: e.shiftKey
        });
      }
      onDocumentMouseMove_(e) {
        this.emitter.emit("move", {
          altKey: e.altKey,
          data: this.computePosition_(jn(e, this.elem_)),
          sender: this,
          shiftKey: e.shiftKey
        });
      }
      onDocumentMouseUp_(e) {
        const t = this.elem_.ownerDocument;
        t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
          altKey: e.altKey,
          data: this.computePosition_(jn(e, this.elem_)),
          sender: this,
          shiftKey: e.shiftKey
        });
      }
      onTouchStart_(e) {
        e.preventDefault();
        const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: e.altKey,
          data: this.computePosition_(t ? {
            x: t.clientX - i.left,
            y: t.clientY - i.top
          } : void 0),
          sender: this,
          shiftKey: e.shiftKey
        }), this.lastTouch_ = t;
      }
      onTouchMove_(e) {
        const t = e.targetTouches.item(0), i = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: e.altKey,
          data: this.computePosition_(t ? {
            x: t.clientX - i.left,
            y: t.clientY - i.top
          } : void 0),
          sender: this,
          shiftKey: e.shiftKey
        }), this.lastTouch_ = t;
      }
      onTouchEnd_(e) {
        var t;
        const i = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_, c = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: e.altKey,
          data: this.computePosition_(i ? {
            x: i.clientX - c.left,
            y: i.clientY - c.top
          } : void 0),
          sender: this,
          shiftKey: e.shiftKey
        });
      }
    }
    function ee(n, e, t, i, c) {
      const _ = (n - e) / (t - e);
      return i + _ * (c - i);
    }
    function xs(n) {
      return String(n.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function ae(n, e, t) {
      return Math.min(Math.max(n, e), t);
    }
    function ys(n, e) {
      return (n % e + e) % e;
    }
    const xe = I("txt");
    class gi {
      constructor(e, t) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(xe(), xe(void 0, "num")), t.arrayPosition && this.element.classList.add(xe(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("input");
        i.classList.add(xe("i")), i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(xe()), this.inputElement.classList.add(xe("i"));
        const c = e.createElement("div");
        c.classList.add(xe("k")), this.element.appendChild(c), this.knobElement = c;
        const _ = e.createElementNS(Ee, "svg");
        _.classList.add(xe("g")), this.knobElement.appendChild(_);
        const y = e.createElementNS(Ee, "path");
        y.classList.add(xe("gb")), _.appendChild(y), this.guideBodyElem_ = y;
        const M = e.createElementNS(Ee, "path");
        M.classList.add(xe("gh")), _.appendChild(M), this.guideHeadElem_ = M;
        const F = e.createElement("div");
        F.classList.add(I("tt")()), this.knobElement.appendChild(F), this.tooltipElem_ = F, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh();
      }
      onDraggingChange_(e) {
        if (e.rawValue === null) {
          this.element.classList.remove(xe(void 0, "drg"));
          return;
        }
        this.element.classList.add(xe(void 0, "drg"));
        const t = e.rawValue / this.props_.get("draggingScale"), i = t + (t > 0 ? -1 : t < 0 ? 1 : 0), c = ae(-i, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${i + c},0 L${i},4 L${i + c},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
        const _ = this.props_.get("formatter");
        this.tooltipElem_.textContent = _(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`;
      }
      refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class Ke {
      constructor(e, t) {
        var i;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.sliderProps_ = (i = t.sliderProps) !== null && i !== void 0 ? i : null, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = X(null), this.view = new gi(e, {
          arrayPosition: t.arrayPosition,
          dragging: this.dragging_,
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const c = new it(this.view.knobElement);
        c.emitter.on("down", this.onPointerDown_), c.emitter.on("move", this.onPointerMove_), c.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(e) {
        var t, i;
        const c = (t = this.sliderProps_) === null || t === void 0 ? void 0 : t.get("minValue"), _ = (i = this.sliderProps_) === null || i === void 0 ? void 0 : i.get("maxValue");
        let y = e;
        return c !== void 0 && (y = Math.max(y, c)), _ !== void 0 && (y = Math.min(y, _)), y;
      }
      onInputChange_(e) {
        const i = e.currentTarget.value, c = this.parser_(i);
        g(c) || (this.value.rawValue = this.constrainValue_(c)), this.view.refresh();
      }
      onInputKeyDown_(e) {
        const t = me(this.baseStep_, Re(e));
        t !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), {
          forceEmit: false,
          last: false
        });
      }
      onInputKeyUp_(e) {
        me(this.baseStep_, Re(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(e) {
        if (!e.point)
          return null;
        const t = e.point.x - e.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + t * this.props.get("draggingScale"));
      }
      onPointerMove_(e) {
        const t = this.computeDraggingValue_(e.data);
        t !== null && (this.value.setRawValue(t, {
          forceEmit: false,
          last: false
        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(e) {
        const t = this.computeDraggingValue_(e.data);
        t !== null && (this.value.setRawValue(t, {
          forceEmit: true,
          last: true
        }), this.dragging_.rawValue = null);
      }
    }
    const Bn = I("sld");
    class Cs {
      constructor(e, t) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Bn()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("div");
        i.classList.add(Bn("t")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.trackElement = i;
        const c = e.createElement("div");
        c.classList.add(Bn("k")), this.trackElement.appendChild(c), this.knobElement = c, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_();
      }
      update_() {
        const e = ae(ee(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
        this.knobElement.style.width = `${e}%`;
      }
      onChange_() {
        this.update_();
      }
    }
    class wi {
      constructor(e, t) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new Cs(e, {
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new it(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e, t) {
        !e.point || this.value.setRawValue(ee(ae(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t);
      }
      onPointerDownOrMove_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(e) {
        const t = me(this.baseStep_, ze(e));
        t !== 0 && this.value.setRawValue(this.value.rawValue + t, {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(e) {
        me(this.baseStep_, ze(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const Un = I("sldtxt");
    class Le {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(Un());
        const i = e.createElement("div");
        i.classList.add(Un("s")), this.sliderView_ = t.sliderView, i.appendChild(this.sliderView_.element), this.element.appendChild(i);
        const c = e.createElement("div");
        c.classList.add(Un("t")), this.textView_ = t.textView, c.appendChild(this.textView_.element), this.element.appendChild(c);
      }
    }
    class cn {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new wi(e, {
          baseStep: t.baseStep,
          props: t.sliderProps,
          value: t.value,
          viewProps: this.viewProps
        }), this.textC_ = new Ke(e, {
          baseStep: t.baseStep,
          parser: t.parser,
          props: t.textProps,
          sliderProps: t.sliderProps,
          value: t.value,
          viewProps: t.viewProps
        }), this.view = new Le(e, {
          sliderView: this.sliderC_.view,
          textView: this.textC_.view
        });
      }
      get sliderController() {
        return this.sliderC_;
      }
      get textController() {
        return this.textC_;
      }
    }
    function wt(n, e) {
      n.write(e);
    }
    function xt(n) {
      const e = H;
      if (Array.isArray(n))
        return e.required.array(e.required.object({
          text: e.required.string,
          value: e.required.raw
        }))(n).value;
      if (typeof n == "object")
        return e.required.raw(n).value;
    }
    function Es(n) {
      if (n === "inline" || n === "popup")
        return n;
    }
    function fe(n) {
      const e = H;
      return e.required.object({
        max: e.optional.number,
        min: e.optional.number,
        step: e.optional.number
      })(n).value;
    }
    function Ps(n) {
      if (Array.isArray(n))
        return n;
      const e = [];
      return Object.keys(n).forEach((t) => {
        e.push({ text: t, value: n[t] });
      }), e;
    }
    function zn(n) {
      return g(n) ? null : new bt(Ps(n));
    }
    function Kn(n) {
      const e = n ? Q(n, bt) : null;
      return e ? e.options : null;
    }
    function xi(n) {
      const e = n ? Q(n, he) : null;
      return e ? e.step : null;
    }
    function pn(n, e) {
      const t = n && Q(n, he);
      return t ? xs(t.step) : Math.max(xs(e), 2);
    }
    function yt(n) {
      const e = xi(n);
      return e != null ? e : 1;
    }
    function Ct(n, e) {
      var t;
      const i = n && Q(n, he), c = Math.abs((t = i == null ? void 0 : i.step) !== null && t !== void 0 ? t : e);
      return c === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(c)) - 1);
    }
    const un = I("ckb");
    class yi {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(un()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("label");
        i.classList.add(un("l")), this.element.appendChild(i);
        const c = e.createElement("input");
        c.classList.add(un("i")), c.type = "checkbox", i.appendChild(c), this.inputElement = c, t.viewProps.bindDisabled(this.inputElement);
        const _ = e.createElement("div");
        _.classList.add(un("w")), i.appendChild(_);
        const y = $e(e, "check");
        _.appendChild(y), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
      }
      update_() {
        this.inputElement.checked = this.value.rawValue;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Ci {
      constructor(e, t) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new yi(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(e) {
        const t = e.currentTarget;
        this.value.rawValue = t.checked;
      }
    }
    function Ht(n) {
      const e = [], t = zn(n.options);
      return t && e.push(t), new Ze(e);
    }
    const Ei = {
      id: "input-bool",
      type: "input",
      accept: (n, e) => {
        if (typeof n != "boolean")
          return null;
        const i = re2(e, {
          options: H.optional.custom(xt)
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => ds,
        constraint: (n) => Ht(n.params),
        writer: (n) => wt
      },
      controller: (n) => {
        var e;
        const t = n.document, i = n.value, c = n.constraint;
        return c && Q(c, bt) ? new st(t, {
          props: j.fromObject({
            options: (e = Kn(c)) !== null && e !== void 0 ? e : []
          }),
          value: i,
          viewProps: n.viewProps
        }) : new Ci(t, {
          value: i,
          viewProps: n.viewProps
        });
      }
    }, rt = I("col");
    class Hn {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(rt()), t.foldable.bindExpandedClass(this.element, rt(void 0, "expanded")), Y(t.foldable, "completed", J(this.element, rt(void 0, "cpl")));
        const i = e.createElement("div");
        i.classList.add(rt("h")), this.element.appendChild(i);
        const c = e.createElement("div");
        c.classList.add(rt("s")), i.appendChild(c), this.swatchElement = c;
        const _ = e.createElement("div");
        if (_.classList.add(rt("t")), i.appendChild(_), this.textElement = _, t.pickerLayout === "inline") {
          const y = e.createElement("div");
          y.classList.add(rt("p")), this.element.appendChild(y), this.pickerElement = y;
        } else
          this.pickerElement = null;
      }
    }
    function Pi(n, e, t) {
      const i = ae(n / 255, 0, 1), c = ae(e / 255, 0, 1), _ = ae(t / 255, 0, 1), y = Math.max(i, c, _), M = Math.min(i, c, _), F = y - M;
      let U = 0, W = 0;
      const Z = (M + y) / 2;
      return F !== 0 && (W = F / (1 - Math.abs(y + M - 1)), i === y ? U = (c - _) / F : c === y ? U = 2 + (_ - i) / F : U = 4 + (i - c) / F, U = U / 6 + (U < 0 ? 1 : 0)), [U * 360, W * 100, Z * 100];
    }
    function Gn(n, e, t) {
      const i = (n % 360 + 360) % 360, c = ae(e / 100, 0, 1), _ = ae(t / 100, 0, 1), y = (1 - Math.abs(2 * _ - 1)) * c, M = y * (1 - Math.abs(i / 60 % 2 - 1)), F = _ - y / 2;
      let U, W, Z;
      return i >= 0 && i < 60 ? [U, W, Z] = [y, M, 0] : i >= 60 && i < 120 ? [U, W, Z] = [M, y, 0] : i >= 120 && i < 180 ? [U, W, Z] = [0, y, M] : i >= 180 && i < 240 ? [U, W, Z] = [0, M, y] : i >= 240 && i < 300 ? [U, W, Z] = [M, 0, y] : [U, W, Z] = [y, 0, M], [(U + F) * 255, (W + F) * 255, (Z + F) * 255];
    }
    function ki(n, e, t) {
      const i = ae(n / 255, 0, 1), c = ae(e / 255, 0, 1), _ = ae(t / 255, 0, 1), y = Math.max(i, c, _), M = Math.min(i, c, _), F = y - M;
      let U;
      F === 0 ? U = 0 : y === i ? U = 60 * (((c - _) / F % 6 + 6) % 6) : y === c ? U = 60 * ((_ - i) / F + 2) : U = 60 * ((i - c) / F + 4);
      const W = y === 0 ? 0 : F / y, Z = y;
      return [U, W * 100, Z * 100];
    }
    function ks(n, e, t) {
      const i = ys(n, 360), c = ae(e / 100, 0, 1), _ = ae(t / 100, 0, 1), y = _ * c, M = y * (1 - Math.abs(i / 60 % 2 - 1)), F = _ - y;
      let U, W, Z;
      return i >= 0 && i < 60 ? [U, W, Z] = [y, M, 0] : i >= 60 && i < 120 ? [U, W, Z] = [M, y, 0] : i >= 120 && i < 180 ? [U, W, Z] = [0, y, M] : i >= 180 && i < 240 ? [U, W, Z] = [0, M, y] : i >= 240 && i < 300 ? [U, W, Z] = [M, 0, y] : [U, W, Z] = [y, 0, M], [(U + F) * 255, (W + F) * 255, (Z + F) * 255];
    }
    function Ti(n, e, t) {
      const i = t + e * (100 - Math.abs(2 * t - 100)) / 200;
      return [
        n,
        i !== 0 ? e * (100 - Math.abs(2 * t - 100)) / i : 0,
        t + e * (100 - Math.abs(2 * t - 100)) / (2 * 100)
      ];
    }
    function Mi(n, e, t) {
      const i = 100 - Math.abs(t * (200 - e) / 100 - 100);
      return [n, i !== 0 ? e * t / i : 0, t * (200 - e) / (2 * 100)];
    }
    function o(n) {
      return [n[0], n[1], n[2]];
    }
    function s(n, e) {
      return [n[0], n[1], n[2], e];
    }
    const r = {
      hsl: {
        hsl: (n, e, t) => [n, e, t],
        hsv: Ti,
        rgb: Gn
      },
      hsv: {
        hsl: Mi,
        hsv: (n, e, t) => [n, e, t],
        rgb: ks
      },
      rgb: {
        hsl: Pi,
        hsv: ki,
        rgb: (n, e, t) => [n, e, t]
      }
    };
    function l(n, e) {
      return [
        e === "float" ? 1 : n === "rgb" ? 255 : 360,
        e === "float" ? 1 : n === "rgb" ? 255 : 100,
        e === "float" ? 1 : n === "rgb" ? 255 : 100
      ];
    }
    function v(n, e, t) {
      var i;
      const c = l(e, t);
      return [
        e === "rgb" ? ae(n[0], 0, c[0]) : ys(n[0], c[0]),
        ae(n[1], 0, c[1]),
        ae(n[2], 0, c[2]),
        ae((i = n[3]) !== null && i !== void 0 ? i : 1, 0, 1)
      ];
    }
    function w(n, e, t, i) {
      const c = l(e, t), _ = l(e, i);
      return n.map((y, M) => y / c[M] * _[M]);
    }
    function P(n, e, t) {
      const i = w(n, e.mode, e.type, "int"), c = r[e.mode][t.mode](...i);
      return w(c, t.mode, "int", t.type);
    }
    function A(n, e) {
      return typeof n != "object" || g(n) ? false : e in n && typeof n[e] == "number";
    }
    class O {
      constructor(e, t, i = "int") {
        this.mode = t, this.type = i, this.comps_ = v(e, t, i);
      }
      static black(e = "int") {
        return new O([0, 0, 0], "rgb", e);
      }
      static fromObject(e, t = "int") {
        const i = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
        return new O(i, "rgb", t);
      }
      static toRgbaObject(e, t = "int") {
        return e.toRgbaObject(t);
      }
      static isRgbColorObject(e) {
        return A(e, "r") && A(e, "g") && A(e, "b");
      }
      static isRgbaColorObject(e) {
        return this.isRgbColorObject(e) && A(e, "a");
      }
      static isColorObject(e) {
        return this.isRgbColorObject(e);
      }
      static equals(e, t) {
        if (e.mode !== t.mode)
          return false;
        const i = e.comps_, c = t.comps_;
        for (let _ = 0; _ < i.length; _++)
          if (i[_] !== c[_])
            return false;
        return true;
      }
      getComponents(e, t = "int") {
        return s(P(o(this.comps_), { mode: this.mode, type: this.type }, { mode: e != null ? e : this.mode, type: t }), this.comps_[3]);
      }
      toRgbaObject(e = "int") {
        const t = this.getComponents("rgb", e);
        return {
          r: t[0],
          g: t[1],
          b: t[2],
          a: t[3]
        };
      }
    }
    const le = I("colp");
    class He {
      constructor(e, t) {
        this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(le());
        const i = e.createElement("div");
        i.classList.add(le("hsv"));
        const c = e.createElement("div");
        c.classList.add(le("sv")), this.svPaletteView_ = t.svPaletteView, c.appendChild(this.svPaletteView_.element), i.appendChild(c);
        const _ = e.createElement("div");
        _.classList.add(le("h")), this.hPaletteView_ = t.hPaletteView, _.appendChild(this.hPaletteView_.element), i.appendChild(_), this.element.appendChild(i);
        const y = e.createElement("div");
        if (y.classList.add(le("rgb")), this.textView_ = t.textView, y.appendChild(this.textView_.element), this.element.appendChild(y), t.alphaViews) {
          this.alphaViews_ = {
            palette: t.alphaViews.palette,
            text: t.alphaViews.text
          };
          const M = e.createElement("div");
          M.classList.add(le("a"));
          const F = e.createElement("div");
          F.classList.add(le("ap")), F.appendChild(this.alphaViews_.palette.element), M.appendChild(F);
          const U = e.createElement("div");
          U.classList.add(le("at")), U.appendChild(this.alphaViews_.text.element), M.appendChild(U), this.element.appendChild(M);
        }
      }
      get allFocusableElements() {
        const e = [
          this.svPaletteView_.element,
          this.hPaletteView_.element,
          this.textView_.modeSelectElement,
          ...this.textView_.textViews.map((t) => t.inputElement)
        ];
        return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
      }
    }
    function $n(n) {
      return n === "int" ? "int" : n === "float" ? "float" : void 0;
    }
    function qn(n) {
      const e = H;
      return re2(n, {
        alpha: e.optional.boolean,
        color: e.optional.object({
          alpha: e.optional.boolean,
          type: e.optional.custom($n)
        }),
        expanded: e.optional.boolean,
        picker: e.optional.custom(Es)
      });
    }
    function ot(n) {
      return n ? 0.1 : 1;
    }
    function Gt(n) {
      var e;
      return (e = n.color) === null || e === void 0 ? void 0 : e.type;
    }
    function uo(n, e) {
      return n.alpha === e.alpha && n.mode === e.mode && n.notation === e.notation && n.type === e.type;
    }
    function Ne(n, e) {
      const t = n.match(/^(.+)%$/);
      return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(n), e);
    }
    const ho = {
      deg: (n) => n,
      grad: (n) => n * 360 / 400,
      rad: (n) => n * 360 / (2 * Math.PI),
      turn: (n) => n * 360
    };
    function sr(n) {
      const e = n.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
      if (!e)
        return parseFloat(n);
      const t = parseFloat(e[1]), i = e[2];
      return ho[i](t);
    }
    function ir(n) {
      const e = n.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!e)
        return null;
      const t = [
        Ne(e[1], 255),
        Ne(e[2], 255),
        Ne(e[3], 255)
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
    }
    function rr(n) {
      return (e) => {
        const t = ir(e);
        return t ? new O(t, "rgb", n) : null;
      };
    }
    function or(n) {
      const e = n.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!e)
        return null;
      const t = [
        Ne(e[1], 255),
        Ne(e[2], 255),
        Ne(e[3], 255),
        Ne(e[4], 1)
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
    }
    function ar(n) {
      return (e) => {
        const t = or(e);
        return t ? new O(t, "rgb", n) : null;
      };
    }
    function lr(n) {
      const e = n.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!e)
        return null;
      const t = [
        sr(e[1]),
        Ne(e[2], 100),
        Ne(e[3], 100)
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
    }
    function cr(n) {
      return (e) => {
        const t = lr(e);
        return t ? new O(t, "hsl", n) : null;
      };
    }
    function pr(n) {
      const e = n.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
      if (!e)
        return null;
      const t = [
        sr(e[1]),
        Ne(e[2], 100),
        Ne(e[3], 100),
        Ne(e[4], 1)
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
    }
    function ur(n) {
      return (e) => {
        const t = pr(e);
        return t ? new O(t, "hsl", n) : null;
      };
    }
    function dr(n) {
      const e = n.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (e)
        return [
          parseInt(e[1] + e[1], 16),
          parseInt(e[2] + e[2], 16),
          parseInt(e[3] + e[3], 16)
        ];
      const t = n.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return t ? [
        parseInt(t[1], 16),
        parseInt(t[2], 16),
        parseInt(t[3], 16)
      ] : null;
    }
    function mo(n) {
      const e = dr(n);
      return e ? new O(e, "rgb", "int") : null;
    }
    function hr(n) {
      const e = n.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
      if (e)
        return [
          parseInt(e[1] + e[1], 16),
          parseInt(e[2] + e[2], 16),
          parseInt(e[3] + e[3], 16),
          ee(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)
        ];
      const t = n.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
      return t ? [
        parseInt(t[1], 16),
        parseInt(t[2], 16),
        parseInt(t[3], 16),
        ee(parseInt(t[4], 16), 0, 255, 0, 1)
      ] : null;
    }
    function vo(n) {
      const e = hr(n);
      return e ? new O(e, "rgb", "int") : null;
    }
    function mr(n) {
      const e = n.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!e)
        return null;
      const t = [
        parseFloat(e[1]),
        parseFloat(e[2]),
        parseFloat(e[3])
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
    }
    function vr(n) {
      return (e) => {
        const t = mr(e);
        return t ? new O(t, "rgb", n) : null;
      };
    }
    function fr(n) {
      const e = n.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
      if (!e)
        return null;
      const t = [
        parseFloat(e[1]),
        parseFloat(e[2]),
        parseFloat(e[3]),
        parseFloat(e[4])
      ];
      return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
    }
    function br(n) {
      return (e) => {
        const t = fr(e);
        return t ? new O(t, "rgb", n) : null;
      };
    }
    const fo = [
      {
        parser: dr,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: hr,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "hex"
        }
      },
      {
        parser: ir,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: or,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "func"
        }
      },
      {
        parser: lr,
        result: {
          alpha: false,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: pr,
        result: {
          alpha: true,
          mode: "hsl",
          notation: "func"
        }
      },
      {
        parser: mr,
        result: {
          alpha: false,
          mode: "rgb",
          notation: "object"
        }
      },
      {
        parser: fr,
        result: {
          alpha: true,
          mode: "rgb",
          notation: "object"
        }
      }
    ];
    function bo(n) {
      return fo.reduce((e, { parser: t, result: i }) => e || (t(n) ? i : null), null);
    }
    function Li(n, e = "int") {
      const t = bo(n);
      return t ? t.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, t), { type: "int" }) : t.notation === "func" ? Object.assign(Object.assign({}, t), { type: e }) : null : null;
    }
    const _r = {
      int: [
        mo,
        vo,
        rr("int"),
        ar("int"),
        cr("int"),
        ur("int"),
        vr("int"),
        br("int")
      ],
      float: [
        rr("float"),
        ar("float"),
        cr("float"),
        ur("float"),
        vr("float"),
        br("float")
      ]
    };
    function _o(n) {
      const e = _r[n];
      return (t) => {
        if (typeof t != "string")
          return O.black(n);
        const i = e.reduce((c, _) => c || _(t), null);
        return i != null ? i : O.black(n);
      };
    }
    function Si(n) {
      const e = _r[n];
      return (t) => e.reduce((i, c) => i || c(t), null);
    }
    function gr(n) {
      const e = ae(Math.floor(n), 0, 255).toString(16);
      return e.length === 1 ? `0${e}` : e;
    }
    function wr(n, e = "#") {
      const t = o(n.getComponents("rgb")).map(gr).join("");
      return `${e}${t}`;
    }
    function Ai(n, e = "#") {
      const t = n.getComponents("rgb"), i = [t[0], t[1], t[2], t[3] * 255].map(gr).join("");
      return `${e}${i}`;
    }
    function xr(n, e) {
      const t = se(e === "float" ? 2 : 0);
      return `rgb(${o(n.getComponents("rgb", e)).map((c) => t(c)).join(", ")})`;
    }
    function go(n) {
      return (e) => xr(e, n);
    }
    function Ts(n, e) {
      const t = se(2), i = se(e === "float" ? 2 : 0);
      return `rgba(${n.getComponents("rgb", e).map((_, y) => (y === 3 ? t : i)(_)).join(", ")})`;
    }
    function wo(n) {
      return (e) => Ts(e, n);
    }
    function xo(n) {
      const e = [
        se(0),
        _t,
        _t
      ];
      return `hsl(${o(n.getComponents("hsl")).map((i, c) => e[c](i)).join(", ")})`;
    }
    function yo(n) {
      const e = [
        se(0),
        _t,
        _t,
        se(2)
      ];
      return `hsla(${n.getComponents("hsl").map((i, c) => e[c](i)).join(", ")})`;
    }
    function yr(n, e) {
      const t = se(e === "float" ? 2 : 0), i = ["r", "g", "b"];
      return `{${o(n.getComponents("rgb", e)).map((_, y) => `${i[y]}: ${t(_)}`).join(", ")}}`;
    }
    function Co(n) {
      return (e) => yr(e, n);
    }
    function Cr(n, e) {
      const t = se(2), i = se(e === "float" ? 2 : 0), c = ["r", "g", "b", "a"];
      return `{${n.getComponents("rgb", e).map((y, M) => {
        const F = M === 3 ? t : i;
        return `${c[M]}: ${F(y)}`;
      }).join(", ")}}`;
    }
    function Eo(n) {
      return (e) => Cr(e, n);
    }
    const Po = [
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: wr
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "hex",
          type: "int"
        },
        stringifier: Ai
      },
      {
        format: {
          alpha: false,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: xo
      },
      {
        format: {
          alpha: true,
          mode: "hsl",
          notation: "func",
          type: "int"
        },
        stringifier: yo
      },
      ...["int", "float"].reduce((n, e) => [
        ...n,
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "func",
            type: e
          },
          stringifier: go(e)
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "func",
            type: e
          },
          stringifier: wo(e)
        },
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "object",
            type: e
          },
          stringifier: Co(e)
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "object",
            type: e
          },
          stringifier: Eo(e)
        }
      ], [])
    ];
    function Vi(n) {
      return Po.reduce((e, t) => e || (uo(t.format, n) ? t.stringifier : null), null);
    }
    const Yn = I("apl");
    class ko {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Yn()), t.viewProps.bindTabIndex(this.element);
        const i = e.createElement("div");
        i.classList.add(Yn("b")), this.element.appendChild(i);
        const c = e.createElement("div");
        c.classList.add(Yn("c")), i.appendChild(c), this.colorElem_ = c;
        const _ = e.createElement("div");
        _.classList.add(Yn("m")), this.element.appendChild(_), this.markerElem_ = _;
        const y = e.createElement("div");
        y.classList.add(Yn("p")), this.markerElem_.appendChild(y), this.previewElem_ = y, this.update_();
      }
      update_() {
        const e = this.value.rawValue, t = e.getComponents("rgb"), i = new O([t[0], t[1], t[2], 0], "rgb"), c = new O([t[0], t[1], t[2], 255], "rgb"), _ = [
          "to right",
          Ts(i),
          Ts(c)
        ];
        this.colorElem_.style.background = `linear-gradient(${_.join(",")})`, this.previewElem_.style.backgroundColor = Ts(e);
        const y = ee(t[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${y}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class To {
      constructor(e, t) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new ko(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new it(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e, t) {
        if (!e.point)
          return;
        const i = e.point.x / e.bounds.width, c = this.value.rawValue, [_, y, M] = c.getComponents("hsv");
        this.value.setRawValue(new O([_, y, M, i], "hsv"), t);
      }
      onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(e) {
        const t = me(ot(true), ze(e));
        if (t === 0)
          return;
        const i = this.value.rawValue, [c, _, y, M] = i.getComponents("hsv");
        this.value.setRawValue(new O([c, _, y, M + t], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(e) {
        me(ot(true), ze(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const dn = I("coltxt");
    function Mo(n) {
      const e = n.createElement("select"), t = [
        { text: "RGB", value: "rgb" },
        { text: "HSL", value: "hsl" },
        { text: "HSV", value: "hsv" }
      ];
      return e.appendChild(t.reduce((i, c) => {
        const _ = n.createElement("option");
        return _.textContent = c.text, _.value = c.value, i.appendChild(_), i;
      }, n.createDocumentFragment())), e;
    }
    class Lo {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(dn());
        const i = e.createElement("div");
        i.classList.add(dn("m")), this.modeElem_ = Mo(e), this.modeElem_.classList.add(dn("ms")), i.appendChild(this.modeSelectElement);
        const c = e.createElement("div");
        c.classList.add(dn("mm")), c.appendChild($e(e, "dropdown")), i.appendChild(c), this.element.appendChild(i);
        const _ = e.createElement("div");
        _.classList.add(dn("w")), this.element.appendChild(_), this.textsElem_ = _, this.textViews_ = t.textViews, this.applyTextViews_(), te(t.colorMode, (y) => {
          this.modeElem_.value = y;
        });
      }
      get modeSelectElement() {
        return this.modeElem_;
      }
      get textViews() {
        return this.textViews_;
      }
      set textViews(e) {
        this.textViews_ = e, this.applyTextViews_();
      }
      applyTextViews_() {
        en(this.textsElem_);
        const e = this.element.ownerDocument;
        this.textViews_.forEach((t) => {
          const i = e.createElement("div");
          i.classList.add(dn("c")), i.appendChild(t.element), this.textsElem_.appendChild(i);
        });
      }
    }
    function So(n) {
      return se(n === "float" ? 2 : 0);
    }
    function Ao(n, e, t) {
      const i = l(n, e)[t];
      return new Se({
        min: 0,
        max: i
      });
    }
    function Ri(n, e, t) {
      return new Ke(n, {
        arrayPosition: t === 0 ? "fst" : t === 3 - 1 ? "lst" : "mid",
        baseStep: ot(false),
        parser: e.parser,
        props: j.fromObject({
          draggingScale: e.colorType === "float" ? 0.01 : 1,
          formatter: So(e.colorType)
        }),
        value: X(0, {
          constraint: Ao(e.colorMode, e.colorType, t)
        }),
        viewProps: e.viewProps
      });
    }
    class Vo {
      constructor(e, t) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = t.colorType, this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = X(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new Lo(e, {
          colorMode: this.colorMode,
          textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
      }
      createComponentControllers_(e) {
        const t = {
          colorMode: this.colorMode.rawValue,
          colorType: this.colorType_,
          parser: this.parser_,
          viewProps: this.viewProps
        }, i = [
          Ri(e, t, 0),
          Ri(e, t, 1),
          Ri(e, t, 2)
        ];
        return i.forEach((c, _) => {
          gt({
            primary: this.value,
            secondary: c.value,
            forward: (y) => y.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[_],
            backward: (y, M) => {
              const F = this.colorMode.rawValue, U = y.rawValue.getComponents(F, this.colorType_);
              return U[_] = M.rawValue, new O(s(o(U), U[3]), F, this.colorType_);
            }
          });
        }), i;
      }
      onModeSelectChange_(e) {
        const t = e.currentTarget;
        this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [
          this.ccs_[0].view,
          this.ccs_[1].view,
          this.ccs_[2].view
        ];
      }
    }
    const Ni = I("hpl");
    class Ro {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Ni()), t.viewProps.bindTabIndex(this.element);
        const i = e.createElement("div");
        i.classList.add(Ni("c")), this.element.appendChild(i);
        const c = e.createElement("div");
        c.classList.add(Ni("m")), this.element.appendChild(c), this.markerElem_ = c, this.update_();
      }
      update_() {
        const e = this.value.rawValue, [t] = e.getComponents("hsv");
        this.markerElem_.style.backgroundColor = xr(new O([t, 100, 100], "hsv"));
        const i = ee(t, 0, 360, 0, 100);
        this.markerElem_.style.left = `${i}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class No {
      constructor(e, t) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Ro(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new it(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e, t) {
        if (!e.point)
          return;
        const i = ee(ae(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 359), c = this.value.rawValue, [, _, y, M] = c.getComponents("hsv");
        this.value.setRawValue(new O([i, _, y, M], "hsv"), t);
      }
      onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(e) {
        const t = me(ot(false), ze(e));
        if (t === 0)
          return;
        const i = this.value.rawValue, [c, _, y, M] = i.getComponents("hsv");
        this.value.setRawValue(new O([c + t, _, y, M], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(e) {
        me(ot(false), ze(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    const Ii = I("svp"), Er = 64;
    class Io {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Ii()), t.viewProps.bindTabIndex(this.element);
        const i = e.createElement("canvas");
        i.height = Er, i.width = Er, i.classList.add(Ii("c")), this.element.appendChild(i), this.canvasElement = i;
        const c = e.createElement("div");
        c.classList.add(Ii("m")), this.element.appendChild(c), this.markerElem_ = c, this.update_();
      }
      update_() {
        const e = yn(this.canvasElement);
        if (!e)
          return;
        const i = this.value.rawValue.getComponents("hsv"), c = this.canvasElement.width, _ = this.canvasElement.height, y = e.getImageData(0, 0, c, _), M = y.data;
        for (let W = 0; W < _; W++)
          for (let Z = 0; Z < c; Z++) {
            const lt = ee(Z, 0, c, 0, 100), Wn = ee(W, 0, _, 100, 0), Zn = ks(i[0], lt, Wn), fn = (W * c + Z) * 4;
            M[fn] = Zn[0], M[fn + 1] = Zn[1], M[fn + 2] = Zn[2], M[fn + 3] = 255;
          }
        e.putImageData(y, 0, 0);
        const F = ee(i[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${F}%`;
        const U = ee(i[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${U}%`;
      }
      onValueChange_() {
        this.update_();
      }
    }
    class Oo {
      constructor(e, t) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Io(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new it(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
      }
      handlePointerEvent_(e, t) {
        if (!e.point)
          return;
        const i = ee(e.point.x, 0, e.bounds.width, 0, 100), c = ee(e.point.y, 0, e.bounds.height, 100, 0), [_, , , y] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new O([_, i, c, y], "hsv"), t);
      }
      onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(e) {
        ws(e.key) && e.preventDefault();
        const [t, i, c, _] = this.value.rawValue.getComponents("hsv"), y = ot(false), M = me(y, ze(e)), F = me(y, Re(e));
        M === 0 && F === 0 || this.value.setRawValue(new O([t, i + M, c + F, _], "hsv"), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(e) {
        const t = ot(false), i = me(t, ze(e)), c = me(t, Re(e));
        i === 0 && c === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    class Do {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new No(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.svPaletteC_ = new Oo(e, {
          value: this.value,
          viewProps: this.viewProps
        }), this.alphaIcs_ = t.supportsAlpha ? {
          palette: new To(e, {
            value: this.value,
            viewProps: this.viewProps
          }),
          text: new Ke(e, {
            parser: Be,
            baseStep: 0.1,
            props: j.fromObject({
              draggingScale: 0.01,
              formatter: se(2)
            }),
            value: X(0, {
              constraint: new Se({ min: 0, max: 1 })
            }),
            viewProps: this.viewProps
          })
        } : null, this.alphaIcs_ && gt({
          primary: this.value,
          secondary: this.alphaIcs_.text.value,
          forward: (i) => i.rawValue.getComponents()[3],
          backward: (i, c) => {
            const _ = i.rawValue.getComponents();
            return _[3] = c.rawValue, new O(_, i.rawValue.mode);
          }
        }), this.textC_ = new Vo(e, {
          colorType: t.colorType,
          parser: Be,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new He(e, {
          alphaViews: this.alphaIcs_ ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view
          } : null,
          hPaletteView: this.hPaletteC_.view,
          supportsAlpha: t.supportsAlpha,
          svPaletteView: this.svPaletteC_.view,
          textView: this.textC_.view
        });
      }
      get textController() {
        return this.textC_;
      }
    }
    const Oi = I("colsw");
    class Fo {
      constructor(e, t) {
        this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(Oi()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("div");
        i.classList.add(Oi("sw")), this.element.appendChild(i), this.swatchElem_ = i;
        const c = e.createElement("button");
        c.classList.add(Oi("b")), t.viewProps.bindDisabled(c), this.element.appendChild(c), this.buttonElement = c, this.update_();
      }
      update_() {
        const e = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Ai(e);
      }
      onValueChange_() {
        this.update_();
      }
    }
    class jo {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.view = new Fo(e, {
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    class Di {
      constructor(e, t) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Fe.create(t.expanded), this.swatchC_ = new jo(e, {
          value: this.value,
          viewProps: this.viewProps
        });
        const i = this.swatchC_.view.buttonElement;
        i.addEventListener("blur", this.onButtonBlur_), i.addEventListener("click", this.onButtonClick_), this.textC_ = new Ut(e, {
          parser: t.parser,
          props: j.fromObject({
            formatter: t.formatter
          }),
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new Hn(e, {
          foldable: this.foldable_,
          pickerLayout: t.pickerLayout
        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = t.pickerLayout === "popup" ? new Rn(e, {
          viewProps: this.viewProps
        }) : null;
        const c = new Do(e, {
          colorType: t.colorType,
          supportsAlpha: t.supportsAlpha,
          value: this.value,
          viewProps: this.viewProps
        });
        c.view.allFocusableElements.forEach((_) => {
          _.addEventListener("blur", this.onPopupChildBlur_), _.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = c, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(c.view.element), gt({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (_) => _.rawValue,
          backward: (_, y) => y.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), B(this.foldable_, this.view.pickerElement));
      }
      get textController() {
        return this.textC_;
      }
      onButtonBlur_(e) {
        if (!this.popC_)
          return;
        const t = this.view.element, i = e.relatedTarget;
        (!i || !t.contains(i)) && (this.popC_.shows.rawValue = false);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e) {
        if (!this.popC_)
          return;
        const t = this.popC_.view.element, i = Ae(e);
        i && t.contains(i) || i && i === this.swatchC_.view.buttonElement && !ut(t.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e) {
        this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus();
      }
    }
    function Bo(n, e) {
      return O.isColorObject(n) ? O.fromObject(n, e) : O.black(e);
    }
    function Uo(n) {
      return o(n.getComponents("rgb")).reduce((e, t) => e << 8 | Math.floor(t) & 255, 0);
    }
    function zo(n) {
      return n.getComponents("rgb").reduce((e, t, i) => {
        const c = Math.floor(i === 3 ? t * 255 : t) & 255;
        return e << 8 | c;
      }, 0) >>> 0;
    }
    function Ko(n) {
      return new O([n >> 16 & 255, n >> 8 & 255, n & 255], "rgb");
    }
    function Ho(n) {
      return new O([
        n >> 24 & 255,
        n >> 16 & 255,
        n >> 8 & 255,
        ee(n & 255, 0, 255, 0, 1)
      ], "rgb");
    }
    function Go(n) {
      return typeof n != "number" ? O.black() : Ko(n);
    }
    function $o(n) {
      return typeof n != "number" ? O.black() : Ho(n);
    }
    function qo(n) {
      const e = Vi(n);
      return e ? (t, i) => {
        wt(t, e(i));
      } : null;
    }
    function Yo(n) {
      const e = n ? zo : Uo;
      return (t, i) => {
        wt(t, e(i));
      };
    }
    function Xo(n, e, t) {
      const i = e.toRgbaObject(t);
      n.writeProperty("r", i.r), n.writeProperty("g", i.g), n.writeProperty("b", i.b), n.writeProperty("a", i.a);
    }
    function Wo(n, e, t) {
      const i = e.toRgbaObject(t);
      n.writeProperty("r", i.r), n.writeProperty("g", i.g), n.writeProperty("b", i.b);
    }
    function Zo(n, e) {
      return (t, i) => {
        n ? Xo(t, i, e) : Wo(t, i, e);
      };
    }
    function Fi(n) {
      var e;
      return !!((n == null ? void 0 : n.alpha) || ((e = n == null ? void 0 : n.color) === null || e === void 0 ? void 0 : e.alpha));
    }
    function Qo(n) {
      return n ? (e) => Ai(e, "0x") : (e) => wr(e, "0x");
    }
    function Jo(n) {
      return "color" in n || "view" in n && n.view === "color";
    }
    const ea = {
      id: "input-color-number",
      type: "input",
      accept: (n, e) => {
        if (typeof n != "number" || !Jo(e))
          return null;
        const t = qn(e);
        return t ? {
          initialValue: n,
          params: t
        } : null;
      },
      binding: {
        reader: (n) => Fi(n.params) ? $o : Go,
        equals: O.equals,
        writer: (n) => Yo(Fi(n.params))
      },
      controller: (n) => {
        const e = Fi(n.params), t = "expanded" in n.params ? n.params.expanded : void 0, i = "picker" in n.params ? n.params.picker : void 0;
        return new Di(n.document, {
          colorType: "int",
          expanded: t != null ? t : false,
          formatter: Qo(e),
          parser: Si("int"),
          pickerLayout: i != null ? i : "popup",
          supportsAlpha: e,
          value: n.value,
          viewProps: n.viewProps
        });
      }
    };
    function ta(n) {
      return O.isRgbaColorObject(n);
    }
    function na(n) {
      return (e) => Bo(e, n);
    }
    function sa(n, e) {
      return (t) => n ? Cr(t, e) : yr(t, e);
    }
    const ia = {
      id: "input-color-object",
      type: "input",
      accept: (n, e) => {
        if (!O.isColorObject(n))
          return null;
        const t = qn(e);
        return t ? {
          initialValue: n,
          params: t
        } : null;
      },
      binding: {
        reader: (n) => na(Gt(n.params)),
        equals: O.equals,
        writer: (n) => Zo(ta(n.initialValue), Gt(n.params))
      },
      controller: (n) => {
        var e;
        const t = O.isRgbaColorObject(n.initialValue), i = "expanded" in n.params ? n.params.expanded : void 0, c = "picker" in n.params ? n.params.picker : void 0, _ = (e = Gt(n.params)) !== null && e !== void 0 ? e : "int";
        return new Di(n.document, {
          colorType: _,
          expanded: i != null ? i : false,
          formatter: sa(t, _),
          parser: Si(_),
          pickerLayout: c != null ? c : "popup",
          supportsAlpha: t,
          value: n.value,
          viewProps: n.viewProps
        });
      }
    }, ra = {
      id: "input-color-string",
      type: "input",
      accept: (n, e) => {
        if (typeof n != "string" || "view" in e && e.view === "text")
          return null;
        const t = Li(n, Gt(e));
        if (!t || !Vi(t))
          return null;
        const c = qn(e);
        return c ? {
          initialValue: n,
          params: c
        } : null;
      },
      binding: {
        reader: (n) => {
          var e;
          return _o((e = Gt(n.params)) !== null && e !== void 0 ? e : "int");
        },
        equals: O.equals,
        writer: (n) => {
          const e = Li(n.initialValue, Gt(n.params));
          if (!e)
            throw L.shouldNeverHappen();
          const t = qo(e);
          if (!t)
            throw L.notBindable();
          return t;
        }
      },
      controller: (n) => {
        const e = Li(n.initialValue, Gt(n.params));
        if (!e)
          throw L.shouldNeverHappen();
        const t = Vi(e);
        if (!t)
          throw L.shouldNeverHappen();
        const i = "expanded" in n.params ? n.params.expanded : void 0, c = "picker" in n.params ? n.params.picker : void 0;
        return new Di(n.document, {
          colorType: e.type,
          expanded: i != null ? i : false,
          formatter: t,
          parser: Si(e.type),
          pickerLayout: c != null ? c : "popup",
          supportsAlpha: e.alpha,
          value: n.value,
          viewProps: n.viewProps
        });
      }
    };
    class Et {
      constructor(e) {
        this.components = e.components, this.asm_ = e.assembly;
      }
      constrain(e) {
        const t = this.asm_.toComponents(e).map((i, c) => {
          var _, y;
          return (y = (_ = this.components[c]) === null || _ === void 0 ? void 0 : _.constrain(i)) !== null && y !== void 0 ? y : i;
        });
        return this.asm_.fromComponents(t);
      }
    }
    const Pr = I("pndtxt");
    class oa {
      constructor(e, t) {
        this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(Pr()), this.textViews.forEach((i) => {
          const c = e.createElement("div");
          c.classList.add(Pr("a")), c.appendChild(i.element), this.element.appendChild(c);
        });
      }
    }
    function aa(n, e, t) {
      return new Ke(n, {
        arrayPosition: t === 0 ? "fst" : t === e.axes.length - 1 ? "lst" : "mid",
        baseStep: e.axes[t].baseStep,
        parser: e.parser,
        props: e.axes[t].textProps,
        value: X(0, {
          constraint: e.axes[t].constraint
        }),
        viewProps: e.viewProps
      });
    }
    class ji {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map((i, c) => aa(e, t, c)), this.acs_.forEach((i, c) => {
          gt({
            primary: this.value,
            secondary: i.value,
            forward: (_) => t.assembly.toComponents(_.rawValue)[c],
            backward: (_, y) => {
              const M = t.assembly.toComponents(_.rawValue);
              return M[c] = y.rawValue, t.assembly.fromComponents(M);
            }
          });
        }), this.view = new oa(e, {
          textViews: this.acs_.map((i) => i.view)
        });
      }
    }
    function kr(n, e) {
      return "step" in n && !g(n.step) ? new he(n.step, e) : null;
    }
    function Tr(n) {
      return "max" in n && !g(n.max) || "min" in n && !g(n.min) ? new Se({
        max: n.max,
        min: n.min
      }) : null;
    }
    function la(n, e) {
      const t = [], i = kr(n, e);
      i && t.push(i);
      const c = Tr(n);
      c && t.push(c);
      const _ = zn(n.options);
      return _ && t.push(_), new Ze(t);
    }
    function ca(n) {
      const e = n ? Q(n, Se) : null;
      return e ? [e.minValue, e.maxValue] : [void 0, void 0];
    }
    function pa(n) {
      const [e, t] = ca(n);
      return [e != null ? e : 0, t != null ? t : 100];
    }
    const ua = {
      id: "input-number",
      type: "input",
      accept: (n, e) => {
        if (typeof n != "number")
          return null;
        const t = H, i = re2(e, {
          format: t.optional.function,
          max: t.optional.number,
          min: t.optional.number,
          options: t.optional.custom(xt),
          step: t.optional.number
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => Dn,
        constraint: (n) => la(n.params, n.initialValue),
        writer: (n) => wt
      },
      controller: (n) => {
        var e, t;
        const i = n.value, c = n.constraint;
        if (c && Q(c, bt))
          return new st(n.document, {
            props: j.fromObject({
              options: (e = Kn(c)) !== null && e !== void 0 ? e : []
            }),
            value: i,
            viewProps: n.viewProps
          });
        const _ = (t = "format" in n.params ? n.params.format : void 0) !== null && t !== void 0 ? t : se(pn(c, i.rawValue));
        if (c && Q(c, Se)) {
          const [y, M] = pa(c);
          return new cn(n.document, {
            baseStep: yt(c),
            parser: Be,
            sliderProps: j.fromObject({
              maxValue: M,
              minValue: y
            }),
            textProps: j.fromObject({
              draggingScale: Ct(c, i.rawValue),
              formatter: _
            }),
            value: i,
            viewProps: n.viewProps
          });
        }
        return new Ke(n.document, {
          baseStep: yt(c),
          parser: Be,
          props: j.fromObject({
            draggingScale: Ct(c, i.rawValue),
            formatter: _
          }),
          value: i,
          viewProps: n.viewProps
        });
      }
    };
    class Pt {
      constructor(e = 0, t = 0) {
        this.x = e, this.y = t;
      }
      getComponents() {
        return [this.x, this.y];
      }
      static isObject(e) {
        if (g(e))
          return false;
        const t = e.x, i = e.y;
        return !(typeof t != "number" || typeof i != "number");
      }
      static equals(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y
        };
      }
    }
    const Mr = {
      toComponents: (n) => n.getComponents(),
      fromComponents: (n) => new Pt(...n)
    }, hn = I("p2d");
    class da {
      constructor(e, t) {
        this.element = e.createElement("div"), this.element.classList.add(hn()), t.viewProps.bindClassModifiers(this.element), te(t.expanded, J(this.element, hn(void 0, "expanded")));
        const i = e.createElement("div");
        i.classList.add(hn("h")), this.element.appendChild(i);
        const c = e.createElement("button");
        c.classList.add(hn("b")), c.appendChild($e(e, "p2dpad")), t.viewProps.bindDisabled(c), i.appendChild(c), this.buttonElement = c;
        const _ = e.createElement("div");
        if (_.classList.add(hn("t")), i.appendChild(_), this.textElement = _, t.pickerLayout === "inline") {
          const y = e.createElement("div");
          y.classList.add(hn("p")), this.element.appendChild(y), this.pickerElement = y;
        } else
          this.pickerElement = null;
      }
    }
    const kt = I("p2dp");
    class ha {
      constructor(e, t) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(kt()), t.layout === "popup" && this.element.classList.add(kt(void 0, "p"));
        const i = e.createElement("div");
        i.classList.add(kt("p")), t.viewProps.bindTabIndex(i), this.element.appendChild(i), this.padElement = i;
        const c = e.createElementNS(Ee, "svg");
        c.classList.add(kt("g")), this.padElement.appendChild(c), this.svgElem_ = c;
        const _ = e.createElementNS(Ee, "line");
        _.classList.add(kt("ax")), _.setAttributeNS(null, "x1", "0"), _.setAttributeNS(null, "y1", "50%"), _.setAttributeNS(null, "x2", "100%"), _.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(_);
        const y = e.createElementNS(Ee, "line");
        y.classList.add(kt("ax")), y.setAttributeNS(null, "x1", "50%"), y.setAttributeNS(null, "y1", "0"), y.setAttributeNS(null, "x2", "50%"), y.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(y);
        const M = e.createElementNS(Ee, "line");
        M.classList.add(kt("l")), M.setAttributeNS(null, "x1", "50%"), M.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(M), this.lineElem_ = M;
        const F = e.createElement("div");
        F.classList.add(kt("m")), this.padElement.appendChild(F), this.markerElem_ = F, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_();
      }
      get allFocusableElements() {
        return [this.padElement];
      }
      update_() {
        const [e, t] = this.value.rawValue.getComponents(), i = this.maxValue_, c = ee(e, -i, +i, 0, 100), _ = ee(t, -i, +i, 0, 100), y = this.invertsY_ ? 100 - _ : _;
        this.lineElem_.setAttributeNS(null, "x2", `${c}%`), this.lineElem_.setAttributeNS(null, "y2", `${y}%`), this.markerElem_.style.left = `${c}%`, this.markerElem_.style.top = `${y}%`;
      }
      onValueChange_() {
        this.update_();
      }
      onFoldableChange_() {
        this.update_();
      }
    }
    function Lr(n, e, t) {
      return [
        me(e[0], ze(n)),
        me(e[1], Re(n)) * (t ? 1 : -1)
      ];
    }
    class ma {
      constructor(e, t) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new ha(e, {
          invertsY: this.invertsY_,
          layout: t.layout,
          maxValue: this.maxValue_,
          value: this.value,
          viewProps: this.viewProps
        }), this.ptHandler_ = new it(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
      }
      handlePointerEvent_(e, t) {
        if (!e.point)
          return;
        const i = this.maxValue_, c = ee(e.point.x, 0, e.bounds.width, -i, +i), _ = ee(this.invertsY_ ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -i, +i);
        this.value.setRawValue(new Pt(c, _), t);
      }
      onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
          forceEmit: true,
          last: true
        });
      }
      onPadKeyDown_(e) {
        ws(e.key) && e.preventDefault();
        const [t, i] = Lr(e, this.baseSteps_, this.invertsY_);
        t === 0 && i === 0 || this.value.setRawValue(new Pt(this.value.rawValue.x + t, this.value.rawValue.y + i), {
          forceEmit: false,
          last: false
        });
      }
      onPadKeyUp_(e) {
        const [t, i] = Lr(e, this.baseSteps_, this.invertsY_);
        t === 0 && i === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    class va {
      constructor(e, t) {
        var i, c;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Fe.create(t.expanded), this.popC_ = t.pickerLayout === "popup" ? new Rn(e, {
          viewProps: this.viewProps
        }) : null;
        const _ = new ma(e, {
          baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
          invertsY: t.invertsY,
          layout: t.pickerLayout,
          maxValue: t.maxValue,
          value: this.value,
          viewProps: this.viewProps
        });
        _.view.allFocusableElements.forEach((y) => {
          y.addEventListener("blur", this.onPopupChildBlur_), y.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = _, this.textC_ = new ji(e, {
          assembly: Mr,
          axes: t.axes,
          parser: t.parser,
          value: this.value,
          viewProps: this.viewProps
        }), this.view = new da(e, {
          expanded: this.foldable_.value("expanded"),
          pickerLayout: t.pickerLayout,
          viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.textC_.view.element), (i = this.view.buttonElement) === null || i === void 0 || i.addEventListener("blur", this.onPadButtonBlur_), (c = this.view.buttonElement) === null || c === void 0 || c.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), gt({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (y) => y.rawValue,
          backward: (y, M) => M.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), B(this.foldable_, this.view.pickerElement));
      }
      onPadButtonBlur_(e) {
        if (!this.popC_)
          return;
        const t = this.view.element, i = e.relatedTarget;
        (!i || !t.contains(i)) && (this.popC_.shows.rawValue = false);
      }
      onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(e) {
        if (!this.popC_)
          return;
        const t = this.popC_.view.element, i = Ae(e);
        i && t.contains(i) || i && i === this.view.buttonElement && !ut(t.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(e) {
        this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus();
      }
    }
    function fa(n) {
      return Pt.isObject(n) ? new Pt(n.x, n.y) : new Pt();
    }
    function ba(n, e) {
      n.writeProperty("x", e.x), n.writeProperty("y", e.y);
    }
    function at(n, e) {
      if (!n)
        return;
      const t = [], i = kr(n, e);
      i && t.push(i);
      const c = Tr(n);
      return c && t.push(c), new Ze(t);
    }
    function _a(n, e) {
      return new Et({
        assembly: Mr,
        components: [
          at("x" in n ? n.x : void 0, e.x),
          at("y" in n ? n.y : void 0, e.y)
        ]
      });
    }
    function Sr(n, e) {
      var t, i;
      const c = n && Q(n, Se);
      if (c)
        return Math.max(Math.abs((t = c.minValue) !== null && t !== void 0 ? t : 0), Math.abs((i = c.maxValue) !== null && i !== void 0 ? i : 0));
      const _ = yt(n);
      return Math.max(Math.abs(_) * 10, Math.abs(e) * 10);
    }
    function ga(n, e) {
      const t = e instanceof Et ? e.components[0] : void 0, i = e instanceof Et ? e.components[1] : void 0, c = Sr(t, n.x), _ = Sr(i, n.y);
      return Math.max(c, _);
    }
    function Ar(n, e) {
      return {
        baseStep: yt(e),
        constraint: e,
        textProps: j.fromObject({
          draggingScale: Ct(e, n),
          formatter: se(pn(e, n))
        })
      };
    }
    function wa(n) {
      if (!("y" in n))
        return false;
      const e = n.y;
      return e && "inverted" in e ? !!e.inverted : false;
    }
    const xa = {
      id: "input-point2d",
      type: "input",
      accept: (n, e) => {
        if (!Pt.isObject(n))
          return null;
        const t = H, i = re2(e, {
          expanded: t.optional.boolean,
          picker: t.optional.custom(Es),
          x: t.optional.custom(fe),
          y: t.optional.object({
            inverted: t.optional.boolean,
            max: t.optional.number,
            min: t.optional.number,
            step: t.optional.number
          })
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => fa,
        constraint: (n) => _a(n.params, n.initialValue),
        equals: Pt.equals,
        writer: (n) => ba
      },
      controller: (n) => {
        const e = n.document, t = n.value, i = n.constraint;
        if (!(i instanceof Et))
          throw L.shouldNeverHappen();
        const c = "expanded" in n.params ? n.params.expanded : void 0, _ = "picker" in n.params ? n.params.picker : void 0;
        return new va(e, {
          axes: [
            Ar(t.rawValue.x, i.components[0]),
            Ar(t.rawValue.y, i.components[1])
          ],
          expanded: c != null ? c : false,
          invertsY: wa(n.params),
          maxValue: ga(t.rawValue, i),
          parser: Be,
          pickerLayout: _ != null ? _ : "popup",
          value: t,
          viewProps: n.viewProps
        });
      }
    };
    class mn {
      constructor(e = 0, t = 0, i = 0) {
        this.x = e, this.y = t, this.z = i;
      }
      getComponents() {
        return [this.x, this.y, this.z];
      }
      static isObject(e) {
        if (g(e))
          return false;
        const t = e.x, i = e.y, c = e.z;
        return !(typeof t != "number" || typeof i != "number" || typeof c != "number");
      }
      static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z
        };
      }
    }
    const Vr = {
      toComponents: (n) => n.getComponents(),
      fromComponents: (n) => new mn(...n)
    };
    function ya(n) {
      return mn.isObject(n) ? new mn(n.x, n.y, n.z) : new mn();
    }
    function Ca(n, e) {
      n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z);
    }
    function Ea(n, e) {
      return new Et({
        assembly: Vr,
        components: [
          at("x" in n ? n.x : void 0, e.x),
          at("y" in n ? n.y : void 0, e.y),
          at("z" in n ? n.z : void 0, e.z)
        ]
      });
    }
    function Bi(n, e) {
      return {
        baseStep: yt(e),
        constraint: e,
        textProps: j.fromObject({
          draggingScale: Ct(e, n),
          formatter: se(pn(e, n))
        })
      };
    }
    const Pa = {
      id: "input-point3d",
      type: "input",
      accept: (n, e) => {
        if (!mn.isObject(n))
          return null;
        const t = H, i = re2(e, {
          x: t.optional.custom(fe),
          y: t.optional.custom(fe),
          z: t.optional.custom(fe)
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => ya,
        constraint: (n) => Ea(n.params, n.initialValue),
        equals: mn.equals,
        writer: (n) => Ca
      },
      controller: (n) => {
        const e = n.value, t = n.constraint;
        if (!(t instanceof Et))
          throw L.shouldNeverHappen();
        return new ji(n.document, {
          assembly: Vr,
          axes: [
            Bi(e.rawValue.x, t.components[0]),
            Bi(e.rawValue.y, t.components[1]),
            Bi(e.rawValue.z, t.components[2])
          ],
          parser: Be,
          value: e,
          viewProps: n.viewProps
        });
      }
    };
    class vn {
      constructor(e = 0, t = 0, i = 0, c = 0) {
        this.x = e, this.y = t, this.z = i, this.w = c;
      }
      getComponents() {
        return [this.x, this.y, this.z, this.w];
      }
      static isObject(e) {
        if (g(e))
          return false;
        const t = e.x, i = e.y, c = e.z, _ = e.w;
        return !(typeof t != "number" || typeof i != "number" || typeof c != "number" || typeof _ != "number");
      }
      static equals(e, t) {
        return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
      }
      toObject() {
        return {
          x: this.x,
          y: this.y,
          z: this.z,
          w: this.w
        };
      }
    }
    const Rr = {
      toComponents: (n) => n.getComponents(),
      fromComponents: (n) => new vn(...n)
    };
    function ka(n) {
      return vn.isObject(n) ? new vn(n.x, n.y, n.z, n.w) : new vn();
    }
    function Ta(n, e) {
      n.writeProperty("x", e.x), n.writeProperty("y", e.y), n.writeProperty("z", e.z), n.writeProperty("w", e.w);
    }
    function Ma(n, e) {
      return new Et({
        assembly: Rr,
        components: [
          at("x" in n ? n.x : void 0, e.x),
          at("y" in n ? n.y : void 0, e.y),
          at("z" in n ? n.z : void 0, e.z),
          at("w" in n ? n.w : void 0, e.w)
        ]
      });
    }
    function La(n, e) {
      return {
        baseStep: yt(e),
        constraint: e,
        textProps: j.fromObject({
          draggingScale: Ct(e, n),
          formatter: se(pn(e, n))
        })
      };
    }
    const Sa = {
      id: "input-point4d",
      type: "input",
      accept: (n, e) => {
        if (!vn.isObject(n))
          return null;
        const t = H, i = re2(e, {
          x: t.optional.custom(fe),
          y: t.optional.custom(fe),
          z: t.optional.custom(fe),
          w: t.optional.custom(fe)
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => ka,
        constraint: (n) => Ma(n.params, n.initialValue),
        equals: vn.equals,
        writer: (n) => Ta
      },
      controller: (n) => {
        const e = n.value, t = n.constraint;
        if (!(t instanceof Et))
          throw L.shouldNeverHappen();
        return new ji(n.document, {
          assembly: Rr,
          axes: e.rawValue.getComponents().map((i, c) => La(i, t.components[c])),
          parser: Be,
          value: e,
          viewProps: n.viewProps
        });
      }
    };
    function Aa(n) {
      const e = [], t = zn(n.options);
      return t && e.push(t), new Ze(e);
    }
    const Va = {
      id: "input-string",
      type: "input",
      accept: (n, e) => {
        if (typeof n != "string")
          return null;
        const i = re2(e, {
          options: H.optional.custom(xt)
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => _s,
        constraint: (n) => Aa(n.params),
        writer: (n) => wt
      },
      controller: (n) => {
        var e;
        const t = n.document, i = n.value, c = n.constraint;
        return c && Q(c, bt) ? new st(t, {
          props: j.fromObject({
            options: (e = Kn(c)) !== null && e !== void 0 ? e : []
          }),
          value: i,
          viewProps: n.viewProps
        }) : new Ut(t, {
          parser: (_) => _,
          props: j.fromObject({
            formatter: ln
          }),
          value: i,
          viewProps: n.viewProps
        });
      }
    }, Xn = {
      monitor: {
        defaultInterval: 200,
        defaultLineCount: 3
      }
    }, Nr = I("mll");
    class Ra {
      constructor(e, t) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Nr()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("textarea");
        i.classList.add(Nr("i")), i.style.height = `calc(var(--bld-us) * ${t.lineCount})`, i.readOnly = true, t.viewProps.bindDisabled(i), this.element.appendChild(i), this.textareaElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
      }
      update_() {
        const e = this.textareaElem_, t = e.scrollTop === e.scrollHeight - e.clientHeight, i = [];
        this.value.rawValue.forEach((c) => {
          c !== void 0 && i.push(this.formatter_(c));
        }), e.textContent = i.join(`
`), t && (e.scrollTop = e.scrollHeight);
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class Ui {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.view = new Ra(e, {
          formatter: t.formatter,
          lineCount: t.lineCount,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const Ir = I("sgl");
    class Na {
      constructor(e, t) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(Ir()), t.viewProps.bindClassModifiers(this.element);
        const i = e.createElement("input");
        i.classList.add(Ir("i")), i.readOnly = true, i.type = "text", t.viewProps.bindDisabled(i), this.element.appendChild(i), this.inputElement = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
      }
      update_() {
        const e = this.value.rawValue, t = e[e.length - 1];
        this.inputElement.value = t !== void 0 ? this.formatter_(t) : "";
      }
      onValueUpdate_() {
        this.update_();
      }
    }
    class zi {
      constructor(e, t) {
        this.value = t.value, this.viewProps = t.viewProps, this.view = new Na(e, {
          formatter: t.formatter,
          value: this.value,
          viewProps: this.viewProps
        });
      }
    }
    const Ia = {
      id: "monitor-bool",
      type: "monitor",
      accept: (n, e) => {
        if (typeof n != "boolean")
          return null;
        const i = re2(e, {
          lineCount: H.optional.number
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => ds
      },
      controller: (n) => {
        var e;
        return n.value.rawValue.length === 1 ? new zi(n.document, {
          formatter: hs,
          value: n.value,
          viewProps: n.viewProps
        }) : new Ui(n.document, {
          formatter: hs,
          lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : Xn.monitor.defaultLineCount,
          value: n.value,
          viewProps: n.viewProps
        });
      }
    }, Tt = I("grl");
    class Oa {
      constructor(e, t) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(Tt()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.props_ = t.props, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const i = e.createElementNS(Ee, "svg");
        i.classList.add(Tt("g")), i.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(i), this.svgElem_ = i;
        const c = e.createElementNS(Ee, "polyline");
        this.svgElem_.appendChild(c), this.lineElem_ = c;
        const _ = e.createElement("div");
        _.classList.add(Tt("t"), I("tt")()), this.element.appendChild(_), this.tooltipElem_ = _, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const e = this.svgElem_.getBoundingClientRect(), t = this.value.rawValue.length - 1, i = this.props_.get("minValue"), c = this.props_.get("maxValue"), _ = [];
        this.value.rawValue.forEach((W, Z) => {
          if (W === void 0)
            return;
          const lt = ee(Z, 0, t, 0, e.width), Wn = ee(W, i, c, e.height, 0);
          _.push([lt, Wn].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", _.join(" "));
        const y = this.tooltipElem_, M = this.value.rawValue[this.cursor_.rawValue];
        if (M === void 0) {
          y.classList.remove(Tt("t", "a"));
          return;
        }
        const F = ee(this.cursor_.rawValue, 0, t, 0, e.width), U = ee(M, i, c, e.height, 0);
        y.style.left = `${F}px`, y.style.top = `${U}px`, y.textContent = `${this.formatter_(M)}`, y.classList.contains(Tt("t", "a")) || (y.classList.add(Tt("t", "a"), Tt("t", "in")), Je2(y), y.classList.remove(Tt("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class Da {
      constructor(e, t) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = t.props, this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = X(-1), this.view = new Oa(e, {
          cursor: this.cursor_,
          formatter: t.formatter,
          lineCount: t.lineCount,
          props: this.props_,
          value: this.value,
          viewProps: this.viewProps
        }), !ut(e))
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
          const i = new it(this.view.element);
          i.emitter.on("down", this.onGraphPointerDown_), i.emitter.on("move", this.onGraphPointerMove_), i.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(e) {
        const t = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(ee(e.offsetX, 0, t.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(e) {
        this.onGraphPointerMove_(e);
      }
      onGraphPointerMove_(e) {
        if (!e.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(ee(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    function Ki(n) {
      return "format" in n && !g(n.format) ? n.format : se(2);
    }
    function Fa(n) {
      var e;
      return n.value.rawValue.length === 1 ? new zi(n.document, {
        formatter: Ki(n.params),
        value: n.value,
        viewProps: n.viewProps
      }) : new Ui(n.document, {
        formatter: Ki(n.params),
        lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : Xn.monitor.defaultLineCount,
        value: n.value,
        viewProps: n.viewProps
      });
    }
    function ja(n) {
      var e, t, i;
      return new Da(n.document, {
        formatter: Ki(n.params),
        lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : Xn.monitor.defaultLineCount,
        props: j.fromObject({
          maxValue: (t = "max" in n.params ? n.params.max : null) !== null && t !== void 0 ? t : 100,
          minValue: (i = "min" in n.params ? n.params.min : null) !== null && i !== void 0 ? i : 0
        }),
        value: n.value,
        viewProps: n.viewProps
      });
    }
    function Or(n) {
      return "view" in n && n.view === "graph";
    }
    const Ba = {
      id: "monitor-number",
      type: "monitor",
      accept: (n, e) => {
        if (typeof n != "number")
          return null;
        const t = H, i = re2(e, {
          format: t.optional.function,
          lineCount: t.optional.number,
          max: t.optional.number,
          min: t.optional.number,
          view: t.optional.string
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        defaultBufferSize: (n) => Or(n) ? 64 : 1,
        reader: (n) => Dn
      },
      controller: (n) => Or(n.params) ? ja(n) : Fa(n)
    }, Ua = {
      id: "monitor-string",
      type: "monitor",
      accept: (n, e) => {
        if (typeof n != "string")
          return null;
        const t = H, i = re2(e, {
          lineCount: t.optional.number,
          multiline: t.optional.boolean
        });
        return i ? {
          initialValue: n,
          params: i
        } : null;
      },
      binding: {
        reader: (n) => _s
      },
      controller: (n) => {
        var e;
        const t = n.value;
        return t.rawValue.length > 1 || "multiline" in n.params && n.params.multiline ? new Ui(n.document, {
          formatter: ln,
          lineCount: (e = n.params.lineCount) !== null && e !== void 0 ? e : Xn.monitor.defaultLineCount,
          value: t,
          viewProps: n.viewProps
        }) : new zi(n.document, {
          formatter: ln,
          value: t,
          viewProps: n.viewProps
        });
      }
    };
    class za {
      constructor(e) {
        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new R(), this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read();
      }
      read() {
        const e = this.target.read();
        e !== void 0 && (this.value.rawValue = this.reader(e));
      }
      write_(e) {
        this.writer(this.target, e);
      }
      onValueChange_(e) {
        this.write_(e.rawValue), this.emitter.emit("change", {
          options: e.options,
          rawValue: e.rawValue,
          sender: this
        });
      }
    }
    function Ka(n, e) {
      const t = n.accept(e.target.read(), e.params);
      if (g(t))
        return null;
      const i = H, c = {
        target: e.target,
        initialValue: t.initialValue,
        params: t.params
      }, _ = n.binding.reader(c), y = n.binding.constraint ? n.binding.constraint(c) : void 0, M = X(_(t.initialValue), {
        constraint: y,
        equals: n.binding.equals
      }), F = new za({
        reader: _,
        target: e.target,
        value: M,
        writer: n.binding.writer(c)
      }), U = i.optional.boolean(e.params.disabled).value, W = i.optional.boolean(e.params.hidden).value, Z = n.controller({
        constraint: y,
        document: e.document,
        initialValue: t.initialValue,
        params: t.params,
        value: F.value,
        viewProps: We.create({
          disabled: U,
          hidden: W
        })
      }), lt = i.optional.string(e.params.label).value;
      return new Te(e.document, {
        binding: F,
        blade: De(),
        props: j.fromObject({
          label: lt != null ? lt : e.target.key
        }),
        valueController: Z
      });
    }
    class Ha {
      constructor(e) {
        this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new R(), this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
      }
      dispose() {
        this.ticker.dispose();
      }
      read() {
        const e = this.target.read();
        if (e === void 0)
          return;
        const t = this.value.rawValue, i = this.reader_(e);
        this.value.rawValue = gs(t, i), this.emitter.emit("update", {
          rawValue: i,
          sender: this
        });
      }
      onTick_(e) {
        this.read();
      }
    }
    function Ga(n, e) {
      return e === 0 ? new cs() : new An(n, e != null ? e : Xn.monitor.defaultInterval);
    }
    function $a(n, e) {
      var t, i, c;
      const _ = H, y = n.accept(e.target.read(), e.params);
      if (g(y))
        return null;
      const M = {
        target: e.target,
        initialValue: y.initialValue,
        params: y.params
      }, F = n.binding.reader(M), U = (i = (t = _.optional.number(e.params.bufferSize).value) !== null && t !== void 0 ? t : n.binding.defaultBufferSize && n.binding.defaultBufferSize(y.params)) !== null && i !== void 0 ? i : 1, W = _.optional.number(e.params.interval).value, Z = new Ha({
        reader: F,
        target: e.target,
        ticker: Ga(e.document, W),
        value: bi(U)
      }), lt = _.optional.boolean(e.params.disabled).value, Wn = _.optional.boolean(e.params.hidden).value, Zn = n.controller({
        document: e.document,
        params: y.params,
        value: Z.value,
        viewProps: We.create({
          disabled: lt,
          hidden: Wn
        })
      }), fn = (c = _.optional.string(e.params.label).value) !== null && c !== void 0 ? c : e.target.key;
      return new Xe(e.document, {
        binding: Z,
        blade: De(),
        props: j.fromObject({
          label: fn
        }),
        valueController: Zn
      });
    }
    class qa {
      constructor() {
        this.pluginsMap_ = {
          blades: [],
          inputs: [],
          monitors: []
        };
      }
      getAll() {
        return [
          ...this.pluginsMap_.blades,
          ...this.pluginsMap_.inputs,
          ...this.pluginsMap_.monitors
        ];
      }
      register(e) {
        e.type === "blade" ? this.pluginsMap_.blades.unshift(e) : e.type === "input" ? this.pluginsMap_.inputs.unshift(e) : e.type === "monitor" && this.pluginsMap_.monitors.unshift(e);
      }
      createInput(e, t, i) {
        const c = t.read();
        if (g(c))
          throw new L({
            context: {
              key: t.key
            },
            type: "nomatchingcontroller"
          });
        const _ = this.pluginsMap_.inputs.reduce((y, M) => y != null ? y : Ka(M, {
          document: e,
          target: t,
          params: i
        }), null);
        if (_)
          return _;
        throw new L({
          context: {
            key: t.key
          },
          type: "nomatchingcontroller"
        });
      }
      createMonitor(e, t, i) {
        const c = this.pluginsMap_.monitors.reduce((_, y) => _ != null ? _ : $a(y, {
          document: e,
          params: i,
          target: t
        }), null);
        if (c)
          return c;
        throw new L({
          context: {
            key: t.key
          },
          type: "nomatchingcontroller"
        });
      }
      createBlade(e, t) {
        const i = this.pluginsMap_.blades.reduce((c, _) => c != null ? c : Gs(_, {
          document: e,
          params: t
        }), null);
        if (!i)
          throw new L({
            type: "nomatchingview",
            context: {
              params: t
            }
          });
        return i;
      }
      createBladeApi(e) {
        if (e instanceof Te)
          return new we(e);
        if (e instanceof Xe)
          return new nt(e);
        if (e instanceof Dt)
          return new Ot(e, this);
        const t = this.pluginsMap_.blades.reduce((i, c) => i != null ? i : c.api({
          controller: e,
          pool: this
        }), null);
        if (!t)
          throw L.shouldNeverHappen();
        return t;
      }
    }
    function Ya() {
      const n = new qa();
      return [
        xa,
        Pa,
        Sa,
        Va,
        ua,
        ra,
        ia,
        ea,
        Ei,
        Ia,
        Ua,
        Ba,
        ht,
        Bs,
        rs,
        Sn
      ].forEach((e) => {
        n.register(e);
      }), n;
    }
    class Dr extends d {
      constructor(e) {
        super(e), this.emitter_ = new R(), this.controller_.valueController.value.emitter.on("change", (t) => {
          this.emitter_.emit("change", {
            event: new h(this, t.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      get options() {
        return this.controller_.valueController.props.get("options");
      }
      set options(e) {
        this.controller_.valueController.props.set("options", e);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e) {
        this.controller_.valueController.value.rawValue = e;
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
    }
    class Fr extends d {
      constructor(e) {
        super(e), this.emitter_ = new R(), this.controller_.valueController.value.emitter.on("change", (t) => {
          this.emitter_.emit("change", {
            event: new h(this, t.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      get maxValue() {
        return this.controller_.valueController.sliderController.props.get("maxValue");
      }
      set maxValue(e) {
        this.controller_.valueController.sliderController.props.set("maxValue", e);
      }
      get minValue() {
        return this.controller_.valueController.sliderController.props.get("minValue");
      }
      set minValue(e) {
        this.controller_.valueController.sliderController.props.set("minValue", e);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e) {
        this.controller_.valueController.value.rawValue = e;
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
    }
    class jr extends d {
      constructor(e) {
        super(e), this.emitter_ = new R(), this.controller_.valueController.value.emitter.on("change", (t) => {
          this.emitter_.emit("change", {
            event: new h(this, t.rawValue)
          });
        });
      }
      get label() {
        return this.controller_.props.get("label");
      }
      set label(e) {
        this.controller_.props.set("label", e);
      }
      get formatter() {
        return this.controller_.valueController.props.get("formatter");
      }
      set formatter(e) {
        this.controller_.valueController.props.set("formatter", e);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(e) {
        this.controller_.valueController.value.rawValue = e;
      }
      on(e, t) {
        const i = t.bind(this);
        return this.emitter_.on(e, (c) => {
          i(c.event);
        }), this;
      }
    }
    const Xa = function() {
      return {
        id: "list",
        type: "blade",
        accept(n) {
          const e = H, t = re2(n, {
            options: e.required.custom(xt),
            value: e.required.raw,
            view: e.required.constant("list"),
            label: e.optional.string
          });
          return t ? { params: t } : null;
        },
        controller(n) {
          const e = new st(n.document, {
            props: j.fromObject({
              options: Ps(n.params.options)
            }),
            value: X(n.params.value),
            viewProps: n.viewProps
          });
          return new vt(n.document, {
            blade: n.blade,
            props: j.fromObject({
              label: n.params.label
            }),
            valueController: e
          });
        },
        api(n) {
          return !(n.controller instanceof vt) || !(n.controller.valueController instanceof st) ? null : new Dr(n.controller);
        }
      };
    }();
    function Wa(n) {
      return n.reduce((e, t) => Object.assign(e, {
        [t.presetKey]: t.read()
      }), {});
    }
    function Za(n, e) {
      n.forEach((t) => {
        const i = e[t.presetKey];
        i !== void 0 && t.write(i);
      });
    }
    class Qa extends En {
      constructor(e, t) {
        super(e, t);
      }
      get element() {
        return this.controller_.view.element;
      }
      importPreset(e) {
        const t = this.controller_.rackController.rack.find(Te).map((i) => i.binding.target);
        Za(t, e), this.refresh();
      }
      exportPreset() {
        const e = this.controller_.rackController.rack.find(Te).map((t) => t.binding.target);
        return Wa(e);
      }
      refresh() {
        this.controller_.rackController.rack.find(Te).forEach((e) => {
          e.binding.read();
        }), this.controller_.rackController.rack.find(Xe).forEach((e) => {
          e.binding.read();
        });
      }
    }
    class Ja extends Tn {
      constructor(e, t) {
        super(e, {
          expanded: t.expanded,
          blade: t.blade,
          props: t.props,
          root: true,
          viewProps: t.viewProps
        });
      }
    }
    const el = {
      id: "slider",
      type: "blade",
      accept(n) {
        const e = H, t = re2(n, {
          max: e.required.number,
          min: e.required.number,
          view: e.required.constant("slider"),
          format: e.optional.function,
          label: e.optional.string,
          value: e.optional.number
        });
        return t ? { params: t } : null;
      },
      controller(n) {
        var e, t;
        const i = (e = n.params.value) !== null && e !== void 0 ? e : 0, c = new cn(n.document, {
          baseStep: 1,
          parser: Be,
          sliderProps: j.fromObject({
            maxValue: n.params.max,
            minValue: n.params.min
          }),
          textProps: j.fromObject({
            draggingScale: Ct(void 0, i),
            formatter: (t = n.params.format) !== null && t !== void 0 ? t : vi
          }),
          value: X(i),
          viewProps: n.viewProps
        });
        return new vt(n.document, {
          blade: n.blade,
          props: j.fromObject({
            label: n.params.label
          }),
          valueController: c
        });
      },
      api(n) {
        return !(n.controller instanceof vt) || !(n.controller.valueController instanceof cn) ? null : new Fr(n.controller);
      }
    }, tl = function() {
      return {
        id: "text",
        type: "blade",
        accept(n) {
          const e = H, t = re2(n, {
            parse: e.required.function,
            value: e.required.raw,
            view: e.required.constant("text"),
            format: e.optional.function,
            label: e.optional.string
          });
          return t ? { params: t } : null;
        },
        controller(n) {
          var e;
          const t = new Ut(n.document, {
            parser: n.params.parse,
            props: j.fromObject({
              formatter: (e = n.params.format) !== null && e !== void 0 ? e : (i) => String(i)
            }),
            value: X(n.params.value),
            viewProps: n.viewProps
          });
          return new vt(n.document, {
            blade: n.blade,
            props: j.fromObject({
              label: n.params.label
            }),
            valueController: t
          });
        },
        api(n) {
          return !(n.controller instanceof vt) || !(n.controller.valueController instanceof Ut) ? null : new jr(n.controller);
        }
      };
    }();
    function nl(n) {
      const e = n.createElement("div");
      return e.classList.add(I("dfw")()), n.body && n.body.appendChild(e), e;
    }
    function Br(n, e, t) {
      if (n.querySelector(`style[data-tp-style=${e}]`))
        return;
      const i = n.createElement("style");
      i.dataset.tpStyle = e, i.textContent = t, n.head.appendChild(i);
    }
    class sl extends Qa {
      constructor(e) {
        var t, i;
        const c = e != null ? e : {}, _ = (t = c.document) !== null && t !== void 0 ? t : xn(), y = Ya(), M = new Ja(_, {
          expanded: c.expanded,
          blade: De(),
          props: j.fromObject({
            title: c.title
          }),
          viewProps: We.create()
        });
        super(M, y), this.pool_ = y, this.containerElem_ = (i = c.container) !== null && i !== void 0 ? i : nl(_), this.containerElem_.appendChild(this.element), this.doc_ = _, this.usesDefaultWrapper_ = !c.container, this.setUpDefaultPlugins_();
      }
      get document() {
        if (!this.doc_)
          throw L.alreadyDisposed();
        return this.doc_;
      }
      dispose() {
        const e = this.containerElem_;
        if (!e)
          throw L.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
          const t = e.parentElement;
          t && t.removeChild(e);
        }
        this.containerElem_ = null, this.doc_ = null, super.dispose();
      }
      registerPlugin(e) {
        ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((i) => {
          this.pool_.register(i), this.embedPluginStyle_(i);
        });
      }
      embedPluginStyle_(e) {
        e.css && Br(this.document, `plugin-${e.id}`, e.css);
      }
      setUpDefaultPlugins_() {
        Br(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((e) => {
          this.embedPluginStyle_(e);
        }), this.registerPlugin({
          plugins: [
            el,
            Xa,
            Sn,
            tl
          ]
        });
      }
    }
    const il = new a("3.1.0");
    p.BladeApi = d, p.ButtonApi = N, p.FolderApi = En, p.InputBindingApi = we, p.ListApi = Dr, p.MonitorBindingApi = nt, p.Pane = sl, p.SeparatorApi = Mn, p.SliderApi = Fr, p.TabApi = as, p.TabPageApi = Ln, p.TextApi = jr, p.TpChangeEvent = h, p.VERSION = il, Object.defineProperty(p, "__esModule", { value: true });
  });
})(tr, tr.exports);
var Vs = { exports: {} };
(function(T, u) {
  (function(p, a) {
    a(u);
  })(po, function(p) {
    class a {
      constructor(s) {
        this.controller_ = s;
      }
      get element() {
        return this.controller_.view.element;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(s) {
        this.controller_.viewProps.set("disabled", s);
      }
      get hidden() {
        return this.controller_.viewProps.get("hidden");
      }
      set hidden(s) {
        this.controller_.viewProps.set("hidden", s);
      }
      dispose() {
        this.controller_.viewProps.set("disposed", true);
      }
    }
    class d {
      constructor(s) {
        this.target = s;
      }
    }
    class m extends d {
      constructor(s, r, l, v) {
        super(s), this.value = r, this.presetKey = l, this.last = v != null ? v : true;
      }
    }
    function h(o) {
      return o;
    }
    function b(o) {
      return o == null;
    }
    const f = {
      alreadydisposed: () => "View has been already disposed",
      invalidparams: (o) => `Invalid parameters for '${o.name}'`,
      nomatchingcontroller: (o) => `No matching controller for '${o.key}'`,
      nomatchingview: (o) => `No matching view for '${JSON.stringify(o.params)}'`,
      notbindable: () => "Value is not bindable",
      propertynotfound: (o) => `Property '${o.name}' not found`,
      shouldneverhappen: () => "This error should never happen"
    };
    class x {
      constructor(s) {
        var r;
        this.message = (r = f[s.type](s.context)) !== null && r !== void 0 ? r : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = s.type;
      }
      static alreadyDisposed() {
        return new x({ type: "alreadydisposed" });
      }
      static notBindable() {
        return new x({
          type: "notbindable"
        });
      }
      static propertyNotFound(s) {
        return new x({
          type: "propertynotfound",
          context: {
            name: s
          }
        });
      }
      static shouldNeverHappen() {
        return new x({ type: "shouldneverhappen" });
      }
    }
    class E {
      constructor() {
        this.observers_ = {};
      }
      on(s, r) {
        let l = this.observers_[s];
        return l || (l = this.observers_[s] = []), l.push({
          handler: r
        }), this;
      }
      off(s, r) {
        const l = this.observers_[s];
        return l && (this.observers_[s] = l.filter((v) => v.handler !== r)), this;
      }
      emit(s, r) {
        const l = this.observers_[s];
        !l || l.forEach((v) => {
          v.handler(r);
        });
      }
    }
    const g = "tp";
    function k(o) {
      return (r, l) => [
        g,
        "-",
        o,
        "v",
        r ? `_${r}` : "",
        l ? `-${l}` : ""
      ].join("");
    }
    function V(o, s) {
      return (r) => s(o(r));
    }
    function L(o) {
      return o.rawValue;
    }
    function D(o, s) {
      o.emitter.on("change", V(L, s)), s(o.rawValue);
    }
    function N(o, s, r) {
      D(o.value(s), r);
    }
    function R(o, s, r) {
      r ? o.classList.add(s) : o.classList.remove(s);
    }
    function q(o, s) {
      return (r) => {
        R(o, s, r);
      };
    }
    function I(o, s) {
      D(o, (r) => {
        s.textContent = r != null ? r : "";
      });
    }
    const ie = k("btn");
    class ue {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(ie()), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElement("button");
        l.classList.add(ie("b")), r.viewProps.bindDisabled(l), this.element.appendChild(l), this.buttonElement = l;
        const v = s.createElement("div");
        v.classList.add(ie("t")), I(r.props.value("title"), v), this.buttonElement.appendChild(v);
      }
    }
    class te {
      constructor(s, r) {
        this.emitter = new E(), this.onClick_ = this.onClick_.bind(this), this.props = r.props, this.viewProps = r.viewProps, this.view = new ue(s, {
          props: this.props,
          viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("click", this.onClick_);
      }
      onClick_() {
        this.emitter.emit("click", {
          sender: this
        });
      }
    }
    class Y {
      constructor(s, r) {
        var l;
        this.constraint_ = r == null ? void 0 : r.constraint, this.equals_ = (l = r == null ? void 0 : r.equals) !== null && l !== void 0 ? l : (v, w) => v === w, this.emitter = new E(), this.rawValue_ = s;
      }
      get constraint() {
        return this.constraint_;
      }
      get rawValue() {
        return this.rawValue_;
      }
      set rawValue(s) {
        this.setRawValue(s, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(s, r) {
        const l = r != null ? r : {
          forceEmit: false,
          last: true
        }, v = this.constraint_ ? this.constraint_.constrain(s) : s;
        !!this.equals_(this.rawValue_, v) && !l.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.rawValue_ = v, this.emitter.emit("change", {
          options: l,
          rawValue: v,
          sender: this
        }));
      }
    }
    class z {
      constructor(s) {
        this.emitter = new E(), this.value_ = s;
      }
      get rawValue() {
        return this.value_;
      }
      set rawValue(s) {
        this.setRawValue(s, {
          forceEmit: false,
          last: true
        });
      }
      setRawValue(s, r) {
        const l = r != null ? r : {
          forceEmit: false,
          last: true
        };
        this.value_ === s && !l.forceEmit || (this.emitter.emit("beforechange", {
          sender: this
        }), this.value_ = s, this.emitter.emit("change", {
          options: l,
          rawValue: this.value_,
          sender: this
        }));
      }
    }
    function J(o, s) {
      const r = s == null ? void 0 : s.constraint, l = s == null ? void 0 : s.equals;
      return !r && !l ? new z(o) : new Y(o, s);
    }
    class ne {
      constructor(s) {
        this.emitter = new E(), this.valMap_ = s;
        for (const r in this.valMap_)
          this.valMap_[r].emitter.on("change", () => {
            this.emitter.emit("change", {
              key: r,
              sender: this
            });
          });
      }
      static createCore(s) {
        return Object.keys(s).reduce((l, v) => Object.assign(l, {
          [v]: J(s[v])
        }), {});
      }
      static fromObject(s) {
        const r = this.createCore(s);
        return new ne(r);
      }
      get(s) {
        return this.valMap_[s].rawValue;
      }
      set(s, r) {
        this.valMap_[s].rawValue = r;
      }
      value(s) {
        return this.valMap_[s];
      }
    }
    function be(o, s) {
      const l = Object.keys(s).reduce((v, w) => {
        if (v === void 0)
          return;
        const P = s[w], A = P(o[w]);
        return A.succeeded ? Object.assign(Object.assign({}, v), { [w]: A.value }) : void 0;
      }, {});
      return l;
    }
    function ye(o, s) {
      return o.reduce((r, l) => {
        if (r === void 0)
          return;
        const v = s(l);
        if (!(!v.succeeded || v.value === void 0))
          return [...r, v.value];
      }, []);
    }
    function de(o) {
      return o === null ? false : typeof o == "object";
    }
    function pe(o) {
      return (s) => (r) => {
        if (!s && r === void 0)
          return {
            succeeded: false,
            value: void 0
          };
        if (s && r === void 0)
          return {
            succeeded: true,
            value: void 0
          };
        const l = o(r);
        return l !== void 0 ? {
          succeeded: true,
          value: l
        } : {
          succeeded: false,
          value: void 0
        };
      };
    }
    function ve(o) {
      return {
        custom: (s) => pe(s)(o),
        boolean: pe((s) => typeof s == "boolean" ? s : void 0)(o),
        number: pe((s) => typeof s == "number" ? s : void 0)(o),
        string: pe((s) => typeof s == "string" ? s : void 0)(o),
        function: pe((s) => typeof s == "function" ? s : void 0)(o),
        constant: (s) => pe((r) => r === s ? s : void 0)(o),
        raw: pe((s) => s)(o),
        object: (s) => pe((r) => {
          if (!!de(r))
            return be(r, s);
        })(o),
        array: (s) => pe((r) => {
          if (!!Array.isArray(r))
            return ye(r, s);
        })(o)
      };
    }
    const X = {
      optional: ve(true),
      required: ve(false)
    };
    function j(o, s) {
      const r = X.required.object(s)(o);
      return r.succeeded ? r.value : void 0;
    }
    function pt(o) {
      return o && o.parentElement && o.parentElement.removeChild(o), null;
    }
    function Zt() {
      return ["veryfirst", "first", "last", "verylast"];
    }
    const Qt = k(""), _e = {
      veryfirst: "vfst",
      first: "fst",
      last: "lst",
      verylast: "vlst"
    };
    class Lt {
      constructor(s) {
        this.parent_ = null, this.blade = s.blade, this.view = s.view, this.viewProps = s.viewProps;
        const r = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
          Zt().forEach((l) => {
            r.classList.remove(Qt(void 0, _e[l]));
          }), this.blade.get("positions").forEach((l) => {
            r.classList.add(Qt(void 0, _e[l]));
          });
        }), this.viewProps.handleDispose(() => {
          pt(r);
        });
      }
      get parent() {
        return this.parent_;
      }
    }
    const H = "http://www.w3.org/2000/svg";
    function re2(o) {
      o.offsetHeight;
    }
    function wn(o, s) {
      const r = o.style.transition;
      o.style.transition = "none", s(), o.style.transition = r;
    }
    function Jt(o) {
      return o.ontouchstart !== void 0;
    }
    function St(o) {
      for (; o.childNodes.length > 0; )
        o.removeChild(o.childNodes[0]);
    }
    function At(o) {
      return o.relatedTarget ? o.relatedTarget : "explicitOriginalTarget" in o ? o.explicitOriginalTarget : null;
    }
    const Ce = k("lbl");
    function Ee(o, s) {
      const r = o.createDocumentFragment();
      return s.split(`
`).map((v) => o.createTextNode(v)).forEach((v, w) => {
        w > 0 && r.appendChild(o.createElement("br")), r.appendChild(v);
      }), r;
    }
    class Je2 {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(Ce()), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElement("div");
        l.classList.add(Ce("l")), N(r.props, "label", (w) => {
          b(w) ? this.element.classList.add(Ce(void 0, "nol")) : (this.element.classList.remove(Ce(void 0, "nol")), St(l), l.appendChild(Ee(s, w)));
        }), this.element.appendChild(l), this.labelElement = l;
        const v = s.createElement("div");
        v.classList.add(Ce("v")), this.element.appendChild(v), this.valueElement = v;
      }
    }
    class et extends Lt {
      constructor(s, r) {
        const l = r.valueController.viewProps;
        super(Object.assign(Object.assign({}, r), { view: new Je2(s, {
          props: r.props,
          viewProps: l
        }), viewProps: l })), this.props = r.props, this.valueController = r.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    class ut extends Lt {
      constructor(s) {
        super(s), this.value = s.value;
      }
    }
    class dt extends ne {
      constructor(s) {
        super(s);
      }
      static create(s) {
        const r = {
          completed: true,
          expanded: s,
          expandedHeight: null,
          shouldFixHeight: false,
          temporaryExpanded: null
        }, l = ne.createCore(r);
        return new dt(l);
      }
      get styleExpanded() {
        var s;
        return (s = this.get("temporaryExpanded")) !== null && s !== void 0 ? s : this.get("expanded");
      }
      get styleHeight() {
        if (!this.styleExpanded)
          return "0";
        const s = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !b(s) ? `${s}px` : "auto";
      }
      bindExpandedClass(s, r) {
        const l = () => {
          this.styleExpanded ? s.classList.add(r) : s.classList.remove(r);
        };
        N(this, "expanded", l), N(this, "temporaryExpanded", l);
      }
      cleanUpTransition() {
        this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
      }
    }
    function xn(o) {
      return dt.create(o);
    }
    function yn(o, s) {
      let r = 0;
      return wn(s, () => {
        o.set("expandedHeight", null), o.set("temporaryExpanded", true), re2(s), r = s.clientHeight, o.set("temporaryExpanded", null), re2(s);
      }), r;
    }
    function Vt(o, s) {
      s.style.height = o.styleHeight;
    }
    function $e(o, s) {
      o.value("expanded").emitter.on("beforechange", () => {
        o.set("completed", false), b(o.get("expandedHeight")) && o.set("expandedHeight", yn(o, s)), o.set("shouldFixHeight", true), re2(s);
      }), o.emitter.on("change", () => {
        Vt(o, s);
      }), Vt(o, s), s.addEventListener("transitionend", (r) => {
        r.propertyName === "height" && o.cleanUpTransition();
      });
    }
    class tt {
      constructor(s, r) {
        const l = k(r.viewName);
        this.element = s.createElement("div"), this.element.classList.add(l()), r.viewProps.bindClassModifiers(this.element);
      }
    }
    class qe extends ut {
      constructor(s, r) {
        const l = r.valueController.viewProps;
        super(Object.assign(Object.assign({}, r), { value: r.valueController.value, view: new Je2(s, {
          props: r.props,
          viewProps: l
        }), viewProps: l })), this.props = r.props, this.valueController = r.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
      }
    }
    const en = k("");
    function tn(o, s) {
      return q(o, en(void 0, s));
    }
    class Ae extends ne {
      constructor(s) {
        super(s);
      }
      static create(s) {
        var r, l;
        const v = s != null ? s : {}, w = {
          disabled: (r = v.disabled) !== null && r !== void 0 ? r : false,
          disposed: false,
          hidden: (l = v.hidden) !== null && l !== void 0 ? l : false
        }, P = ne.createCore(w);
        return new Ae(P);
      }
      bindClassModifiers(s) {
        N(this, "disabled", tn(s, "disabled")), N(this, "hidden", tn(s, "hidden"));
      }
      bindDisabled(s) {
        N(this, "disabled", (r) => {
          s.disabled = r;
        });
      }
      bindTabIndex(s) {
        N(this, "disabled", (r) => {
          s.tabIndex = r ? -1 : 0;
        });
      }
      handleDispose(s) {
        this.value("disposed").emitter.on("change", (r) => {
          r && s();
        });
      }
    }
    class Ye {
      constructor() {
        this.disabled = false, this.emitter = new E();
      }
      dispose() {
      }
      tick() {
        this.disabled || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class Cn {
      constructor(s, r) {
        this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = s, this.emitter = new E(), this.interval_ = r, this.setTimer_();
      }
      get disabled() {
        return this.disabled_;
      }
      set disabled(s) {
        this.disabled_ = s, this.disabled_ ? this.clearTimer_() : this.setTimer_();
      }
      dispose() {
        this.clearTimer_();
      }
      clearTimer_() {
        if (this.timerId_ === null)
          return;
        const s = this.doc_.defaultView;
        s && s.clearInterval(this.timerId_), this.timerId_ = null;
      }
      setTimer_() {
        if (this.clearTimer_(), this.interval_ <= 0)
          return;
        const s = this.doc_.defaultView;
        s && (this.timerId_ = s.setInterval(this.onTick_, this.interval_));
      }
      onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
          sender: this
        });
      }
    }
    class Rt {
      constructor(s) {
        this.constraints = s;
      }
      constrain(s) {
        return this.constraints.reduce((r, l) => l.constrain(r), s);
      }
    }
    function Ve(o, s) {
      if (o instanceof s)
        return o;
      if (o instanceof Rt) {
        const r = o.constraints.reduce((l, v) => l || (v instanceof s ? v : null), null);
        if (r)
          return r;
      }
      return null;
    }
    class ht {
      constructor(s) {
        this.maxValue = s.max, this.minValue = s.min;
      }
      constrain(s) {
        let r = s;
        return b(this.minValue) || (r = Math.max(r, this.minValue)), b(this.maxValue) || (r = Math.min(r, this.maxValue)), r;
      }
    }
    class Pe {
      constructor(s, r = 0) {
        this.step = s, this.origin = r;
      }
      constrain(s) {
        const r = this.origin % this.step, l = Math.round((s - r) / this.step);
        return r + l * this.step;
      }
    }
    const De = k("pop");
    class Fe {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(De()), r.viewProps.bindClassModifiers(this.element), D(r.shows, q(this.element, De(void 0, "v")));
      }
    }
    class C {
      constructor(s, r) {
        this.shows = J(false), this.viewProps = r.viewProps, this.view = new Fe(s, {
          shows: this.shows,
          viewProps: this.viewProps
        });
      }
    }
    const S = k("txt");
    class B {
      constructor(s, r) {
        this.onChange_ = this.onChange_.bind(this), this.element = s.createElement("div"), this.element.classList.add(S()), r.viewProps.bindClassModifiers(this.element), this.props_ = r.props, this.props_.emitter.on("change", this.onChange_);
        const l = s.createElement("input");
        l.classList.add(S("i")), l.type = "text", r.viewProps.bindDisabled(l), this.element.appendChild(l), this.inputElement = l, r.value.emitter.on("change", this.onChange_), this.value_ = r.value, this.refresh();
      }
      refresh() {
        const s = this.props_.get("formatter");
        this.inputElement.value = s(this.value_.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class G {
      constructor(s, r) {
        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = r.parser, this.props = r.props, this.value = r.value, this.viewProps = r.viewProps, this.view = new B(s, {
          props: r.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_);
      }
      onInputChange_(s) {
        const l = s.currentTarget.value, v = this.parser_(l);
        b(v) || (this.value.rawValue = v), this.view.refresh();
      }
    }
    function oe(o) {
      return o === "false" ? false : !!o;
    }
    class ke {
      constructor(s) {
        this.text = s;
      }
      evaluate() {
        return Number(this.text);
      }
      toString() {
        return this.text;
      }
    }
    const mt = {
      "**": (o, s) => Math.pow(o, s),
      "*": (o, s) => o * s,
      "/": (o, s) => o / s,
      "%": (o, s) => o % s,
      "+": (o, s) => o + s,
      "-": (o, s) => o - s,
      "<<": (o, s) => o << s,
      ">>": (o, s) => o >> s,
      ">>>": (o, s) => o >>> s,
      "&": (o, s) => o & s,
      "^": (o, s) => o ^ s,
      "|": (o, s) => o | s
    };
    class nn {
      constructor(s, r, l) {
        this.left = r, this.operator = s, this.right = l;
      }
      evaluate() {
        const s = mt[this.operator];
        if (!s)
          throw new Error(`unexpected binary operator: '${this.operator}`);
        return s(this.left.evaluate(), this.right.evaluate());
      }
      toString() {
        return [
          "b(",
          this.left.toString(),
          this.operator,
          this.right.toString(),
          ")"
        ].join(" ");
      }
    }
    const ge = {
      "+": (o) => o,
      "-": (o) => -o,
      "~": (o) => ~o
    };
    class we {
      constructor(s, r) {
        this.operator = s, this.expression = r;
      }
      evaluate() {
        const s = ge[this.operator];
        if (!s)
          throw new Error(`unexpected unary operator: '${this.operator}`);
        return s(this.expression.evaluate());
      }
      toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
      }
    }
    function Te(o) {
      return (s, r) => {
        for (let l = 0; l < o.length; l++) {
          const v = o[l](s, r);
          if (v !== "")
            return v;
        }
        return "";
      };
    }
    function nt(o, s) {
      var r;
      const l = o.substr(s).match(/^\s+/);
      return (r = l && l[0]) !== null && r !== void 0 ? r : "";
    }
    function Xe(o, s) {
      const r = o.substr(s, 1);
      return r.match(/^[1-9]$/) ? r : "";
    }
    function Nt(o, s) {
      var r;
      const l = o.substr(s).match(/^[0-9]+/);
      return (r = l && l[0]) !== null && r !== void 0 ? r : "";
    }
    function It(o, s) {
      const r = Nt(o, s);
      if (r !== "")
        return r;
      const l = o.substr(s, 1);
      if (s += 1, l !== "-" && l !== "+")
        return "";
      const v = Nt(o, s);
      return v === "" ? "" : l + v;
    }
    function sn(o, s) {
      const r = o.substr(s, 1);
      if (s += 1, r.toLowerCase() !== "e")
        return "";
      const l = It(o, s);
      return l === "" ? "" : r + l;
    }
    function Ot(o, s) {
      const r = o.substr(s, 1);
      if (r === "0")
        return r;
      const l = Xe(o, s);
      return s += l.length, l === "" ? "" : l + Nt(o, s);
    }
    function En(o, s) {
      const r = Ot(o, s);
      if (s += r.length, r === "")
        return "";
      const l = o.substr(s, 1);
      if (s += l.length, l !== ".")
        return "";
      const v = Nt(o, s);
      return s += v.length, r + l + v + sn(o, s);
    }
    function Pn(o, s) {
      const r = o.substr(s, 1);
      if (s += r.length, r !== ".")
        return "";
      const l = Nt(o, s);
      return s += l.length, l === "" ? "" : r + l + sn(o, s);
    }
    function Rs(o, s) {
      const r = Ot(o, s);
      return s += r.length, r === "" ? "" : r + sn(o, s);
    }
    const Ns = Te([
      En,
      Pn,
      Rs
    ]);
    function Is(o, s) {
      var r;
      const l = o.substr(s).match(/^[01]+/);
      return (r = l && l[0]) !== null && r !== void 0 ? r : "";
    }
    function Os(o, s) {
      const r = o.substr(s, 2);
      if (s += r.length, r.toLowerCase() !== "0b")
        return "";
      const l = Is(o, s);
      return l === "" ? "" : r + l;
    }
    function kn(o, s) {
      var r;
      const l = o.substr(s).match(/^[0-7]+/);
      return (r = l && l[0]) !== null && r !== void 0 ? r : "";
    }
    function Ds(o, s) {
      const r = o.substr(s, 2);
      if (s += r.length, r.toLowerCase() !== "0o")
        return "";
      const l = kn(o, s);
      return l === "" ? "" : r + l;
    }
    function Fs(o, s) {
      var r;
      const l = o.substr(s).match(/^[0-9a-f]+/i);
      return (r = l && l[0]) !== null && r !== void 0 ? r : "";
    }
    function Dt(o, s) {
      const r = o.substr(s, 2);
      if (s += r.length, r.toLowerCase() !== "0x")
        return "";
      const l = Fs(o, s);
      return l === "" ? "" : r + l;
    }
    const ns = Te([
      Os,
      Ds,
      Dt
    ]), js = Te([
      ns,
      Ns
    ]);
    function Tn(o, s) {
      const r = js(o, s);
      return s += r.length, r === "" ? null : {
        evaluable: new ke(r),
        cursor: s
      };
    }
    function Bs(o, s) {
      const r = o.substr(s, 1);
      if (s += r.length, r !== "(")
        return null;
      const l = rs(o, s);
      if (!l)
        return null;
      s = l.cursor, s += nt(o, s).length;
      const v = o.substr(s, 1);
      return s += v.length, v !== ")" ? null : {
        evaluable: l.evaluable,
        cursor: s
      };
    }
    function vt(o, s) {
      var r;
      return (r = Tn(o, s)) !== null && r !== void 0 ? r : Bs(o, s);
    }
    function Mn(o, s) {
      const r = vt(o, s);
      if (r)
        return r;
      const l = o.substr(s, 1);
      if (s += l.length, l !== "+" && l !== "-" && l !== "~")
        return null;
      const v = Mn(o, s);
      return v ? (s = v.cursor, {
        cursor: s,
        evaluable: new we(l, v.evaluable)
      }) : null;
    }
    function ss(o, s, r) {
      r += nt(s, r).length;
      const l = o.filter((v) => s.startsWith(v, r))[0];
      return l ? (r += l.length, r += nt(s, r).length, {
        cursor: r,
        operator: l
      }) : null;
    }
    function Us(o, s) {
      return (r, l) => {
        const v = o(r, l);
        if (!v)
          return null;
        l = v.cursor;
        let w = v.evaluable;
        for (; ; ) {
          const P = ss(s, r, l);
          if (!P)
            break;
          l = P.cursor;
          const A = o(r, l);
          if (!A)
            return null;
          l = A.cursor, w = new nn(P.operator, w, A.evaluable);
        }
        return w ? {
          cursor: l,
          evaluable: w
        } : null;
      };
    }
    const is = [
      ["**"],
      ["*", "/", "%"],
      ["+", "-"],
      ["<<", ">>>", ">>"],
      ["&"],
      ["^"],
      ["|"]
    ].reduce((o, s) => Us(o, s), Mn);
    function rs(o, s) {
      return s += nt(o, s).length, is(o, s);
    }
    function zs(o) {
      const s = rs(o, 0);
      return !s || s.cursor + nt(o, s.cursor).length !== o.length ? null : s.evaluable;
    }
    function Ft(o) {
      var s;
      const r = zs(o);
      return (s = r == null ? void 0 : r.evaluate()) !== null && s !== void 0 ? s : null;
    }
    function We(o) {
      if (typeof o == "number")
        return o;
      if (typeof o == "string") {
        const s = Ft(o);
        if (!b(s))
          return s;
      }
      return 0;
    }
    function ce(o) {
      return (s) => s.toFixed(Math.max(Math.min(o, 20), 0));
    }
    const Ks = ce(0);
    function rn(o) {
      return Ks(o) + "%";
    }
    function os(o) {
      return String(o);
    }
    function Ln(o, s) {
      for (; o.length < s; )
        o.push(void 0);
    }
    function as(o) {
      const s = [];
      return Ln(s, o), J(s);
    }
    function ls(o) {
      const s = o.indexOf(void 0);
      return s < 0 ? o : o.slice(0, s);
    }
    function Hs(o, s) {
      const r = [...ls(o), s];
      return r.length > o.length ? r.splice(0, r.length - o.length) : Ln(r, o.length), r;
    }
    function jt({ primary: o, secondary: s, forward: r, backward: l }) {
      let v = false;
      function w(P) {
        v || (v = true, P(), v = false);
      }
      o.emitter.on("change", (P) => {
        w(() => {
          s.setRawValue(r(o, s), P.options);
        });
      }), s.emitter.on("change", (P) => {
        w(() => {
          o.setRawValue(l(o, s), P.options);
        }), w(() => {
          s.setRawValue(r(o, s), P.options);
        });
      }), w(() => {
        s.setRawValue(r(o, s), {
          forceEmit: false,
          last: true
        });
      });
    }
    function ft(o, s) {
      const r = o * (s.altKey ? 0.1 : 1) * (s.shiftKey ? 10 : 1);
      return s.upKey ? +r : s.downKey ? -r : 0;
    }
    function Bt(o) {
      return {
        altKey: o.altKey,
        downKey: o.key === "ArrowDown",
        shiftKey: o.shiftKey,
        upKey: o.key === "ArrowUp"
      };
    }
    function Sn(o) {
      return {
        altKey: o.altKey,
        downKey: o.key === "ArrowLeft",
        shiftKey: o.shiftKey,
        upKey: o.key === "ArrowRight"
      };
    }
    function Gs(o) {
      return o === "ArrowUp" || o === "ArrowDown";
    }
    function cs(o) {
      return Gs(o) || o === "ArrowLeft" || o === "ArrowRight";
    }
    function An(o, s) {
      var r, l;
      const v = s.ownerDocument.defaultView, w = s.getBoundingClientRect();
      return {
        x: o.pageX - (((r = v && v.scrollX) !== null && r !== void 0 ? r : 0) + w.left),
        y: o.pageY - (((l = v && v.scrollY) !== null && l !== void 0 ? l : 0) + w.top)
      };
    }
    class Ze {
      constructor(s) {
        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = s, this.emitter = new E(), s.addEventListener("touchstart", this.onTouchStart_, {
          passive: false
        }), s.addEventListener("touchmove", this.onTouchMove_, {
          passive: true
        }), s.addEventListener("touchend", this.onTouchEnd_), s.addEventListener("mousedown", this.onMouseDown_);
      }
      computePosition_(s) {
        const r = this.elem_.getBoundingClientRect();
        return {
          bounds: {
            width: r.width,
            height: r.height
          },
          point: s ? {
            x: s.x,
            y: s.y
          } : null
        };
      }
      onMouseDown_(s) {
        var r;
        s.preventDefault(), (r = s.currentTarget) === null || r === void 0 || r.focus();
        const l = this.elem_.ownerDocument;
        l.addEventListener("mousemove", this.onDocumentMouseMove_), l.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
          altKey: s.altKey,
          data: this.computePosition_(An(s, this.elem_)),
          sender: this,
          shiftKey: s.shiftKey
        });
      }
      onDocumentMouseMove_(s) {
        this.emitter.emit("move", {
          altKey: s.altKey,
          data: this.computePosition_(An(s, this.elem_)),
          sender: this,
          shiftKey: s.shiftKey
        });
      }
      onDocumentMouseUp_(s) {
        const r = this.elem_.ownerDocument;
        r.removeEventListener("mousemove", this.onDocumentMouseMove_), r.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
          altKey: s.altKey,
          data: this.computePosition_(An(s, this.elem_)),
          sender: this,
          shiftKey: s.shiftKey
        });
      }
      onTouchStart_(s) {
        s.preventDefault();
        const r = s.targetTouches.item(0), l = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
          altKey: s.altKey,
          data: this.computePosition_(r ? {
            x: r.clientX - l.left,
            y: r.clientY - l.top
          } : void 0),
          sender: this,
          shiftKey: s.shiftKey
        }), this.lastTouch_ = r;
      }
      onTouchMove_(s) {
        const r = s.targetTouches.item(0), l = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
          altKey: s.altKey,
          data: this.computePosition_(r ? {
            x: r.clientX - l.left,
            y: r.clientY - l.top
          } : void 0),
          sender: this,
          shiftKey: s.shiftKey
        }), this.lastTouch_ = r;
      }
      onTouchEnd_(s) {
        var r;
        const l = (r = s.targetTouches.item(0)) !== null && r !== void 0 ? r : this.lastTouch_, v = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
          altKey: s.altKey,
          data: this.computePosition_(l ? {
            x: l.clientX - v.left,
            y: l.clientY - v.top
          } : void 0),
          sender: this,
          shiftKey: s.shiftKey
        });
      }
    }
    function Q(o, s, r, l, v) {
      const w = (o - s) / (r - s);
      return l + w * (v - l);
    }
    function bt(o) {
      return String(o.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
    }
    function Se(o, s, r) {
      return Math.min(Math.max(o, s), r);
    }
    const he = k("txt");
    class Vn {
      constructor(s, r) {
        this.onChange_ = this.onChange_.bind(this), this.props_ = r.props, this.props_.emitter.on("change", this.onChange_), this.element = s.createElement("div"), this.element.classList.add(he(), he(void 0, "num")), r.arrayPosition && this.element.classList.add(he(void 0, r.arrayPosition)), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElement("input");
        l.classList.add(he("i")), l.type = "text", r.viewProps.bindDisabled(l), this.element.appendChild(l), this.inputElement = l, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = r.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(he()), this.inputElement.classList.add(he("i"));
        const v = s.createElement("div");
        v.classList.add(he("k")), this.element.appendChild(v), this.knobElement = v;
        const w = s.createElementNS(H, "svg");
        w.classList.add(he("g")), this.knobElement.appendChild(w);
        const P = s.createElementNS(H, "path");
        P.classList.add(he("gb")), w.appendChild(P), this.guideBodyElem_ = P;
        const A = s.createElementNS(H, "path");
        A.classList.add(he("gh")), w.appendChild(A), this.guideHeadElem_ = A;
        const O = s.createElement("div");
        O.classList.add(k("tt")()), this.knobElement.appendChild(O), this.tooltipElem_ = O, r.value.emitter.on("change", this.onChange_), this.value = r.value, this.refresh();
      }
      onDraggingChange_(s) {
        if (s.rawValue === null) {
          this.element.classList.remove(he(void 0, "drg"));
          return;
        }
        this.element.classList.add(he(void 0, "drg"));
        const r = s.rawValue / this.props_.get("draggingScale"), l = r + (r > 0 ? -1 : r < 0 ? 1 : 0), v = Se(-l, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${l + v},0 L${l},4 L${l + v},8`, `M ${r},-1 L${r},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${r},4`);
        const w = this.props_.get("formatter");
        this.tooltipElem_.textContent = w(this.value.rawValue), this.tooltipElem_.style.left = `${r}px`;
      }
      refresh() {
        const s = this.props_.get("formatter");
        this.inputElement.value = s(this.value.rawValue);
      }
      onChange_() {
        this.refresh();
      }
    }
    class $s {
      constructor(s, r) {
        var l;
        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = r.baseStep, this.parser_ = r.parser, this.props = r.props, this.sliderProps_ = (l = r.sliderProps) !== null && l !== void 0 ? l : null, this.value = r.value, this.viewProps = r.viewProps, this.dragging_ = J(null), this.view = new Vn(s, {
          arrayPosition: r.arrayPosition,
          dragging: this.dragging_,
          props: this.props,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const v = new Ze(this.view.knobElement);
        v.emitter.on("down", this.onPointerDown_), v.emitter.on("move", this.onPointerMove_), v.emitter.on("up", this.onPointerUp_);
      }
      constrainValue_(s) {
        var r, l;
        const v = (r = this.sliderProps_) === null || r === void 0 ? void 0 : r.get("minValue"), w = (l = this.sliderProps_) === null || l === void 0 ? void 0 : l.get("maxValue");
        let P = s;
        return v !== void 0 && (P = Math.max(P, v)), w !== void 0 && (P = Math.min(P, w)), P;
      }
      onInputChange_(s) {
        const l = s.currentTarget.value, v = this.parser_(l);
        b(v) || (this.value.rawValue = this.constrainValue_(v)), this.view.refresh();
      }
      onInputKeyDown_(s) {
        const r = ft(this.baseStep_, Bt(s));
        r !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + r), {
          forceEmit: false,
          last: false
        });
      }
      onInputKeyUp_(s) {
        ft(this.baseStep_, Bt(s)) !== 0 && this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
      onPointerDown_() {
        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
      }
      computeDraggingValue_(s) {
        if (!s.point)
          return null;
        const r = s.point.x - s.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + r * this.props.get("draggingScale"));
      }
      onPointerMove_(s) {
        const r = this.computeDraggingValue_(s.data);
        r !== null && (this.value.setRawValue(r, {
          forceEmit: false,
          last: false
        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
      }
      onPointerUp_(s) {
        const r = this.computeDraggingValue_(s.data);
        r !== null && (this.value.setRawValue(r, {
          forceEmit: true,
          last: true
        }), this.dragging_.rawValue = null);
      }
    }
    function st(o, s) {
      o.write(s);
    }
    function ps(o) {
      const s = o ? Ve(o, Pe) : null;
      return s ? s.step : null;
    }
    function qs(o, s) {
      const r = o && Ve(o, Pe);
      return r ? bt(r.step) : Math.max(bt(s), 2);
    }
    function Rn(o) {
      const s = ps(o);
      return s != null ? s : 1;
    }
    function us(o, s) {
      var r;
      const l = o && Ve(o, Pe), v = Math.abs((r = l == null ? void 0 : l.step) !== null && r !== void 0 ? r : s);
      return v === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(v)) - 1);
    }
    function on(o) {
      return [o[0], o[1], o[2]];
    }
    function Ut(o) {
      const s = Se(Math.floor(o), 0, 255).toString(16);
      return s.length === 1 ? `0${s}` : s;
    }
    function Ys(o, s = "#") {
      const r = on(o.getComponents("rgb")).map(Ut).join("");
      return `${s}${r}`;
    }
    function ds(o, s = "#") {
      const r = o.getComponents("rgb"), l = [r[0], r[1], r[2], r[3] * 255].map(Ut).join("");
      return `${s}${l}`;
    }
    function hs(o, s) {
      const r = ce(s === "float" ? 2 : 0);
      return `rgb(${on(o.getComponents("rgb", s)).map((v) => r(v)).join(", ")})`;
    }
    function Xs(o) {
      return (s) => hs(s, o);
    }
    function Ws(o, s) {
      const r = ce(2), l = ce(s === "float" ? 2 : 0);
      return `rgba(${o.getComponents("rgb", s).map((w, P) => (P === 3 ? r : l)(w)).join(", ")})`;
    }
    function Zs(o) {
      return (s) => Ws(s, o);
    }
    function Qs(o) {
      const s = [
        ce(0),
        rn,
        rn
      ];
      return `hsl(${on(o.getComponents("hsl")).map((l, v) => s[v](l)).join(", ")})`;
    }
    function Js(o) {
      const s = [
        ce(0),
        rn,
        rn,
        ce(2)
      ];
      return `hsla(${o.getComponents("hsl").map((l, v) => s[v](l)).join(", ")})`;
    }
    function Nn(o, s) {
      const r = ce(s === "float" ? 2 : 0), l = ["r", "g", "b"];
      return `{${on(o.getComponents("rgb", s)).map((w, P) => `${l[P]}: ${r(w)}`).join(", ")}}`;
    }
    function zt(o) {
      return (s) => Nn(s, o);
    }
    function ei(o, s) {
      const r = ce(2), l = ce(s === "float" ? 2 : 0), v = ["r", "g", "b", "a"];
      return `{${o.getComponents("rgb", s).map((P, A) => {
        const O = A === 3 ? r : l;
        return `${v[A]}: ${O(P)}`;
      }).join(", ")}}`;
    }
    function Kt(o) {
      return (s) => ei(s, o);
    }
    [
      ...["int", "float"].reduce((o, s) => [
        ...o,
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "func",
            type: s
          },
          stringifier: Xs(s)
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "func",
            type: s
          },
          stringifier: Zs(s)
        },
        {
          format: {
            alpha: false,
            mode: "rgb",
            notation: "object",
            type: s
          },
          stringifier: zt(s)
        },
        {
          format: {
            alpha: true,
            mode: "rgb",
            notation: "object",
            type: s
          },
          stringifier: Kt(s)
        }
      ], [])
    ];
    class ti {
      constructor(s) {
        this.components = s.components, this.asm_ = s.assembly;
      }
      constrain(s) {
        const r = this.asm_.toComponents(s).map((l, v) => {
          var w, P;
          return (P = (w = this.components[v]) === null || w === void 0 ? void 0 : w.constrain(l)) !== null && P !== void 0 ? P : l;
        });
        return this.asm_.fromComponents(r);
      }
    }
    const an = k("pndtxt");
    class ms {
      constructor(s, r) {
        this.textViews = r.textViews, this.element = s.createElement("div"), this.element.classList.add(an()), this.textViews.forEach((l) => {
          const v = s.createElement("div");
          v.classList.add(an("a")), v.appendChild(l.element), this.element.appendChild(v);
        });
      }
    }
    function ni(o, s, r) {
      return new $s(o, {
        arrayPosition: r === 0 ? "fst" : r === s.axes.length - 1 ? "lst" : "mid",
        baseStep: s.axes[r].baseStep,
        parser: s.parser,
        props: s.axes[r].textProps,
        value: J(0, {
          constraint: s.axes[r].constraint
        }),
        viewProps: s.viewProps
      });
    }
    class In {
      constructor(s, r) {
        this.value = r.value, this.viewProps = r.viewProps, this.acs_ = r.axes.map((l, v) => ni(s, r, v)), this.acs_.forEach((l, v) => {
          jt({
            primary: this.value,
            secondary: l.value,
            forward: (w) => r.assembly.toComponents(w.rawValue)[v],
            backward: (w, P) => {
              const A = r.assembly.toComponents(w.rawValue);
              return A[v] = P.rawValue, r.assembly.fromComponents(A);
            }
          });
        }), this.view = new ms(s, {
          textViews: this.acs_.map((l) => l.view)
        });
      }
    }
    function si(o, s) {
      return "step" in o && !b(o.step) ? new Pe(o.step, s) : null;
    }
    function ii(o) {
      return "max" in o && !b(o.max) || "min" in o && !b(o.min) ? new ht({
        max: o.max,
        min: o.min
      }) : null;
    }
    const ri = {
      monitor: {
        defaultInterval: 200,
        defaultLineCount: 3
      }
    }, Qe = k("grl");
    class oi {
      constructor(s, r) {
        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = s.createElement("div"), this.element.classList.add(Qe()), r.viewProps.bindClassModifiers(this.element), this.formatter_ = r.formatter, this.props_ = r.props, this.cursor_ = r.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
        const l = s.createElementNS(H, "svg");
        l.classList.add(Qe("g")), l.style.height = `calc(var(--bld-us) * ${r.lineCount})`, this.element.appendChild(l), this.svgElem_ = l;
        const v = s.createElementNS(H, "polyline");
        this.svgElem_.appendChild(v), this.lineElem_ = v;
        const w = s.createElement("div");
        w.classList.add(Qe("t"), k("tt")()), this.element.appendChild(w), this.tooltipElem_ = w, r.value.emitter.on("change", this.onValueUpdate_), this.value = r.value, this.update_();
      }
      get graphElement() {
        return this.svgElem_;
      }
      update_() {
        const s = this.svgElem_.getBoundingClientRect(), r = this.value.rawValue.length - 1, l = this.props_.get("minValue"), v = this.props_.get("maxValue"), w = [];
        this.value.rawValue.forEach((He, $n) => {
          if (He === void 0)
            return;
          const qn = Q($n, 0, r, 0, s.width), ot = Q(He, l, v, s.height, 0);
          w.push([qn, ot].join(","));
        }), this.lineElem_.setAttributeNS(null, "points", w.join(" "));
        const P = this.tooltipElem_, A = this.value.rawValue[this.cursor_.rawValue];
        if (A === void 0) {
          P.classList.remove(Qe("t", "a"));
          return;
        }
        const O = Q(this.cursor_.rawValue, 0, r, 0, s.width), le = Q(A, l, v, s.height, 0);
        P.style.left = `${O}px`, P.style.top = `${le}px`, P.textContent = `${this.formatter_(A)}`, P.classList.contains(Qe("t", "a")) || (P.classList.add(Qe("t", "a"), Qe("t", "in")), re2(P), P.classList.remove(Qe("t", "in")));
      }
      onValueUpdate_() {
        this.update_();
      }
      onCursorChange_() {
        this.update_();
      }
    }
    class ai {
      constructor(s, r) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = r.props, this.value = r.value, this.viewProps = r.viewProps, this.cursor_ = J(-1), this.view = new oi(s, {
          cursor: this.cursor_,
          formatter: r.formatter,
          lineCount: r.lineCount,
          props: this.props_,
          value: this.value,
          viewProps: this.viewProps
        }), !Jt(s))
          this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
          const l = new Ze(this.view.element);
          l.emitter.on("down", this.onGraphPointerDown_), l.emitter.on("move", this.onGraphPointerMove_), l.emitter.on("up", this.onGraphPointerUp_);
        }
      }
      onGraphMouseLeave_() {
        this.cursor_.rawValue = -1;
      }
      onGraphMouseMove_(s) {
        const r = this.view.element.getBoundingClientRect();
        this.cursor_.rawValue = Math.floor(Q(s.offsetX, 0, r.width, 0, this.value.rawValue.length));
      }
      onGraphPointerDown_(s) {
        this.onGraphPointerMove_(s);
      }
      onGraphPointerMove_(s) {
        if (!s.data.point) {
          this.cursor_.rawValue = -1;
          return;
        }
        this.cursor_.rawValue = Math.floor(Q(s.data.point.x, 0, s.data.bounds.width, 0, this.value.rawValue.length));
      }
      onGraphPointerUp_() {
        this.cursor_.rawValue = -1;
      }
    }
    class li {
      constructor(s) {
        this.controller_ = s;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(s) {
        this.controller_.viewProps.set("disabled", s);
      }
      get title() {
        var s;
        return (s = this.controller_.props.get("title")) !== null && s !== void 0 ? s : "";
      }
      set title(s) {
        this.controller_.props.set("title", s);
      }
      on(s, r) {
        const l = r.bind(this);
        return this.controller_.emitter.on(s, () => {
          l(new d(this));
        }), this;
      }
    }
    class ci extends d {
      constructor(s, r, l) {
        super(s), this.cell = r, this.index = l;
      }
    }
    class pi extends a {
      constructor(s) {
        super(s), this.cellToApiMap_ = /* @__PURE__ */ new Map(), this.emitter_ = new E();
        const r = this.controller_.valueController;
        r.cellControllers.forEach((l, v) => {
          const w = new li(l);
          this.cellToApiMap_.set(l, w), l.emitter.on("click", () => {
            const P = v % r.size[0], A = Math.floor(v / r.size[0]);
            this.emitter_.emit("click", {
              event: new ci(this, w, [P, A])
            });
          });
        });
      }
      cell(s, r) {
        const l = this.controller_.valueController, v = l.cellControllers[r * l.size[0] + s];
        return this.cellToApiMap_.get(v);
      }
      on(s, r) {
        const l = r.bind(this);
        return this.emitter_.on(s, (v) => {
          l(v.event);
        }), this;
      }
    }
    class vs {
      constructor(s, r) {
        this.size = r.size;
        const [l, v] = this.size, w = [];
        for (let P = 0; P < v; P++)
          for (let A = 0; A < l; A++) {
            const O = new te(s, {
              props: ne.fromObject(Object.assign({}, r.cellConfig(A, P))),
              viewProps: Ae.create()
            });
            w.push(O);
          }
        this.cellCs_ = w, this.viewProps = Ae.create(), this.viewProps.handleDispose(() => {
          this.cellCs_.forEach((P) => {
            P.viewProps.set("disposed", true);
          });
        }), this.view = new tt(s, {
          viewProps: this.viewProps,
          viewName: "btngrid"
        }), this.view.element.style.gridTemplateColumns = `repeat(${l}, 1fr)`, this.cellCs_.forEach((P) => {
          this.view.element.appendChild(P.view.element);
        });
      }
      get cellControllers() {
        return this.cellCs_;
      }
    }
    const ui = {
      id: "buttongrid",
      type: "blade",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept(o) {
        const s = X, r = j(o, {
          cells: s.required.function,
          size: s.required.array(s.required.number),
          view: s.required.constant("buttongrid"),
          label: s.optional.string
        });
        return r ? { params: r } : null;
      },
      controller(o) {
        return new et(o.document, {
          blade: o.blade,
          props: ne.fromObject({
            label: o.params.label
          }),
          valueController: new vs(o.document, {
            cellConfig: o.params.cells,
            size: o.params.size
          })
        });
      },
      api(o) {
        return !(o.controller instanceof et) || !(o.controller.valueController instanceof vs) ? null : new pi(o.controller);
      }
    };
    class di extends a {
      get label() {
        return this.controller_.props.get("label");
      }
      set label(s) {
        this.controller_.props.set("label", s);
      }
      get value() {
        return this.controller_.valueController.value.rawValue;
      }
      set value(s) {
        this.controller_.valueController.value.rawValue = s;
      }
      on(s, r) {
        const l = r.bind(this);
        return this.controller_.valueController.value.emitter.on(s, (v) => {
          l(new m(this, v.rawValue, void 0, v.options.last));
        }), this;
      }
    }
    function Me(o, s, r) {
      return o * (1 - r) + s * r;
    }
    const fs = 20, hi = 1e-3, On = 100;
    function mi(o, s) {
      let r = 0.25, l = 0.5, v = -1;
      for (let w = 0; w < fs; w++) {
        const [P, A] = o.curve(l);
        if (l += r * (P < s ? 1 : -1), v = A, r *= 0.5, Math.abs(s - P) < hi)
          break;
      }
      return v;
    }
    class je {
      constructor(s = 0, r = 0, l = 1, v = 1) {
        this.cache_ = [], this.comps_ = [s, r, l, v];
      }
      get x1() {
        return this.comps_[0];
      }
      get y1() {
        return this.comps_[1];
      }
      get x2() {
        return this.comps_[2];
      }
      get y2() {
        return this.comps_[3];
      }
      static isObject(s) {
        return b(s) || !Array.isArray(s) ? false : typeof s[0] == "number" && typeof s[1] == "number" && typeof s[2] == "number" && typeof s[3] == "number";
      }
      static equals(s, r) {
        return s.x1 === r.x1 && s.y1 === r.y1 && s.x2 === r.x2 && s.y2 === r.y2;
      }
      curve(s) {
        const r = Me(0, this.x1, s), l = Me(0, this.y1, s), v = Me(this.x1, this.x2, s), w = Me(this.y1, this.y2, s), P = Me(this.x2, 1, s), A = Me(this.y2, 1, s), O = Me(r, v, s), le = Me(l, w, s), He = Me(v, P, s), $n = Me(w, A, s);
        return [Me(O, He, s), Me(le, $n, s)];
      }
      y(s) {
        if (this.cache_.length === 0) {
          const r = [];
          for (let l = 0; l < On; l++)
            r.push(mi(this, Q(l, 0, On - 1, 0, 1)));
          this.cache_ = r;
        }
        return this.cache_[Math.round(Q(Se(s, 0, 1), 0, 1, 0, On - 1))];
      }
      toObject() {
        return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]];
      }
    }
    const bs = {
      toComponents: (o) => o.toObject(),
      fromComponents: (o) => new je(...o)
    };
    function Be(o) {
      const s = ce(2);
      return `cubic-bezier(${o.toObject().map((l) => s(l)).join(", ")})`;
    }
    const Dn = [0, 0.5, 0.5, 1];
    function vi(o) {
      const s = o.match(/^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/);
      if (!s)
        return new je(...Dn);
      const r = [s[1], s[2], s[3], s[4]].reduce((l, v) => {
        if (!l)
          return null;
        const w = Number(v);
        return isNaN(w) ? null : [...l, w];
      }, []);
      return new je(...r != null ? r : Dn);
    }
    const se = k("cbz");
    class fi {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(se()), r.viewProps.bindClassModifiers(this.element), r.foldable.bindExpandedClass(this.element, se(void 0, "expanded")), N(r.foldable, "completed", q(this.element, se(void 0, "cpl")));
        const l = s.createElement("div");
        l.classList.add(se("h")), this.element.appendChild(l);
        const v = s.createElement("button");
        v.classList.add(se("b")), r.viewProps.bindDisabled(v);
        const w = s.createElementNS(H, "svg");
        w.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>', v.appendChild(w), l.appendChild(v), this.buttonElement = v;
        const P = s.createElement("div");
        if (P.classList.add(se("t")), l.appendChild(P), this.textElement = P, r.pickerLayout === "inline") {
          const A = s.createElement("div");
          A.classList.add(se("p")), this.element.appendChild(A), this.pickerElement = A;
        } else
          this.pickerElement = null;
      }
    }
    const _t = k("cbzp");
    class _s {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(_t()), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElement("div");
        l.classList.add(_t("g")), this.element.appendChild(l), this.graphElement = l;
        const v = s.createElement("div");
        v.classList.add(_t("t")), this.element.appendChild(v), this.textElement = v;
      }
    }
    function ln(o, s) {
      const r = new MutationObserver((v) => {
        for (const w of v)
          w.type === "childList" && w.addedNodes.forEach((P) => {
            !P.contains(P) || (s(), r.disconnect());
          });
      }), l = o.ownerDocument;
      r.observe(l.body, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }
    const Ue = k("cbzg");
    function bi(o, s) {
      return (r) => s(o(r));
    }
    class _i {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(Ue()), r.viewProps.bindClassModifiers(this.element), r.viewProps.bindTabIndex(this.element);
        const l = s.createElement("div");
        l.classList.add(Ue("p")), this.element.appendChild(l), this.previewElement = l;
        const v = s.createElementNS(H, "svg");
        v.classList.add(Ue("g")), this.element.appendChild(v), this.svgElem_ = v;
        const w = s.createElementNS(H, "path");
        w.classList.add(Ue("u")), this.svgElem_.appendChild(w), this.guideElem_ = w;
        const P = s.createElementNS(H, "polyline");
        P.classList.add(Ue("l")), this.svgElem_.appendChild(P), this.lineElem_ = P, this.handleElems_ = [s.createElement("div"), s.createElement("div")], this.handleElems_.forEach((A) => {
          A.classList.add(Ue("h")), this.element.appendChild(A);
        }), this.vectorElems_ = [
          s.createElementNS(H, "line"),
          s.createElementNS(H, "line")
        ], this.vectorElems_.forEach((A) => {
          A.classList.add(Ue("v")), this.svgElem_.appendChild(A);
        }), this.value_ = r.value, this.value_.emitter.on("change", this.onValueChange_.bind(this)), this.sel_ = r.selection, this.handleElems_.forEach((A, O) => {
          D(this.sel_, bi((le) => le === O, q(A, Ue("h", "sel"))));
        }), ln(this.element, () => {
          this.refresh();
        });
      }
      getVertMargin_(s) {
        return s * 0.25;
      }
      valueToPosition(s, r) {
        const l = this.element.getBoundingClientRect(), v = l.width, w = l.height, P = this.getVertMargin_(w);
        return {
          x: Q(s, 0, 1, 0, v),
          y: Q(r, 0, 1, w - P, P)
        };
      }
      positionToValue(s, r) {
        const l = this.element.getBoundingClientRect(), v = l.width, w = l.height, P = this.getVertMargin_(w);
        return {
          x: Se(Q(s, 0, v, 0, 1), 0, 1),
          y: Q(r, w - P, P, 0, 1)
        };
      }
      refresh() {
        this.guideElem_.setAttributeNS(null, "d", [0, 1].map((w) => {
          const P = this.valueToPosition(0, w), A = this.valueToPosition(1, w);
          return [`M ${P.x},${P.y}`, `L ${A.x},${A.y}`].join(" ");
        }).join(" "));
        const s = this.value_.rawValue, r = [];
        let l = 0;
        for (; ; ) {
          const w = this.valueToPosition(...s.curve(l));
          if (r.push([w.x, w.y].join(",")), l >= 1)
            break;
          l = Math.min(l + 0.05, 1);
        }
        this.lineElem_.setAttributeNS(null, "points", r.join(" "));
        const v = s.toObject();
        [0, 1].forEach((w) => {
          const P = this.valueToPosition(w, w), A = this.valueToPosition(v[w * 2], v[w * 2 + 1]), O = this.vectorElems_[w];
          O.setAttributeNS(null, "x1", String(P.x)), O.setAttributeNS(null, "y1", String(P.y)), O.setAttributeNS(null, "x2", String(A.x)), O.setAttributeNS(null, "y2", String(A.y));
          const le = this.handleElems_[w];
          le.style.left = `${A.x}px`, le.style.top = `${A.y}px`;
        });
      }
      onValueChange_() {
        this.refresh();
      }
    }
    const gs = 24, gt = 400, me = 1e3, Re = k("cbzprv");
    class ze {
      constructor(s, r) {
        this.stopped_ = true, this.startTime_ = -1, this.onDispose_ = this.onDispose_.bind(this), this.onTimer_ = this.onTimer_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.element = s.createElement("div"), this.element.classList.add(Re()), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElementNS(H, "svg");
        l.classList.add(Re("g")), this.element.appendChild(l), this.svgElem_ = l;
        const v = s.createElementNS(H, "path");
        v.classList.add(Re("t")), this.svgElem_.appendChild(v), this.ticksElem_ = v;
        const w = s.createElement("div");
        w.classList.add(Re("m")), this.element.appendChild(w), this.markerElem_ = w, this.value_ = r.value, this.value_.emitter.on("change", this.onValueChange_), r.viewProps.handleDispose(this.onDispose_), ln(this.element, () => {
          this.refresh();
        });
      }
      play() {
        this.stop(), this.updateMarker_(0), this.markerElem_.classList.add(Re("m", "a")), this.startTime_ = new Date().getTime() + gt, this.stopped_ = false, requestAnimationFrame(this.onTimer_);
      }
      stop() {
        this.stopped_ = true, this.markerElem_.classList.remove(Re("m", "a"));
      }
      onDispose_() {
        this.stop();
      }
      updateMarker_(s) {
        const r = this.value_.rawValue.y(Se(s, 0, 1));
        this.markerElem_.style.left = `${r * 100}%`;
      }
      refresh() {
        const s = this.svgElem_.getBoundingClientRect(), r = s.width, l = s.height, v = [], w = this.value_.rawValue;
        for (let P = 0; P < gs; P++) {
          const A = Q(P, 0, gs - 1, 0, 1), O = Q(w.y(A), 0, 1, 0, r);
          v.push(`M ${O},0 v${l}`);
        }
        this.ticksElem_.setAttributeNS(null, "d", v.join(" "));
      }
      onTimer_() {
        if (this.startTime_ === null)
          return;
        const s = new Date().getTime() - this.startTime_, r = s / me;
        this.updateMarker_(r), s > me + gt && this.stop(), this.stopped_ || requestAnimationFrame(this.onTimer_);
      }
      onValueChange_() {
        this.refresh(), this.play();
      }
    }
    function Fn(o, s, r, l) {
      const v = r - o, w = l - s;
      return Math.sqrt(v * v + w * w);
    }
    function ws(o, s, r, l) {
      const v = Fn(o, s, r, l), w = Math.atan2(l - s, r - o), P = Math.round(w / (Math.PI / 4)) * Math.PI / 4;
      return {
        x: o + Math.cos(P) * v,
        y: s + Math.sin(P) * v
      };
    }
    class jn {
      constructor(s, r) {
        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = r.baseStep, this.value = r.value, this.sel_ = J(0), this.viewProps = r.viewProps, this.view = new _i(s, {
          selection: this.sel_,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_), this.prevView_ = new ze(s, {
          value: this.value,
          viewProps: this.viewProps
        }), this.prevView_.element.addEventListener("mousedown", (v) => {
          v.stopImmediatePropagation(), v.preventDefault(), this.prevView_.play();
        }), this.view.previewElement.appendChild(this.prevView_.element);
        const l = new Ze(this.view.element);
        l.emitter.on("down", this.onPointerDown_), l.emitter.on("move", this.onPointerMove_), l.emitter.on("up", this.onPointerUp_);
      }
      refresh() {
        this.view.refresh(), this.prevView_.refresh(), this.prevView_.play();
      }
      updateValue_(s, r, l) {
        const v = this.sel_.rawValue, w = this.value.rawValue.toObject(), P = this.view.positionToValue(s.x, s.y), A = r ? ws(v, v, P.x, P.y) : P;
        w[v * 2] = A.x, w[v * 2 + 1] = A.y, this.value.setRawValue(new je(...w), l);
      }
      onPointerDown_(s) {
        const r = s.data;
        if (!r.point)
          return;
        const l = this.value.rawValue, v = this.view.valueToPosition(l.x1, l.y1), w = Fn(r.point.x, r.point.y, v.x, v.y), P = this.view.valueToPosition(l.x2, l.y2), A = Fn(r.point.x, r.point.y, P.x, P.y);
        this.sel_.rawValue = w <= A ? 0 : 1, this.updateValue_(r.point, s.shiftKey, {
          forceEmit: false,
          last: false
        });
      }
      onPointerMove_(s) {
        const r = s.data;
        !r.point || this.updateValue_(r.point, s.shiftKey, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(s) {
        const r = s.data;
        !r.point || this.updateValue_(r.point, s.shiftKey, {
          forceEmit: true,
          last: true
        });
      }
      onKeyDown_(s) {
        cs(s.key) && s.preventDefault();
        const r = this.sel_.rawValue, l = this.value.rawValue.toObject();
        l[r * 2] += ft(this.baseStep_, Sn(s)), l[r * 2 + 1] += ft(this.baseStep_, Bt(s)), this.value.setRawValue(new je(...l), {
          forceEmit: false,
          last: false
        });
      }
      onKeyUp_(s) {
        cs(s.key) && s.preventDefault();
        const r = ft(this.baseStep_, Sn(s)), l = ft(this.baseStep_, Bt(s));
        r === 0 && l === 0 || this.value.setRawValue(this.value.rawValue, {
          forceEmit: true,
          last: true
        });
      }
    }
    class it {
      constructor(s, r) {
        this.value = r.value, this.viewProps = r.viewProps, this.view = new _s(s, {
          viewProps: this.viewProps
        }), this.gc_ = new jn(s, {
          baseStep: r.axis.baseStep,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.graphElement.appendChild(this.gc_.view.element);
        const l = Object.assign(Object.assign({}, r.axis), { constraint: new ht({ max: 1, min: 0 }) }), v = Object.assign(Object.assign({}, r.axis), { constraint: void 0 });
        this.tc_ = new In(s, {
          assembly: bs,
          axes: [l, v, l, v],
          parser: Ft,
          value: this.value,
          viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.tc_.view.element);
      }
      get allFocusableElements() {
        return [
          this.gc_.view.element,
          ...this.tc_.view.textViews.map((s) => s.inputElement)
        ];
      }
      refresh() {
        this.gc_.refresh();
      }
    }
    class ee {
      constructor(s, r) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = r.value, this.viewProps = r.viewProps, this.foldable_ = xn(r.expanded), this.view = new fi(s, {
          foldable: this.foldable_,
          pickerLayout: r.pickerLayout,
          viewProps: this.viewProps
        }), this.view.buttonElement.addEventListener("blur", this.onButtonBlur_), this.view.buttonElement.addEventListener("click", this.onButtonClick_), this.tc_ = new G(s, {
          parser: vi,
          props: ne.fromObject({
            formatter: Be
          }),
          value: this.value,
          viewProps: this.viewProps
        }), this.view.textElement.appendChild(this.tc_.view.element), this.popC_ = r.pickerLayout === "popup" ? new C(s, {
          viewProps: this.viewProps
        }) : null;
        const l = new it(s, {
          axis: r.axis,
          value: this.value,
          viewProps: this.viewProps
        });
        l.allFocusableElements.forEach((v) => {
          v.addEventListener("blur", this.onPopupChildBlur_), v.addEventListener("keydown", this.onPopupChildKeydown_);
        }), this.pickerC_ = l, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), D(this.popC_.shows, (v) => {
          v && l.refresh();
        }), jt({
          primary: this.foldable_.value("expanded"),
          secondary: this.popC_.shows,
          forward: (v) => v.rawValue,
          backward: (v, w) => w.rawValue
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $e(this.foldable_, this.view.pickerElement));
      }
      onButtonBlur_(s) {
        if (!this.popC_)
          return;
        const r = s.relatedTarget;
        (!r || !this.popC_.view.element.contains(r)) && (this.popC_.shows.rawValue = false);
      }
      onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.allFocusableElements[0].focus();
      }
      onPopupChildBlur_(s) {
        if (!this.popC_)
          return;
        const r = this.popC_.view.element, l = At(s);
        l && r.contains(l) || l && l === this.view.buttonElement && !Jt(r.ownerDocument) || (this.popC_.shows.rawValue = false);
      }
      onPopupChildKeydown_(s) {
        !this.popC_ || s.key === "Escape" && (this.popC_.shows.rawValue = false);
      }
    }
    function xs() {
      return new ti({
        assembly: bs,
        components: [0, 1, 2, 3].map((o) => o % 2 === 0 ? new ht({
          min: 0,
          max: 1
        }) : void 0)
      });
    }
    const ae = {
      id: "cubic-bezier",
      type: "blade",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept(o) {
        const s = X, r = j(o, {
          value: s.required.array(s.required.number),
          view: s.required.constant("cubicbezier"),
          expanded: s.optional.boolean,
          label: s.optional.string,
          picker: s.optional.custom((l) => l === "inline" || l === "popup" ? l : void 0)
        });
        return r ? { params: r } : null;
      },
      controller(o) {
        var s, r;
        const l = new je(...o.params.value), v = J(l, {
          constraint: xs(),
          equals: je.equals
        }), w = new ee(o.document, {
          axis: {
            baseStep: 0.1,
            textProps: ne.fromObject({
              draggingScale: 0.01,
              formatter: ce(2)
            })
          },
          expanded: (s = o.params.expanded) !== null && s !== void 0 ? s : false,
          pickerLayout: (r = o.params.picker) !== null && r !== void 0 ? r : "popup",
          value: v,
          viewProps: o.viewProps
        });
        return new qe(o.document, {
          blade: o.blade,
          props: ne.fromObject({
            label: o.params.label
          }),
          valueController: w
        });
      },
      api(o) {
        return !(o.controller instanceof qe) || !(o.controller.valueController instanceof ee) ? null : new di(o.controller);
      }
    };
    class ys extends a {
      begin() {
        this.controller_.valueController.begin();
      }
      end() {
        this.controller_.valueController.end();
      }
    }
    const xe = 20;
    class gi {
      constructor() {
        this.start_ = null, this.duration_ = 0, this.fps_ = null, this.frameCount_ = 0, this.timestamps_ = [];
      }
      get duration() {
        return this.duration_;
      }
      get fps() {
        return this.fps_;
      }
      begin(s) {
        this.start_ = s.getTime();
      }
      calculateFps_(s) {
        if (this.timestamps_.length === 0)
          return null;
        const r = this.timestamps_[0];
        return 1e3 * (this.frameCount_ - r.frameCount) / (s - r.time);
      }
      compactTimestamps_() {
        if (this.timestamps_.length <= xe)
          return;
        const s = this.timestamps_.length - xe;
        this.timestamps_.splice(0, s);
        const r = this.timestamps_[0].frameCount;
        this.timestamps_.forEach((l) => {
          l.frameCount -= r;
        }), this.frameCount_ -= r;
      }
      end(s) {
        if (this.start_ === null)
          return;
        const r = s.getTime();
        this.duration_ = r - this.start_, this.start_ = null, this.fps_ = this.calculateFps_(r), this.timestamps_.push({
          frameCount: this.frameCount_,
          time: r
        }), ++this.frameCount_, this.compactTimestamps_();
      }
    }
    const Ke = k("fps");
    class Bn {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(Ke()), r.viewProps.bindClassModifiers(this.element), this.graphElement = s.createElement("div"), this.graphElement.classList.add(Ke("g")), this.element.appendChild(this.graphElement);
        const l = s.createElement("div");
        l.classList.add(Ke("l")), this.element.appendChild(l);
        const v = s.createElement("span");
        v.classList.add(Ke("v")), v.textContent = "--", l.appendChild(v), this.valueElement = v;
        const w = s.createElement("span");
        w.classList.add(Ke("u")), w.textContent = "FPS", l.appendChild(w);
      }
    }
    class Cs {
      constructor(s, r) {
        this.stopwatch_ = new gi(), this.onTick_ = this.onTick_.bind(this), this.ticker_ = r.ticker, this.ticker_.emitter.on("tick", this.onTick_), this.value_ = r.value, this.viewProps = r.viewProps, this.view = new Bn(s, {
          viewProps: this.viewProps
        }), this.graphC_ = new ai(s, {
          formatter: ce(0),
          lineCount: r.lineCount,
          props: ne.fromObject({
            maxValue: r.maxValue,
            minValue: r.minValue
          }),
          value: this.value_,
          viewProps: this.viewProps
        }), this.view.graphElement.appendChild(this.graphC_.view.element), this.viewProps.handleDispose(() => {
          this.graphC_.viewProps.set("disposed", true), this.ticker_.dispose();
        });
      }
      begin() {
        this.stopwatch_.begin(new Date());
      }
      end() {
        this.stopwatch_.end(new Date());
      }
      onTick_() {
        const s = this.stopwatch_.fps;
        if (s !== null) {
          const r = this.value_.rawValue;
          this.value_.rawValue = Hs(r, s), this.view.valueElement.textContent = s.toFixed(0);
        }
      }
    }
    function wi(o, s) {
      return s === 0 ? new Ye() : new Cn(o, s != null ? s : ri.monitor.defaultInterval);
    }
    const Un = {
      id: "fpsgraph",
      type: "blade",
      accept(o) {
        const s = X, r = j(o, {
          view: s.required.constant("fpsgraph"),
          interval: s.optional.number,
          label: s.optional.string,
          lineCount: s.optional.number,
          max: s.optional.number,
          min: s.optional.number
        });
        return r ? { params: r } : null;
      },
      controller(o) {
        var s, r, l, v;
        const w = (s = o.params.interval) !== null && s !== void 0 ? s : 500;
        return new et(o.document, {
          blade: o.blade,
          props: ne.fromObject({
            label: o.params.label
          }),
          valueController: new Cs(o.document, {
            lineCount: (r = o.params.lineCount) !== null && r !== void 0 ? r : 2,
            maxValue: (l = o.params.max) !== null && l !== void 0 ? l : 90,
            minValue: (v = o.params.min) !== null && v !== void 0 ? v : 0,
            ticker: wi(o.document, w),
            value: as(80),
            viewProps: o.viewProps
          })
        });
      },
      api(o) {
        return !(o.controller instanceof et) || !(o.controller.valueController instanceof Cs) ? null : new ys(o.controller);
      }
    };
    class Le {
      constructor(s, r) {
        this.min = s, this.max = r;
      }
      static isObject(s) {
        if (typeof s != "object" || s === null)
          return false;
        const r = s.min, l = s.max;
        return !(typeof r != "number" || typeof l != "number");
      }
      static equals(s, r) {
        return s.min === r.min && s.max === r.max;
      }
      get length() {
        return this.max - this.min;
      }
      toObject() {
        return {
          min: this.min,
          max: this.max
        };
      }
    }
    const cn = {
      fromComponents: (o) => new Le(o[0], o[1]),
      toComponents: (o) => [o.min, o.max]
    };
    class wt {
      constructor(s) {
        this.edge = s;
      }
      constrain(s) {
        var r, l, v, w, P, A, O, le;
        if (s.min <= s.max)
          return new Le((l = (r = this.edge) === null || r === void 0 ? void 0 : r.constrain(s.min)) !== null && l !== void 0 ? l : s.min, (w = (v = this.edge) === null || v === void 0 ? void 0 : v.constrain(s.max)) !== null && w !== void 0 ? w : s.max);
        const He = (s.min + s.max) / 2;
        return new Le((A = (P = this.edge) === null || P === void 0 ? void 0 : P.constrain(He)) !== null && A !== void 0 ? A : He, (le = (O = this.edge) === null || O === void 0 ? void 0 : O.constrain(He)) !== null && le !== void 0 ? le : He);
      }
    }
    const xt = k("rsltxt");
    class Es {
      constructor(s, r) {
        this.sliderView_ = r.sliderView, this.textView_ = r.textView, this.element = s.createElement("div"), this.element.classList.add(xt());
        const l = s.createElement("div");
        l.classList.add(xt("s")), l.appendChild(this.sliderView_.element), this.element.appendChild(l);
        const v = s.createElement("div");
        v.classList.add(xt("t")), v.appendChild(this.textView_.element), this.element.appendChild(v);
      }
    }
    const fe = k("rsl");
    class Ps {
      constructor(s, r) {
        this.maxValue_ = r.maxValue, this.minValue_ = r.minValue, this.element = s.createElement("div"), this.element.classList.add(fe()), r.viewProps.bindClassModifiers(this.element), this.value_ = r.value, this.value_.emitter.on("change", this.onValueChange_.bind(this));
        const l = s.createElement("div");
        l.classList.add(fe("t")), this.element.appendChild(l), this.trackElement = l;
        const v = s.createElement("div");
        v.classList.add(fe("b")), l.appendChild(v), this.barElement = v;
        const w = ["min", "max"].map((P) => {
          const A = s.createElement("div");
          return A.classList.add(fe("k"), fe("k", P)), l.appendChild(A), A;
        });
        this.knobElements = [w[0], w[1]], this.update();
      }
      valueToX_(s) {
        return Se(Q(s, this.minValue_, this.maxValue_, 0, 1), 0, 1) * 100;
      }
      update() {
        const s = this.value_.rawValue;
        s.length === 0 ? this.element.classList.add(fe(void 0, "zero")) : this.element.classList.remove(fe(void 0, "zero"));
        const r = [this.valueToX_(s.min), this.valueToX_(s.max)];
        this.barElement.style.left = `${r[0]}%`, this.barElement.style.right = `${100 - r[1]}%`, this.knobElements.forEach((l, v) => {
          l.style.left = `${r[v]}%`;
        });
      }
      onValueChange_() {
        this.update();
      }
    }
    class zn {
      constructor(s, r) {
        this.grabbing_ = null, this.grabOffset_ = 0, this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.maxValue_ = r.maxValue, this.minValue_ = r.minValue, this.viewProps = r.viewProps, this.value = r.value, this.view = new Ps(s, {
          maxValue: r.maxValue,
          minValue: r.minValue,
          value: this.value,
          viewProps: r.viewProps
        });
        const l = new Ze(this.view.trackElement);
        l.emitter.on("down", this.onPointerDown_), l.emitter.on("move", this.onPointerMove_), l.emitter.on("up", this.onPointerUp_);
      }
      ofs_() {
        return this.grabbing_ === "min" ? this.view.knobElements[0].getBoundingClientRect().width / 2 : this.grabbing_ === "max" ? -this.view.knobElements[1].getBoundingClientRect().width / 2 : 0;
      }
      valueFromData_(s) {
        if (!s.point)
          return null;
        const r = (s.point.x + this.ofs_()) / s.bounds.width;
        return Q(r, 0, 1, this.minValue_, this.maxValue_);
      }
      onPointerDown_(s) {
        if (!s.data.point)
          return;
        const r = s.data.point.x / s.data.bounds.width, l = this.value.rawValue, v = Q(l.min, this.minValue_, this.maxValue_, 0, 1), w = Q(l.max, this.minValue_, this.maxValue_, 0, 1);
        Math.abs(w - r) <= 0.025 ? this.grabbing_ = "max" : Math.abs(v - r) <= 0.025 ? this.grabbing_ = "min" : r >= v && r <= w ? (this.grabbing_ = "length", this.grabOffset_ = Q(r - v, 0, 1, 0, this.maxValue_ - this.minValue_)) : r < v ? (this.grabbing_ = "min", this.onPointerMove_(s)) : r > w && (this.grabbing_ = "max", this.onPointerMove_(s));
      }
      applyPointToValue_(s, r) {
        const l = this.valueFromData_(s);
        if (l !== null) {
          if (this.grabbing_ === "min")
            this.value.setRawValue(new Le(l, this.value.rawValue.max), r);
          else if (this.grabbing_ === "max")
            this.value.setRawValue(new Le(this.value.rawValue.min, l), r);
          else if (this.grabbing_ === "length") {
            const v = this.value.rawValue.length;
            let w = l - this.grabOffset_, P = w + v;
            w < this.minValue_ ? (w = this.minValue_, P = this.minValue_ + v) : P > this.maxValue_ && (w = this.maxValue_ - v, P = this.maxValue_), this.value.setRawValue(new Le(w, P), r);
          }
        }
      }
      onPointerMove_(s) {
        this.applyPointToValue_(s.data, {
          forceEmit: false,
          last: false
        });
      }
      onPointerUp_(s) {
        this.applyPointToValue_(s.data, {
          forceEmit: true,
          last: true
        }), this.grabbing_ = null;
      }
    }
    class Kn {
      constructor(s, r) {
        this.value = r.value, this.viewProps = r.viewProps, this.sc_ = new zn(s, r);
        const l = {
          baseStep: r.baseStep,
          constraint: r.constraint,
          textProps: ne.fromObject({
            draggingScale: r.draggingScale,
            formatter: r.formatter
          })
        };
        this.tc_ = new In(s, {
          assembly: cn,
          axes: [l, l],
          parser: r.parser,
          value: this.value,
          viewProps: r.viewProps
        }), this.view = new Es(s, {
          sliderView: this.sc_.view,
          textView: this.tc_.view
        });
      }
      get textController() {
        return this.tc_;
      }
    }
    function xi(o) {
      return Le.isObject(o) ? new Le(o.min, o.max) : new Le(0, 0);
    }
    function pn(o, s) {
      o.writeProperty("max", s.max), o.writeProperty("min", s.min);
    }
    function yt(o) {
      const s = [], r = ii(o);
      r && s.push(r);
      const l = si(o);
      return l && s.push(l), new wt(new Rt(s));
    }
    const Ct = {
      id: "input-interval",
      type: "input",
      css: '.tp-cbzgv,.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-radv_b,.tp-rslv_k,.tp-cbzv_b{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-radv_b:hover,.tp-rslv_k:hover,.tp-cbzv_b:hover{background-color:var(--btn-bg-h)}.tp-radv_b:focus,.tp-rslv_k:focus,.tp-cbzv_b:focus{background-color:var(--btn-bg-f)}.tp-radv_b:active,.tp-rslv_k:active,.tp-cbzv_b:active{background-color:var(--btn-bg-a)}.tp-radv_b:disabled,.tp-rslv_k:disabled,.tp-cbzv_b:disabled{opacity:.5}.tp-cbzgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-cbzgv:hover{background-color:var(--in-bg-h)}.tp-cbzgv:focus{background-color:var(--in-bg-f)}.tp-cbzgv:active{background-color:var(--in-bg-a)}.tp-cbzgv:disabled{opacity:.5}.tp-btngridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-btngridv.tp-v-disabled{opacity:.5}.tp-btngridv .tp-btnv_b:disabled{opacity:1}.tp-btngridv .tp-btnv_b:disabled .tp-btnv_t{opacity:.5}.tp-btngridv .tp-btnv_b{border-radius:0}.tp-cbzv{position:relative}.tp-cbzv_h{display:flex}.tp-cbzv_b{margin-right:4px;position:relative;width:var(--bld-us)}.tp-cbzv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-cbzv_b svg path{stroke:var(--bs-bg);stroke-width:2}.tp-cbzv_t{flex:1}.tp-cbzv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-cbzv.tp-cbzv-expanded .tp-cbzv_p{margin-top:var(--bld-s);opacity:1}.tp-cbzv.tp-cbzv-cpl .tp-cbzv_p{overflow:visible}.tp-cbzv .tp-popv{left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-cbzpv_t{margin-top:var(--bld-s)}.tp-cbzgv{height:auto;overflow:hidden;position:relative}.tp-cbzgv.tp-v-disabled{opacity:.5}.tp-cbzgv_p{left:16px;position:absolute;right:16px;top:0}.tp-cbzgv_g{cursor:pointer;display:block;height:calc(var(--bld-us)*5);width:100%}.tp-cbzgv_u{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_l{fill:rgba(0,0,0,0);stroke:var(--in-fg)}.tp-cbzgv_v{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-cbzgv_h{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;pointer-events:none;position:absolute;width:4px}.tp-cbzgv:focus .tp-cbzgv_h-sel{background-color:var(--in-fg);border-width:0}.tp-cbzprvv{cursor:pointer;height:4px;padding:4px 0;position:relative}.tp-cbzprvv_g{display:block;height:100%;overflow:visible;width:100%}.tp-cbzprvv_t{opacity:.5;stroke:var(--mo-fg)}.tp-cbzprvv_m{background-color:var(--mo-fg);border-radius:50%;height:4px;margin-left:-2px;margin-top:-2px;opacity:0;position:absolute;top:50%;transition:opacity .2s ease-out;width:4px}.tp-cbzprvv_m.tp-cbzprvv_m-a{opacity:1}.tp-fpsv{position:relative}.tp-fpsv_l{bottom:4px;color:var(--mo-fg);line-height:1;right:4px;pointer-events:none;position:absolute}.tp-fpsv_u{margin-left:.2em;opacity:.7}.tp-rslv{cursor:pointer;padding-left:8px;padding-right:8px}.tp-rslv.tp-v-disabled{opacity:.5}.tp-rslv_t{height:calc(var(--bld-us));position:relative}.tp-rslv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:-4px;right:-4px}.tp-rslv_b{bottom:0;top:0;position:absolute}.tp-rslv_b::before{background-color:var(--in-fg);content:"";height:2px;margin-top:-1px;position:absolute;top:50%;left:0;right:0}.tp-rslv_k{height:calc(var(--bld-us) - 8px);margin-top:calc((var(--bld-us) - 8px)/-2);position:absolute;top:50%;width:8px}.tp-rslv_k.tp-rslv_k-min{margin-left:-8px}.tp-rslv_k.tp-rslv_k-max{margin-left:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-min{border-bottom-right-radius:0;border-top-right-radius:0}.tp-rslv.tp-rslv-zero .tp-rslv_k.tp-rslv_k-max{border-bottom-left-radius:0;border-top-left-radius:0}.tp-rsltxtv{display:flex}.tp-rsltxtv_s{flex:1}.tp-rsltxtv_t{flex:1;margin-left:4px}.tp-radv_l{display:block;position:relative}.tp-radv_i{left:0;opacity:0;position:absolute;top:0}.tp-radv_b{opacity:.5}.tp-radv_i:hover+.tp-radv_b{background-color:var(--btn-bg-h)}.tp-radv_i:focus+.tp-radv_b{background-color:var(--btn-bg-f)}.tp-radv_i:active+.tp-radv_b{background-color:var(--btn-bg-a)}.tp-radv_i:checked+.tp-radv_b{opacity:1}.tp-radv_t{bottom:0;color:inherit;left:0;overflow:hidden;position:absolute;right:0;text-align:center;text-overflow:ellipsis;top:0}.tp-radv_i:disabled+.tp-radv_b>.tp-radv_t{opacity:.5}.tp-radgridv{border-radius:var(--elm-br);display:grid;overflow:hidden;gap:2px}.tp-radgridv.tp-v-disabled{opacity:.5}.tp-radgridv .tp-radv_b{border-radius:0}',
      accept: (o, s) => {
        if (!Le.isObject(o))
          return null;
        const r = X, l = j(s, {
          format: r.optional.function,
          max: r.optional.number,
          min: r.optional.number,
          step: r.optional.number
        });
        return l ? {
          initialValue: new Le(o.min, o.max),
          params: l
        } : null;
      },
      binding: {
        reader: (o) => xi,
        constraint: (o) => yt(o.params),
        equals: Le.equals,
        writer: (o) => pn
      },
      controller(o) {
        var s;
        const r = o.value, l = o.constraint;
        if (!(l instanceof wt))
          throw x.shouldNeverHappen();
        const v = (r.rawValue.min + r.rawValue.max) / 2, w = (s = o.params.format) !== null && s !== void 0 ? s : ce(qs(l.edge, v)), P = l.edge && Ve(l.edge, ht);
        if ((P == null ? void 0 : P.minValue) !== void 0 && (P == null ? void 0 : P.maxValue) !== void 0)
          return new Kn(o.document, {
            baseStep: Rn(l.edge),
            constraint: l.edge,
            draggingScale: us(P, v),
            formatter: w,
            maxValue: P.maxValue,
            minValue: P.minValue,
            parser: Ft,
            value: r,
            viewProps: o.viewProps
          });
        const A = {
          baseStep: Rn(l.edge),
          constraint: l.edge,
          textProps: ne.fromObject({
            draggingScale: v,
            formatter: w
          })
        };
        return new In(o.document, {
          assembly: cn,
          axes: [A, A],
          parser: Ft,
          value: r,
          viewProps: o.viewProps
        });
      }
    };
    class un {
      constructor(s) {
        this.controller_ = s;
      }
      get disabled() {
        return this.controller_.viewProps.get("disabled");
      }
      set disabled(s) {
        this.controller_.viewProps.set("disabled", s);
      }
      get title() {
        var s;
        return (s = this.controller_.props.get("title")) !== null && s !== void 0 ? s : "";
      }
      set title(s) {
        this.controller_.props.set("title", s);
      }
    }
    class yi extends m {
      constructor(s, r, l, v, w) {
        super(s, v, w), this.cell = r, this.index = l;
      }
    }
    class Ci extends a {
      constructor(s) {
        super(s), this.cellToApiMap_ = /* @__PURE__ */ new Map(), this.controller_.valueController.cellControllers.forEach((l) => {
          const v = new un(l);
          this.cellToApiMap_.set(l, v);
        });
      }
      get value() {
        return this.controller_.value;
      }
      cell(s, r) {
        const l = this.controller_.valueController, v = l.cellControllers[r * l.size[0] + s];
        return this.cellToApiMap_.get(v);
      }
      on(s, r) {
        const l = r.bind(this);
        this.controller_.value.emitter.on(s, (v) => {
          const w = this.controller_.valueController, P = w.findCellByValue(v.rawValue);
          if (!P)
            return;
          const A = this.cellToApiMap_.get(P);
          if (!A)
            return;
          const O = w.cellControllers.indexOf(P);
          l(new yi(this, A, [O % w.size[0], Math.floor(O / w.size[0])], v.rawValue, void 0));
        });
      }
    }
    const Ht = k("rad");
    class Ei {
      constructor(s, r) {
        this.element = s.createElement("div"), this.element.classList.add(Ht()), r.viewProps.bindClassModifiers(this.element);
        const l = s.createElement("label");
        l.classList.add(Ht("l")), this.element.appendChild(l);
        const v = s.createElement("input");
        v.classList.add(Ht("i")), v.name = r.name, v.type = "radio", r.viewProps.bindDisabled(v), l.appendChild(v), this.inputElement = v;
        const w = s.createElement("div");
        w.classList.add(Ht("b")), l.appendChild(w);
        const P = s.createElement("div");
        P.classList.add(Ht("t")), w.appendChild(P), N(r.props, "title", (A) => {
          P.textContent = A;
        });
      }
    }
    class rt {
      constructor(s, r) {
        this.props = r.props, this.viewProps = r.viewProps, this.view = new Ei(s, {
          name: r.name,
          props: this.props,
          viewProps: this.viewProps
        });
      }
    }
    class Hn {
      constructor(s, r) {
        this.cellCs_ = [], this.cellValues_ = [], this.onCellInputChange_ = this.onCellInputChange_.bind(this), this.size = r.size;
        const [l, v] = this.size;
        for (let w = 0; w < v; w++)
          for (let P = 0; P < l; P++) {
            const A = new rt(s, {
              name: r.groupName,
              props: ne.fromObject(Object.assign({}, r.cellConfig(P, w))),
              viewProps: Ae.create()
            });
            this.cellCs_.push(A), this.cellValues_.push(r.cellConfig(P, w).value);
          }
        this.value = r.value, D(this.value, (w) => {
          const P = this.findCellByValue(w);
          !P || (P.view.inputElement.checked = true);
        }), this.viewProps = Ae.create(), this.view = new tt(s, {
          viewProps: this.viewProps,
          viewName: "radgrid"
        }), this.view.element.style.gridTemplateColumns = `repeat(${l}, 1fr)`, this.cellCs_.forEach((w) => {
          w.view.inputElement.addEventListener("change", this.onCellInputChange_), this.view.element.appendChild(w.view.element);
        });
      }
      get cellControllers() {
        return this.cellCs_;
      }
      findCellByValue(s) {
        const r = this.cellValues_.findIndex((l) => l === s);
        return r < 0 ? null : this.cellCs_[r];
      }
      onCellInputChange_(s) {
        const r = s.currentTarget, l = this.cellCs_.findIndex((v) => v.view.inputElement === r);
        l < 0 || (this.value.rawValue = this.cellValues_[l]);
      }
    }
    const Pi = function() {
      return {
        id: "radiogrid",
        type: "blade",
        accept(o) {
          const s = X, r = j(o, {
            cells: s.required.function,
            groupName: s.required.string,
            size: s.required.array(s.required.number),
            value: s.required.raw,
            view: s.required.constant("radiogrid"),
            label: s.optional.string
          });
          return r ? { params: r } : null;
        },
        controller(o) {
          return new qe(o.document, {
            blade: o.blade,
            props: ne.fromObject({
              label: o.params.label
            }),
            valueController: new Hn(o.document, {
              groupName: o.params.groupName,
              cellConfig: o.params.cells,
              size: o.params.size,
              value: J(o.params.value)
            })
          });
        },
        api(o) {
          return !(o.controller instanceof qe) || !(o.controller.valueController instanceof Hn) ? null : new Ci(o.controller);
        }
      };
    }();
    function Gn(o) {
      return {
        id: "input-radiogrid",
        type: "input",
        accept(s, r) {
          if (!o.isType(s))
            return null;
          const l = X, v = j(r, {
            cells: l.required.function,
            groupName: l.required.string,
            size: l.required.array(l.required.number),
            view: l.required.constant("radiogrid")
          });
          return v ? {
            initialValue: s,
            params: v
          } : null;
        },
        binding: o.binding,
        controller: (s) => new Hn(s.document, {
          cellConfig: s.params.cells,
          groupName: s.params.groupName,
          size: s.params.size,
          value: s.value
        })
      };
    }
    const ki = Gn({
      isType: (o) => typeof o == "number",
      binding: {
        reader: (o) => We,
        writer: (o) => st
      }
    }), ks = Gn({
      isType: (o) => typeof o == "string",
      binding: {
        reader: (o) => os,
        writer: (o) => st
      }
    }), Ti = Gn({
      isType: (o) => typeof o == "boolean",
      binding: {
        reader: (o) => oe,
        writer: (o) => st
      }
    }), Mi = [
      ui,
      ae,
      Un,
      Ct,
      Pi,
      Ti,
      ki,
      ks
    ];
    p.CubicBezier = je, p.plugins = Mi, Object.defineProperty(p, "__esModule", { value: true });
  });
})(Vs, Vs.exports);
var Lc = kc(Vs.exports);
var Sc = Yl({
  __proto__: null,
  default: Lc
}, [Vs.exports]);
var gn;
var Ms;
var Dc = (T = "tres-container") => {
  gn = new tr.exports.Pane({
    container: document.querySelector(T) || void 0
  }), gn.registerPlugin(Sc), Ms = gn.addBlade({
    view: "fpsgraph",
    label: "fpsgraph"
  });
  function u() {
    gn && gn.dispose();
  }
  return onMounted(() => {
    const { onBeforeLoop: p, onAfterLoop: a, resume: d } = re();
    d(), p(() => Ms.begin()), a(() => Ms.end());
  }), onUnmounted(() => {
    u();
  }), { pane: gn, fpsGraph: Ms, disposeTweakPane: u };
};
var Yi = null;
function Ac(T, u) {
  return (p) => {
    u && u(p), Yi || (Yi = new Tc()), Yi.setDecoderPath(T.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/");
  };
}
async function Vc(T, u = {
  draco: false
}, p) {
  return await Je(Wl, T, Ac(u, p));
}
var Fc = defineComponent({
  name: "GLTFModel",
  props: {
    path: String,
    draco: Boolean
  },
  async setup(T) {
    const u = inject("local-scene"), { scene: p } = await Vc(T.path, { draco: T.draco });
    return u != null && u.value && u.value.add(p), () => null;
  }
});
export {
  Fc as GLTFModel,
  Oc as OrbitControls,
  Vc as useGLTF,
  Dc as useTweakPane
};
/*! Tweakpane 3.1.0 (c) 2016 cocopon, licensed under the MIT license. */
//# sourceMappingURL=@tresjs_cientos.js.map
