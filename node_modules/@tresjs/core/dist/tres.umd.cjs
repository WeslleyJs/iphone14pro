/**
 * name: @tresjs/core
 * version: v1.0.0
 * (c) 2022
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
(function(u,o){typeof exports=="object"&&typeof module<"u"?o(exports,require("vue"),require("@vueuse/core"),require("three")):typeof define=="function"&&define.amd?define(["exports","vue","@vueuse/core","three"],o):(u=typeof globalThis<"u"?globalThis:u||self,o(u.tres={},u.Vue,u.VueUseCore,u.Three))})(this,function(u,o,p,g){"use strict";function te(e){if(e&&e.__esModule)return e;const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const n in e)if(n!=="default"){const r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:()=>e[n]})}}return t.default=e,Object.freeze(t)}const ne=te(g);var V=(e=>(e.Perspective="Perspective",e.Orthographic="Orthographic",e))(V||{});const j={cameras:[]},re=45;let b;function z(){const{width:e,height:t}=p.useWindowSize(),{setState:n}=F();function r(c="Perspective",h){if(c==="Perspective"){const{near:f,far:w,fov:C}=h||{near:.1,far:1e3,fov:re};b=new g.PerspectiveCamera(C,a.value,f,w),j.cameras.push(b)}else{const{left:f,right:w,top:C,bottom:M,near:P,far:x}=h||{left:-100,right:100,top:100,bottom:-100,near:.1,far:1e3};b=new g.OrthographicCamera(f,w,C,M,P,x),j.cameras.push(b)}return j.cameras.push(b),b}const a=o.computed(()=>e.value/t.value),s=o.computed(()=>j.cameras[0]);function i(){s.value instanceof g.PerspectiveCamera&&(s.value.aspect=a.value),s.value.updateProjectionMatrix()}function l(c){const h=o.inject("camera");c&&h&&(h.value=c,n("camera",h.value)),j.cameras.push(c),c instanceof g.PerspectiveCamera&&(c.aspect=a.value),c.updateProjectionMatrix()}return o.watch(a,i),{activeCamera:s,createCamera:r,updateCamera:i,pushCamera:l}}let _={...ne};delete _.Scene;function k(){return{extend:t=>{_=Object.assign(_,t)},catalogue:_}}const ae=e=>typeof e<"u",B=e=>!!e&&e.constructor===Array;function oe(e){return typeof e=="number"?[e,e,e]:e instanceof g.Vector3?[e.x,e.y,e.z]:e}function W(e){return e instanceof g.Color?e:Array.isArray(e)?new g.Color(...e):new g.Color(e)}const N="[TresJS \u25B2 \u25A0 \u25CF] ";function I(){function e(r,a){console.error(`${N} ${r}`,a||"")}function t(r){console.warn(`${N} ${r}`)}function n(r,a){}return{logError:e,logWarning:t,logMessage:n}}const se=["rotation","scale","position"];function q(e){const{logMessage:t,logError:n}=I();function r(a){return Object.entries(a).filter(([s,i])=>{var l,c;return(c=(l=i==null?void 0:i.prototype)==null?void 0:l.constructor)==null?void 0:c.toString().includes("class")}).map(([s,i])=>{const l=`${e}${s}`,c=o.defineComponent({name:l,setup(h,{slots:f,attrs:w,...C}){t(l,{props:h,slots:f,attrs:w,ctx:C});let M;const{scene:P}=D(),{pushCamera:x}=z();function U(){if((f==null?void 0:f.default)&&(f==null?void 0:f.default())){const O=f.default().map(m=>{var S;let v;const y=m.type.name.replace(e,"");return(S=m==null?void 0:m.props)!=null&&S.args?v=new a[y](...m.props.args):v=new a[y],m!=null&&m.props&&A(m.props,v),v});M=new i(...O)}else w.args?M=new i(...w.args):M=new i;A(w,M),l.includes("Camera")&&x(M),M.isObject3D&&(P==null||P.value.add(M)),t("Instance added",P),C.expose(M)}function A(O,m){Object.entries(O).forEach(([v,y])=>{const S=v.replace(/(-\w)/g,L=>L[1].toUpperCase());if(!(S==="args"||y===void 0)){se.includes(v)&&y&&(y=oe(y));try{m[S]&&ae(m[S].set)?B(y)?m[S].set(...y):m[S].set(y):(y===""&&(y=!0),m[S]=y)}catch(L){n(`There was an error setting ${S} property`,L)}}}),O.ref&&(O.ref=m)}return U(),()=>{}}});return[l,c]})}return{createComponentInstances:r}}const G=p.createEventHook(),J=p.createEventHook(),K=p.createEventHook(),Q=new g.Clock,{pause:ie,resume:ce,isActive:ue}=p.useRafFn(()=>{const e=Q.getElapsedTime(),t=Q.getDelta();G.trigger({delta:t,elapsed:e}),J.trigger({delta:t,elapsed:e}),K.trigger({delta:t,elapsed:e})},{immediate:!1});function $(){return{onBeforeLoop:G.on,onLoop:J.on,onAfterLoop:K.on,pause:ie,resume:ce,isActive:ue}}const le=o.shallowRef(new g.Scene);function D(){return{scene:le}}function X(e){const t={nodes:{},materials:{}};return e&&e.traverse(n=>{n.name&&(t.nodes[n.name]=n),n.material&&!t.materials[n.material.name]&&(t.materials[n.material.name]=n.material)}),t}async function fe(e,t,n,r,a){const{logError:s}=I(),i=new e;a&&a(i),n&&n(e);const c=(Array.isArray(t)?t:[t]).map(h=>new Promise((f,w)=>{i.load(h,C=>{C.scene&&Object.assign(C,X(C.scene)),f(C)},r,C=>w(s("[useLoader] - Failed to load resource",C)))}));return B(t)?await Promise.all(c):await c[0]}async function pe(e){const t=new g.LoadingManager,n=new g.TextureLoader(t),r=a=>new Promise((s,i)=>{n.load(a,l=>s(l),()=>null,()=>{i(new Error("[useTextures] - Failed to load texture"))})});if(B(e)){const a=await Promise.all(e.map(s=>r(s)));return e.length>1?a:a[0]}else{const{map:a,displacementMap:s,normalMap:i,roughnessMap:l,metalnessMap:c,aoMap:h}=e;return{map:a?await r(a):null,displacementMap:s?await r(s):null,normalMap:i?await r(i):null,roughnessMap:l?await r(l):null,metalnessMap:c?await r(c):null,aoMap:h?await r(h):null}}}const T=o.reactive({});function F(){function e(n){return T[n]}function t(n,r){T[n]=r}return{state:T,...o.toRefs(T),getState:e,setState:t}}const d=o.shallowRef(),R=o.ref(!1);function Y(e,t,n){const{alpha:r=!1,antialias:a,depth:s,logarithmicDepthBuffer:i,failIfMajorPerformanceCaveat:l,precision:c,premultipliedAlpha:h,stencil:f,shadows:w=!1,shadowMapType:C=g.PCFShadowMap,physicallyCorrectLights:M=!1,outputEncoding:P=g.LinearEncoding,toneMapping:x=g.NoToneMapping,toneMappingExposure:U=1,context:A=void 0,powerPreference:O="default",preserveDrawingBuffer:m=!1,clearColor:v=W("#000000"),windowSize:y=!1}=n,{width:S,height:L}=y?p.useWindowSize():p.useElementSize(t),{pixelRatio:Z}=p.useDevicePixelRatio(),{pause:we,resume:Ce}=$(),ye=o.computed(()=>S.value/L.value),E=()=>{!d.value||(d.value.setSize(S.value,L.value),d.value.setPixelRatio(Z.value))},H=()=>{!d.value||(d.value.shadowMap.enabled=p.resolveUnref(w),d.value.outputEncoding=p.resolveUnref(P),d.value.shadowMap.type=p.resolveUnref(C),d.value.physicallyCorrectLights=p.resolveUnref(M),d.value.toneMapping=p.resolveUnref(x),d.value.toneMappingExposure=p.resolveUnref(U),d.value.setClearColor(W(p.resolveUnref(v))))},Se=()=>{const ee=p.unrefElement(e);if(d.value||!ee)return;d.value=new g.WebGLRenderer({canvas:ee,alpha:r,antialias:a,context:A,depth:s,failIfMajorPerformanceCaveat:l,logarithmicDepthBuffer:i,powerPreference:O,precision:c,stencil:f,preserveDrawingBuffer:m,premultipliedAlpha:h});const{setState:ve}=F();ve("renderer",d.value),H(),E(),Ce(),R.value=!0},Me=()=>{!d.value||(d.value.dispose(),d.value=void 0,R.value=!1,we())};return o.watch([S,L,Z],E),o.watch(()=>[w,C,P,M,x,U,v],H),o.watch(()=>[e,t],()=>{p.unrefElement(e)&&p.unrefElement(t)&&Se()},{immediate:!0,deep:!0}),{renderer:d,isReady:R,dispose:Me,aspectRatio:ye}}const de=o.defineComponent({name:"TresCanvas",props:{shadows:Boolean,shadowMapType:Object,physicallyCorrectLights:Boolean,outputEncoding:Object,toneMapping:Object,toneMappingExposure:Number,context:Object,powerPreference:Object,preserveDrawingBuffer:Boolean,clearColor:String,windowSize:Boolean},setup(e,{slots:t,attrs:n}){const{logError:r}=I(),a=o.ref(),s=o.ref(),{renderer:i,dispose:l,aspectRatio:c}=Y(a,s,e),h=o.shallowRef();return o.provide("camera",h),o.provide("renderer",i),o.provide("aspect-ratio",c),t.default&&!t.default().some(f=>f.type.name==="Scene")&&r("TresCanvas must contain a Scene component."),t.default&&!t.default().some(f=>{var w;return(w=f.type.name)==null?void 0:w.includes("Camera")})&&r("Scene must contain a Camera component."),o.onBeforeUnmount(()=>l()),()=>{if(t.default)return o.h("div",{ref:s,style:{position:"relative",width:"100%",height:"100vh",...n.style}},[o.h("canvas",{ref:a,style:{width:"100%",height:"100%",position:"absolute",top:0,left:0}}),t.default()])}}}),me=o.defineComponent({name:"Scene",setup(e,{slots:t}){const{scene:n}=D(),r=o.inject("renderer"),{activeCamera:a}=z(),{onLoop:s}=$();return o.provide("local-scene",n),s(()=>{(r==null?void 0:r.value)&&(a==null?void 0:a.value)&&(n==null?void 0:n.value)&&r.value.render(n==null?void 0:n.value,a.value)}),()=>{if(t.default)return t.default()}}}),ge=Symbol("UseTresState"),he={install(e,t){const n=(t==null?void 0:t.prefix)||"Tres";e.component(`${n}Canvas`,de),e.component(`${n}Scene`,me);const{catalogue:r}=k(),{createComponentInstances:a}=q(n);a(t!=null&&t.extends?{...r,...t.extends}:r).forEach(([i,l])=>{e.component(i,l)})}};u.CameraType=V,u.UseTresStateSymbol=ge,u.default=he,u.trasverseObjects=X,u.useCamera=z,u.useCatalogue=k,u.useInstanceCreator=q,u.useLoader=fe,u.useRenderLoop=$,u.useRenderer=Y,u.useScene=D,u.useTexture=pe,u.useTres=F,Object.defineProperties(u,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
